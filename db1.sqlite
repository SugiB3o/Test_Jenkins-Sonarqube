BEGIN TRANSACTION;
CREATE TABLE IF NOT EXISTS "privileges" (
	"id"	INTEGER NOT NULL,
	"privilege"	VARCHAR(255) NOT NULL,
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "checklist_category" (
	"id"	INTEGER NOT NULL,
	"name"	VARCHAR(255) NOT NULL,
	"description"	TEXT,
	UNIQUE("name"),
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "questions" (
	"id"	INTEGER NOT NULL,
	"question"	TEXT NOT NULL,
	"checklist_type"	INTEGER NOT NULL,
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "lab_items" (
	"id"	INTEGER NOT NULL,
	"title"	TEXT NOT NULL,
	"link"	TEXT NOT NULL,
	"level"	INTEGER NOT NULL,
	"image_tag"	TEXT NOT NULL,
	"label"	TEXT NOT NULL,
	"has_hints"	BOOLEAN,
	PRIMARY KEY("id"),
	CHECK("has_hints" IN (0, 1))
);
CREATE TABLE IF NOT EXISTS "projects" (
	"id"	INTEGER NOT NULL,
	"name"	TEXT NOT NULL,
	"version"	TEXT NOT NULL,
	"description"	TEXT NOT NULL,
	"timestamp"	TEXT NOT NULL,
	UNIQUE("id"),
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "chatbot_log" (
	"id"	INTEGER NOT NULL,
	"question"	TEXT,
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "users" (
	"id"	INTEGER NOT NULL,
	"privilege_id"	INTEGER NOT NULL,
	"accessToken"	INTEGER NOT NULL,
	"username"	VARCHAR(255),
	"password"	TEXT,
	"access"	BOOLEAN NOT NULL,
	"activated"	BOOLEAN NOT NULL,
	"email"	VARCHAR(255) NOT NULL,
	UNIQUE("email"),
	UNIQUE("accessToken"),
	UNIQUE("username"),
	FOREIGN KEY("privilege_id") REFERENCES "privileges"("id"),
	PRIMARY KEY("id"),
	CHECK("access" IN (0, 1)),
	CHECK("activated" IN (0, 1))
);
CREATE TABLE IF NOT EXISTS "kb_items" (
	"kb_id"	INTEGER NOT NULL,
	"title"	TEXT,
	"content"	TEXT,
	"checklist_category_id"	INTEGER,
	FOREIGN KEY("checklist_category_id") REFERENCES "checklist_category"("id"),
	PRIMARY KEY("kb_id")
);
CREATE TABLE IF NOT EXISTS "code_items" (
	"id"	INTEGER NOT NULL,
	"title"	TEXT NOT NULL,
	"content"	TEXT NOT NULL,
	"code_lang"	TEXT NOT NULL,
	"checklist_category_id"	INTEGER,
	FOREIGN KEY("checklist_category_id") REFERENCES "checklist_category"("id"),
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "checklist_types" (
	"id"	INTEGER NOT NULL,
	"name"	TEXT NOT NULL,
	"description"	TEXT NOT NULL,
	"visibility"	BOOLEAN NOT NULL,
	"checklist_category_id"	INTEGER,
	FOREIGN KEY("checklist_category_id") REFERENCES "checklist_category"("id"),
	PRIMARY KEY("id"),
	CHECK("visibility" IN (0, 1))
);
CREATE TABLE IF NOT EXISTS "groups" (
	"id"	INTEGER NOT NULL,
	"owner_id"	INTEGER NOT NULL,
	"groupName"	VARCHAR(255) NOT NULL,
	"timestamp"	TEXT,
	FOREIGN KEY("owner_id") REFERENCES "users"("id"),
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "checklists_kb" (
	"id"	INTEGER NOT NULL,
	"checklist_id"	VARCHAR(255) NOT NULL,
	"content"	TEXT,
	"add_resources"	TEXT,
	"maturity"	INTEGER,
	"question_id"	INTEGER,
	"include_always"	BOOLEAN,
	"kb_id"	INTEGER,
	"checklist_type"	INTEGER NOT NULL,
	FOREIGN KEY("kb_id") REFERENCES "kb_items"("kb_id"),
	FOREIGN KEY("question_id") REFERENCES "questions"("id"),
	PRIMARY KEY("id"),
	CHECK("include_always" IN (0, 1))
);
CREATE TABLE IF NOT EXISTS "logs" (
	"id"	INTEGER NOT NULL,
	"date"	INTEGER NOT NULL,
	"time"	INTEGER NOT NULL,
	"threat"	TEXT NOT NULL,
	"ip"	TEXT NOT NULL,
	"user_id"	INTEGER NOT NULL,
	"message"	TEXT NOT NULL,
	"status"	TEXT NOT NULL,
	FOREIGN KEY("user_id") REFERENCES "users"("id"),
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "groupmembers" (
	"user_id"	INTEGER,
	"group_id"	INTEGER,
	FOREIGN KEY("group_id") REFERENCES "groups"("id"),
	FOREIGN KEY("user_id") REFERENCES "users"("id")
);
CREATE TABLE IF NOT EXISTS "project_sprints" (
	"sprint_id"	INTEGER NOT NULL,
	"name"	TEXT,
	"description"	TEXT,
	"group_id"	INTEGER,
	"project_id"	INTEGER,
	"checklist_type_id"	INTEGER,
	FOREIGN KEY("project_id") REFERENCES "projects"("id"),
	FOREIGN KEY("checklist_type_id") REFERENCES "checklist_types"("id"),
	FOREIGN KEY("group_id") REFERENCES "groups"("id"),
	PRIMARY KEY("sprint_id")
);
CREATE TABLE IF NOT EXISTS "checklist_kb_code_item" (
	"id"	INTEGER NOT NULL,
	"checklist_kb_id"	INTEGER NOT NULL,
	"code_items_id"	INTEGER NOT NULL,
	FOREIGN KEY("checklist_kb_id") REFERENCES "checklists_kb"("id"),
	FOREIGN KEY("code_items_id") REFERENCES "code_items"("id"),
	PRIMARY KEY("id")
);
CREATE TABLE IF NOT EXISTS "checklists_results" (
	"id"	INTEGER NOT NULL,
	"checklist_id"	INTEGER,
	"project_id"	INTEGER,
	"sprint_id"	INTEGER,
	"status"	INTEGER,
	"kb_id"	INTEGER,
	"checklist_type_id"	INTEGER,
	"evidence"	TEXT,
	"resolved"	BOOLEAN,
	FOREIGN KEY("checklist_id") REFERENCES "checklists_kb"("id"),
	FOREIGN KEY("project_id") REFERENCES "projects"("id"),
	FOREIGN KEY("sprint_id") REFERENCES "project_sprints"("sprint_id"),
	FOREIGN KEY("checklist_type_id") REFERENCES "checklist_types"("id"),
	FOREIGN KEY("kb_id") REFERENCES "kb_items"("kb_id"),
	PRIMARY KEY("id"),
	CHECK("resolved" IN (0, 1))
);
CREATE TABLE IF NOT EXISTS "question_results" (
	"id"	INTEGER NOT NULL,
	"project_id"	INTEGER,
	"sprint_id"	INTEGER,
	"question_id"	INTEGER,
	"result"	TEXT,
	"checklist_type"	INTEGER,
	FOREIGN KEY("project_id") REFERENCES "projects"("id"),
	FOREIGN KEY("sprint_id") REFERENCES "project_sprints"("sprint_id"),
	FOREIGN KEY("question_id") REFERENCES "questions"("id"),
	PRIMARY KEY("id")
);
INSERT INTO "privileges" VALUES (1,'edit:read:manage:delete');
INSERT INTO "privileges" VALUES (2,'edit:read:delete');
INSERT INTO "privileges" VALUES (3,'edit:read');
INSERT INTO "privileges" VALUES (4,'read');
INSERT INTO "checklist_category" VALUES (1,'Web applications','category for web collection');
INSERT INTO "checklist_category" VALUES (2,'Mobile applications','category for mobile collection');
INSERT INTO "checklist_category" VALUES (3,'Custom checklist','category for custom checklist collection');
INSERT INTO "questions" VALUES (1,'Secure Software Development Lifecycle Requirements',1);
INSERT INTO "questions" VALUES (2,'Authentication Architectural Requirements',1);
INSERT INTO "questions" VALUES (3,'Access Control Architectural Requirements',1);
INSERT INTO "questions" VALUES (4,'Input and Output Architectural Requirements',1);
INSERT INTO "questions" VALUES (5,'Cryptographic Architectural Requirements',1);
INSERT INTO "questions" VALUES (6,'Errors, Logging and Auditing Architectural Requirements',1);
INSERT INTO "questions" VALUES (7,'Data Protection and Privacy Architectural Requirements',1);
INSERT INTO "questions" VALUES (8,'Communications Architectural Requirements',1);
INSERT INTO "questions" VALUES (9,'Malicious Software Architectural Requirements',1);
INSERT INTO "questions" VALUES (10,'Password security requirements',2);
INSERT INTO "questions" VALUES (11,'General Authenticator Requirements (brute force, authenticator types, 2FA)',2);
INSERT INTO "questions" VALUES (12,'Authenticator Lifecycle Requirements (activation codes, FIDO tokens)',2);
INSERT INTO "questions" VALUES (13,'Credential Storage Requirements (salting/stretching, pbkdf2, bcrypt)',2);
INSERT INTO "questions" VALUES (14,'Credential Recovery Requirements (secret questions, default accounts, recovery tokens)',2);
INSERT INTO "questions" VALUES (15,'Look-up Secret Verifier Requirements (revocation, token randomness)',2);
INSERT INTO "questions" VALUES (16,'Out of Band Verifier Requirements (Reset links, SMS tokens)',2);
INSERT INTO "questions" VALUES (17,'Single or Multi Factor One Time Verifier Requirements',2);
INSERT INTO "questions" VALUES (18,'Cryptographic Software and Devices Verifier Requirements (TPM, HSM)',2);
INSERT INTO "questions" VALUES (19,'Service Authentication Requirements',2);
INSERT INTO "questions" VALUES (20,'Fundamental Session Management Requirements',3);
INSERT INTO "questions" VALUES (21,'Session Binding Requirements',3);
INSERT INTO "questions" VALUES (22,'Session Logout and Timeout Requirements',3);
INSERT INTO "questions" VALUES (23,'Cookie-based Session Management',3);
INSERT INTO "questions" VALUES (24,'Token-based Session Management',3);
INSERT INTO "questions" VALUES (25,'Defenses Against Session Management Exploits',3);
INSERT INTO "questions" VALUES (26,'General Access Control Design',4);
INSERT INTO "questions" VALUES (27,'Operation Level Access Control',4);
INSERT INTO "questions" VALUES (28,'Other Access Control Considerations',4);
INSERT INTO "questions" VALUES (29,'Input Validation Requirements (parameter binding, url redirects, structure checking credit cards, phone numbers, etc, http request methods)',5);
INSERT INTO "questions" VALUES (30,'Sanitization and Sandboxing Requirements (type/length checking, SSRF, wysiwyg/markdown/bbcode/etc)',5);
INSERT INTO "questions" VALUES (31,'Outputting user supplied input on the client side (browser)',5);
INSERT INTO "questions" VALUES (32,'Getting files from the local file system',5);
INSERT INTO "questions" VALUES (33,'Using data selection or database queries (e.g. SQL, HQL, ORM, NoSQL)',5);
INSERT INTO "questions" VALUES (34,'Using LDAP',5);
INSERT INTO "questions" VALUES (35,'Using functions that perfom OS commands',5);
INSERT INTO "questions" VALUES (36,'Using XML/Xpath?',5);
INSERT INTO "questions" VALUES (37,'Are you deserializng objects (json, xml, bytestreams, yaml, etc)',5);
INSERT INTO "questions" VALUES (38,'Does your data need to be stored encrypted?',6);
INSERT INTO "questions" VALUES (39,'Does your application need cryptgrapic functions (they need to be on par with the latest known to be secure standards)',6);
INSERT INTO "questions" VALUES (40,'Does your application need secure random values or UUIDs (are they tested for sufficient entropy?)',6);
INSERT INTO "questions" VALUES (41,'Do your secrets need to be managed in a key-vault?',6);
INSERT INTO "questions" VALUES (42,'Is the application logging sensitive information? (credentials, payment details, tokens, etc)',7);
INSERT INTO "questions" VALUES (43,'Does the application needs to actively do logging (Do logs exist for authentication/ access control decisions?)',7);
INSERT INTO "questions" VALUES (44,'Do you need to implement log protection (Are logs protected for un-authorized access, injection flaws(also in viewing software), and are timestamps synced to match respective timezones)',7);
INSERT INTO "questions" VALUES (45,'Do you need centrilized error handling (Are errors on the application gracefully handled and show non generic error messages?)',7);
INSERT INTO "questions" VALUES (46,'General data protection requirements',8);
INSERT INTO "questions" VALUES (47,'Client side data protection requirements (localstorage, session storage, cookies, etc)',8);
INSERT INTO "questions" VALUES (48,'requirements how to handle sensitive private data (personal identifiable infomation)',8);
INSERT INTO "questions" VALUES (49,'Communication security requirements',9);
INSERT INTO "questions" VALUES (50,'Server security communication requirements',9);
INSERT INTO "questions" VALUES (51,'Code integrity controls',10);
INSERT INTO "questions" VALUES (52,'Malicious code search',10);
INSERT INTO "questions" VALUES (53,'Deployed application integrity controls',10);
INSERT INTO "questions" VALUES (54,'Business Logic Security Requirements',11);
INSERT INTO "questions" VALUES (55,'File Upload Requirements',12);
INSERT INTO "questions" VALUES (56,'File Integrity Requirements',12);
INSERT INTO "questions" VALUES (57,'File execution Requirements',12);
INSERT INTO "questions" VALUES (58,'File Storage Requirements',12);
INSERT INTO "questions" VALUES (59,'File download Requirements',12);
INSERT INTO "questions" VALUES (60,'SSRF Protection Requirements',12);
INSERT INTO "questions" VALUES (61,'Generic Web Service Security Verification Requirements',13);
INSERT INTO "questions" VALUES (62,'RESTful Web Service Verification Requirements',13);
INSERT INTO "questions" VALUES (63,'SOAP Web Service Verification Requirements',13);
INSERT INTO "questions" VALUES (64,'GraphQL and other Web Service Data Layer Security Requirements',13);
INSERT INTO "questions" VALUES (65,'Build pipeline configuration',14);
INSERT INTO "questions" VALUES (66,'Dependency checking',14);
INSERT INTO "questions" VALUES (67,'Unintended Security Disclosure Requirements',14);
INSERT INTO "questions" VALUES (68,'HTTP Security Headers Requirements',14);
INSERT INTO "questions" VALUES (69,'Validate HTTP Request Header Requirements',14);
INSERT INTO "questions" VALUES (70,'Business Logic Architectural Requirements',1);
INSERT INTO "questions" VALUES (71,'Secure File Upload Architectural Requirementss',1);
INSERT INTO "questions" VALUES (72,'Configuration Architectural Requirements',1);
INSERT INTO "lab_items" VALUES (1,'Path traversal (LFI)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-1-filename-injection',1,'lfi','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (2,'Cross Site Scripting','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-3-cross-site-scripting',1,'xss','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (3,'Cross site scripting (attribute)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-3-cross-site-scripting-attribute',1,'xss-attribute','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (4,'Cross site scripting (href)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-3-cross-site-scripting-href',1,'xss-url','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (5,'XSSI','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-include-files-from-untrusted-sources-js',2,'untrusted-sources-js','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (6,'Cross site request forgery','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-5-csrf',3,'csrf','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (7,'Cross site request forgery (same site)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-5-csrf-samesite',3,'csrf-samesite','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (8,'External entity attack','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-6-xxe',2,'xxe','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (9,'Insecure file upload','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-13-file-upload',1,'file-upload','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (10,'Clickjacking','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-20-clickjacking',1,'x-allow-origin','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (11,'Rate-limiting','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-29-ratelimiting',1,'ratelimiting','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (12,'HttpOnly (session hijacking)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-39-httponly-session-hijacking-xss',3,'session-hijacking-xss','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (13,'Missing authorization','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-44-authorisation-missing',2,'auth-missing','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (14,'Exposed Docker daemon','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-45-exposed-docker',3,'none','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (15,'SQLI (union select)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-46-sqli-union-select',2,'sqli','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (16,'Open redirect (hard)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-67-open-redirect-hard',3,'url-redirection-harder','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (17,'CORS exploitation','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-112-cors-exploitation',3,'cors','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (18,'Formulla injection','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-95-formula-injection',1,'formula-injection','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (19,'Mass assingment attack','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-147-parameter-binding',1,'parameter-binding','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (20,'SQLI -like','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-156-sqli-like',2,'sqli-like','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (21,'SQLI-blind','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-156-sqli-blind',3,'sqli-blind','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (22,'Remote file inclusion 1','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-173-remote-file-inclusion',1,'rfi','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (23,'Remote file inclusion 2','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-173-lfi-2',1,'lfi-2','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (24,'Remote file inclusion 3','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-173-lfi-3',1,'lfi-3','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (25,'Content security policiy','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-178-content-security-policy',1,'csp','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (26,'Server side request forgery','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-262-server-side-request-forgery',3,'ssrf','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (27,'Tabnabbing','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-266-tabnabbing',2,'tabnabbing','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (28,'Server side template injection','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-267-server-side-template-injection',3,'ssti','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (29,'Insecure direct object reference','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-268-insecure-direct-object-references',2,'idor','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (30,'JWT null','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-7006-jwt-null',2,'jwt-null','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (31,'JWT weak secret','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-7006-jwt-secret',2,'jwt-secret','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (32,'Insecure deserialization (yaml)','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-deserialisation-yaml',3,'des-yaml','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (33,'Insecure deserialization pickle','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-des-pickle-2',3,'des-pickle-2','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (34,'Race condition','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-race-condition',3,'racecondition','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (35,'Regex Ddos','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-dos-regex',1,'dos-regex','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (36,'Command injection 1','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-cmd-injection-1',1,'cmd','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (37,'Command injection 2','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-cmd-injection-2',1,'cmd2','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (38,'Information disclosure 1','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-information-leakeage-comments',1,'info-leakeage-comments','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (39,'Information disclosure 2','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-information-leakeage-metadata',1,'info-leakeage-metadata','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (40,'Authentication bypass 1','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-auth-bypass-1',1,'auth-bypass-1','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (41,'Authentication bypass 2','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-auth-bypass-2',1,'auth-bypass-2','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (42,'Blind command injection','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-blind-cmd-injection-1',2,'cmd3','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (43,'Right to left override attack','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-xxx-right-to-left-override',1,'rtlo','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (44,'Session puzzeling','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-250-session-puzzling',3,'sessionpuzzle','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (45,'Graphql DOS','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-285-graphql-dos',3,'graphql-dos-resource-exhaustion','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (46,'GraphQL IDOR','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-285-graphql-idor',3,'graphql-idor','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (47,'GraphQL Injections','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-285-graphql-injections',3,'graphql-injections','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (48,'GraphQL Introspection','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-285-graphql-introspection',3,'graphql-info-introspection','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (49,'GraphQL Mutations','https://owasp-skf.gitbook.io/asvs-write-ups/kbid-285-graphql-mutations',3,'graphql-mutation','SKF-labs',NULL);
INSERT INTO "lab_items" VALUES (50,'API-only XSS','https://pwning.owasp-juice.shop/part2/xss.html#perform-a-persisted-xss-attack-without-using-the-frontend-application-at-all',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (51,'Access Log','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#gain-access-to-any-access-log-file-of-the-server',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (52,'Admin Registration','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#register-as-a-user-with-administrator-privileges',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (53,'Admin Section','https://pwning.owasp-juice.shop/part2/broken-access-control.html#access-the-administration-section-of-the-store',2,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (54,'Arbitrary File Write','https://pwning.owasp-juice.shop/part2/vulnerable-components.html#overwrite-the-legal-information-file',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (55,'Bjoerns Favorite Pet','https://pwning.owasp-juice.shop/part2/broken-authentication.html#reset-the-password-of-bjoerns-owasp-account-via-the-forgot-password-mechanism',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (56,'Blockchain Hype','https://pwning.owasp-juice.shop/part2/security-through-obscurity.html#learn-about-the-token-sale-before-its-official-announcement',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (57,'Blocked RCE DoS','https://pwning.owasp-juice.shop/part2/insecure-deserialization.html#perform-a-remote-code-execution-that-would-keep-a-less-hardened-application-busy-forever',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (58,'CAPTCHA Bypass','https://pwning.owasp-juice.shop/part2/broken-anti-automation.html#submit-10-or-more-customer-feedbacks-within-10-seconds',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (59,'Change Benders Password','https://pwning.owasp-juice.shop/part2/broken-authentication.html#change-benders-password-into-slurmcl4ssic-without-using-sql-injection-or-forgot-password',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (60,'Christmas Special','https://pwning.owasp-juice.shop/part2/injection.html#order-the-christmas-special-offer-of-2014',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (61,'CSP Bypass','https://pwning.owasp-juice.shop/part2/xss.html#bypass-the-content-security-policy-and-perform-an-xss-attack-on-a-legacy-page',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (62,'Client-side XSS Protection','https://pwning.owasp-juice.shop/part2/xss.html#perform-a-persisted-xss-attack-bypassing-a-client-side-security-mechanism',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (63,'Confidential Document','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#access-a-confidential-document',1,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (64,'DOM XSS','https://pwning.owasp-juice.shop/part2/xss.html#perform-a-dom-xss-attack',1,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (65,'Database Schema','https://pwning.owasp-juice.shop/part2/injection.html#exfiltrate-the-entire-db-schema-definition-via-sql-injection',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (66,'Deprecated Interface','https://pwning.owasp-juice.shop/part2/security-misconfiguration.html#use-a-deprecated-b2b-interface-that-was-not-properly-shut-down',2,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (67,'Easter Egg','https://pwning.owasp-juice.shop/part2/broken-access-control.html#find-the-hidden-easter-egg',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (68,'Email Leak','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#perform-an-unwanted-information-disclosure-by-accessing-data-cross-domain',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (69,'Ephemeral Accountant','https://pwning.owasp-juice.shop/part2/injection.html#log-in-with-the-non-existing-accountant-without-ever-registering-that-user',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (70,'Error Handling','https://pwning.owasp-juice.shop/part2/security-misconfiguration.html#provoke-an-error-that-is-neither-very-gracefully-nor-consistently-handled',1,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (71,'Expired Coupon','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#successfully-redeem-an-expired-campaign-coupon-code',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (72,'Extra Language','https://pwning.owasp-juice.shop/part2/broken-anti-automation.html#retrieve-the-language-file-that-never-made-it-into-production',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (73,'Five-Star Feedback','https://pwning.owasp-juice.shop/part2/broken-access-control.html#get-rid-of-all-5-star-customer-feedback',2,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (74,'Forged Coupon','https://pwning.owasp-juice.shop/part2/cryptographic-issues.html#forge-a-coupon-code-that-gives-you-a-discount-of-at-least-80',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (75,'Forged Feedback','https://pwning.owasp-juice.shop/part2/broken-access-control.html#post-some-feedback-in-another-users-name',3,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (76,'Forged Review','https://pwning.owasp-juice.shop/part2/broken-access-control.html#post-a-product-review-as-another-user-or-edit-any-users-existing-review',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (77,'Forged Signed JWT','https://pwning.owasp-juice.shop/part2/vulnerable-components.html#forge-an-almost-properly-rsa-signed-jwt-token',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (78,'Forgotten Developer Backup','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#access-a-developers-forgotten-backup-file',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (79,'Forgotten Sales Backup','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#access-a-salesmans-forgotten-backup-file',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (80,'Frontend Typosquatting','https://pwning.owasp-juice.shop/part2/vulnerable-components.html#inform-the-shop-about-a-typosquatting-imposter-that-dug-itself-deep-into-the-frontend',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (81,'GDPR Data Erasure','https://pwning.owasp-juice.shop/part2/broken-authentication.html#log-in-with-chris-erased-user-account',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (82,'GDPR Data Theft','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#steal-someone-elses-personal-data-without-using-injection',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (83,'HTTP-Header XSS','https://pwning.owasp-juice.shop/part2/xss.html#perform-a-persisted-xss-attack-through-an-http-header',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (84,'Imaginary Challenge','https://pwning.owasp-juice.shop/part2/cryptographic-issues.html#solve-challenge-2',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (85,'Leaked Access Logs','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#dumpster-dive-the-internet-for-a-leaked-password-and-log-in-to-the-original-user-account-it-belongs-to',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (86,'Leaked Unsafe Product','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#identify-an-unsafe-product-that-was-removed-from-the-shop-and-inform-the-shop-which-ingredients-are-dangerous',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (87,'Legacy Typosquatting','https://pwning.owasp-juice.shop/part2/vulnerable-components.html#inform-the-shop-about-a-typosquatting-trick-it-has-been-a-victim-of',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (88,'Login Admin','https://pwning.owasp-juice.shop/part2/injection.html#log-in-with-the-administrators-user-account',2,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (89,'Login Amy','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#log-in-with-amys-original-user-credentials',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (90,'Login Bender','https://pwning.owasp-juice.shop/part2/injection.html#log-in-with-benders-user-account',3,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (91,'Login Bjoern','https://pwning.owasp-juice.shop/part2/broken-authentication.html#log-in-with-bjoerns-gmail-account',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (92,'Login CISO','https://pwning.owasp-juice.shop/part2/broken-authentication.html#exploit-oauth-20-to-log-in-with-the-cisos-user-account',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (93,'Login Jim','https://pwning.owasp-juice.shop/part2/injection.html#log-in-with-jims-user-account',3,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (94,'Login MC SafeSearch','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#log-in-with-mc-safesearchs-original-user-credentials',2,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (95,'Login Support Team','https://pwning.owasp-juice.shop/part2/security-misconfiguration.html#log-in-with-the-support-teams-original-user-credentials',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (96,'Manipulate Basket','https://pwning.owasp-juice.shop/part2/broken-access-control.html#put-an-additional-product-into-another-users-shopping-basket',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (97,'Misplaced Signature File','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#access-a-misplaced-siem-signature-file',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (98,'Multiple Likes','https://pwning.owasp-juice.shop/part2/broken-anti-automation.html#like-any-review-at-least-three-times-as-the-same-user',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (99,'Nested Easter Egg','https://pwning.owasp-juice.shop/part2/cryptographic-issues.html#apply-some-advanced-cryptanalysis-to-find-the-real-easter-egg',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (100,'NoSQL DoS','https://pwning.owasp-juice.shop/part2/injection.html#let-the-server-sleep-for-some-time',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (101,'NoSQL Exfiltration','https://pwning.owasp-juice.shop/part2/injection.html#all-your-orders-are-belong-to-us',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (102,'NoSQL Manipulation','https://pwning.owasp-juice.shop/part2/injection.html#update-multiple-product-reviews-at-the-same-time',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (103,'Outdated Whitelist','https://pwning.owasp-juice.shop/part2/unvalidated-redirects.html#let-us-redirect-you-to-one-of-our-crypto-currency-addresses',1,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (104,'Password Strength','https://pwning.owasp-juice.shop/part2/broken-authentication.html#log-in-with-the-administrators-user-credentials-without-previously-changing-them-or-applying-sql-injection',2,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (105,'Payback Time','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#place-an-order-that-makes-you-rich',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (106,'Premium Paywall','https://pwning.owasp-juice.shop/part2/cryptographic-issues.html#unlock-premium-challenge-to-access-exclusive-content',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (107,'Privacy Policy','https://pwning.owasp-juice.shop/part2/miscellaneous.html#read-our-privacy-policy',1,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (108,'Privacy Policy Inspection','https://pwning.owasp-juice.shop/part2/security-through-obscurity.html#prove-that-you-actually-read-our-privacy-policy',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (109,'Product Tampering','https://pwning.owasp-juice.shop/part2/broken-access-control.html#change-the-href-of-the-link-within-the-o-saft-product-description',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (110,'Reflected XSS','https://pwning.owasp-juice.shop/part2/xss.html#perform-a-reflected-xss-attack',2,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (111,'Repetitive Registration','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#follow-the-dry-principle-while-registering-a-user',1,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (112,'Reset Benders Password','https://pwning.owasp-juice.shop/part2/broken-authentication.html#reset-benders-password-via-the-forgot-password-mechanism',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (113,'Reset Bjoerns Password','https://pwning.owasp-juice.shop/part2/broken-authentication.html#reset-the-password-of-bjoerns-internal-account-via-the-forgot-password-mechanism',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (114,'Reset Jims Password','https://pwning.owasp-juice.shop/part2/broken-authentication.html#reset-jims-password-via-the-forgot-password-mechanism',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (115,'Reset Mortys Password','https://pwning.owasp-juice.shop/part2/broken-anti-automation.html#reset-mortys-password-via-the-forgot-password-mechanism',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (116,'Retrieve Blueprint','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#deprive-the-shop-of-earnings-by-downloading-the-blueprint-for-one-of-its-products',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (117,'SSRF','https://pwning.owasp-juice.shop/part2/broken-access-control.html#request-a-hidden-resource-on-server-through-server',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (118,'SSTi','https://pwning.owasp-juice.shop/part2/injection.html#infect-the-server-with-juicy-malware-by-abusing-arbitrary-command-execution',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (119,'Score Board','https://pwning.owasp-juice.shop/part2/score-board.html#find-the-carefully-hidden-score-board-page',1,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (120,'Security Policy','https://pwning.owasp-juice.shop/part2/miscellaneous.html#behave-like-any-white-hat-should-before-getting-into-the-action',2,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (121,'Server-side XSS Protection','https://pwning.owasp-juice.shop/part2/xss.html#perform-a-persisted-xss-attack-bypassing-a-server-side-security-mechanism',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (122,'Steganography','https://pwning.owasp-juice.shop/part2/security-through-obscurity.html#rat-out-a-notorious-character-hiding-in-plain-sight-in-the-shop',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (123,'Successful RCE DoS','https://pwning.owasp-juice.shop/part2/insecure-deserialization.html#perform-a-remote-code-execution-that-occupies-the-server-for-a-while-without-using-infinite-loops',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (124,'Supply Chain Attack','https://pwning.owasp-juice.shop/part2/vulnerable-components.html#inform-the-development-team-about-a-danger-to-some-of-their-credentials',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (125,'Two Factor Authentication','https://pwning.owasp-juice.shop/part2/broken-authentication.html#solve-the-2fa-challenge-for-user-wurstbrot',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (126,'Unsigned JWT','https://pwning.owasp-juice.shop/part2/vulnerable-components.html#forge-an-essentially-unsigned-jwt-token',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (127,'Upload Size','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#upload-a-file-larger-than-100-kb',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (128,'Upload Type','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#upload-a-file-that-has-no-pdf-or-zip-extension',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (129,'User Credentials','https://pwning.owasp-juice.shop/part2/injection.html#retrieve-a-list-of-all-user-credentials-via-sql-injection',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (130,'Video XSS','https://pwning.owasp-juice.shop/part2/xss.html#embed-an-xss-payload-into-our-promo-video',6,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (131,'View Basket','https://pwning.owasp-juice.shop/part2/broken-access-control.html#view-another-users-shopping-basket',2,'juice-shop','juice-shop',1);
INSERT INTO "lab_items" VALUES (132,'Vulnerable Library','https://pwning.owasp-juice.shop/part2/vulnerable-components.html#inform-the-shop-about-a-vulnerable-library-it-is-using',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (133,'Weird Crypto','https://pwning.owasp-juice.shop/part2/cryptographic-issues.html#inform-the-shop-about-an-algorithm-or-library-it-should-definitely-not-use-the-way-it-does',2,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (134,'Whitelist Bypass','https://pwning.owasp-juice.shop/part2/unvalidated-redirects.html#enforce-a-redirect-to-a-page-you-are-not-supposed-to-redirect-to',4,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (135,'XXE Data Access','https://pwning.owasp-juice.shop/part2/xxe.html#retrieve-the-content-of-cwindowssystemini-or-etcpasswd-from-the-server',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (136,'XXE DoS','https://pwning.owasp-juice.shop/part2/xxe.html#give-the-server-something-to-chew-on-for-quite-a-while',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (137,'Zero Stars','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#give-a-devastating-zero-star-feedback-to-the-store',1,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (138,'Missing Encoding','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#retrieve-the-photo-of-bjoerns-cat-in-melee-combat-mode',1,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (139,'Cross-Site Imaging','https://pwning.owasp-juice.shop/part2/injection.html#stick-cute-cross-domain-kittens-all-over-our-delivery-boxes',5,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (140,'Exposed Metrics','https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#find-the-endpoint-that-serves-usage-data-to-be-scraped-by-a-popular-monitoring-system',1,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (141,'Deluxe Fraud','https://pwning.owasp-juice.shop/part2/improper-input-validation.html#obtain-a-deluxe-membership-without-paying-for-it',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (142,'CSRF','https://pwning.owasp-juice.shop/part2/broken-access-control.html#change-the-name-of-a-user-by-performing-cross-site-request-forgery-from-another-origin',3,'juice-shop','juice-shop',NULL);
INSERT INTO "lab_items" VALUES (143,'Bonus Payload','https://pwning.owasp-juice.shop/part2/xss.html#use-the-bonus-payload-in-the-dom-xss-challenge',1,'juice-shop','juice-shop',1);
INSERT INTO "projects" VALUES (1,'Design Patterns ASVS LvL 1','4.0','Application Security Verification Standard','2020-10-05 13:37');
INSERT INTO "projects" VALUES (2,'Design Patterns ASVS LvL 2','4.0','Application Security Verification Standard','2020-10-05 13:37');
INSERT INTO "projects" VALUES (3,'Design Patterns ASVS LvL 3','4.0','Application Security Verification Standard','2020-10-05 13:37');
INSERT INTO "users" VALUES (1,1,1234,'admin','Sendo@2021',0,1,'example@owasp.org');
INSERT INTO "kb_items" VALUES (1,'use as header','Description:

use as header


Mitigation:


use as header
',NULL);
INSERT INTO "kb_items" VALUES (2,'empty control','Description:

empty control

Mitigation:

empty control',1);
INSERT INTO "kb_items" VALUES (5,'J2EE Misconfiguration: Data Transmission Without Encryption','Description:

Information sent over a network can be compromised while in transit. An attacker may be able to read or modify the contents if the data are sent in plaintext or are weakly encrypted.



Mitigation:


PHASE:System Configuration:
The application configuration should ensure that SSL or an encryption mechanism of equivalent strength and vetted reputation is used for all accesscontrolled pages.

',1);
INSERT INTO "kb_items" VALUES (6,'J2EE Misconfiguration: Insufficient Session ID Length','Description:

The J2EE application is configured to use an insufficient session ID length.

If an attacker can guess or steal a session ID, then they may be able to take over the user''''s session (called session hijacking). The number of possible session IDs increases with increased session ID length, making it more difficult to guess or steal a session ID.

Mitigation:


PHASE:Implementation:
Session identifiers should be at least 128 bits long to prevent bruteforce session guessing. A shorter session identifier leaves the application open to bruteforce session guessing attacks.

PHASE:Implementation:
A lower bound on the number of valid session identifiers that are available to be guessed is the number of users that are active on a site at any given moment. However, any users that abandon their sessions without logging out will increase this number. (This is one of many good reasons to have a short inactive session timeout.) With a 64 bit session identifier, assume 32 bits of entropy. For a large web site, assume that the attacker can try 1,000 guesses per second and that there are 10,000 valid session identifiers at any given moment. Given these assumptions, the expected time for an attacker to successfully guess a valid session identifier is less than 4 minutes. Now assume a 128 bit session identifier that provides 64 bits of entropy. With a very large web site, an attacker might try 10,000 guesses per second with 100,000 valid session identifiers available to be guessed. Given these assumptions, the expected time for an attacker to successfully guess a valid session identifier is greater than 292 years.

',1);
INSERT INTO "kb_items" VALUES (7,'J2EE Misconfiguration: Missing Custom Error Page','Description:

The default error page of a web application should not display sensitive information about the software system.

A Web application must define a default error page for 4xx errors (e.g. 404), 5xx (e.g. 500) errors and catch java.lang.Throwable exceptions to prevent attackers from mining information from the application container''''s builtin error response. When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks.

Mitigation:


PHASE:Implementation:
Handle exceptions appropriately in source code.

PHASE:Implementation System Configuration:
Always define appropriate error pages. The application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and userfriendly in addition to being a good security practice, and a good configuration will also define a lastchance error handler that catches any exception that could possibly be thrown by the application.

PHASE:Implementation:
Do not attempt to process an error or attempt to mask it.

PHASE:Implementation:
Verify return values are correct and do not supply sensitive information about the system.

',1);
INSERT INTO "kb_items" VALUES (8,'J2EE Misconfiguration: Entity Bean Declared Remote','Description:

When an application exposes a remote interface for an entity bean, it might also expose methods that get or set the bean''''s data. These methods could be leveraged to read sensitive information, or to change data in ways that violate the application''''s expectations, potentially leading to other vulnerabilities.



Mitigation:


PHASE:Implementation:
Declare Java beans local when possible. When a bean must be remotely accessible, make sure that sensitive information is not exposed, and ensure that the application logic performs appropriate validation of any data that might be modified by an attacker.

',1);
INSERT INTO "kb_items" VALUES (9,'J2EE Misconfiguration: Weak Access Permissions for EJB Methods','Description:

If elevated access rights are assigned to EJB methods, then an attacker can take advantage of the permissions to exploit the software system.

If the EJB deployment descriptor contains one or more method permissions that grant access to the special ANYONE role, it indicates that access control for the application has not been fully thought through or that the application is structured in such a way that reasonable access control restrictions are impossible.

Mitigation:


PHASE:Architecture and Design System Configuration:
Follow the principle of least privilege when assigning access rights to EJB methods. Permission to invoke EJB methods should not be granted to the ANYONE role.

',1);
INSERT INTO "kb_items" VALUES (11,'ASP.NET Misconfiguration: Creating Debug Binary','Description:

Debugging messages help attackers learn about the system and plan a form of attack.

ASP .NET applications can be configured to produce debug binaries. These binaries give detailed debugging messages and should not be used in production environments. Debug binaries are meant to be used in a development or testing environment and can pose a security risk if they are deployed to production.

Mitigation:


PHASE:System Configuration:
Avoid releasing debug binaries into the production environment. Change the debug mode to false when the application is deployed into production.

',1);
INSERT INTO "kb_items" VALUES (12,'ASP.NET Misconfiguration: Missing Custom Error Page','Description:

An ASP .NET application must enable custom error pages in order to prevent attackers from mining information from the framework''''s builtin responses.



Mitigation:


PHASE:System Configuration:
Handle exceptions appropriately in source code. ASP .NET applications should be configured to use custom error pages instead of the framework default page.

PHASE:Architecture and Design:
Do not attempt to process an error or attempt to mask it.

PHASE:Implementation:
Verify return values are correct and do not supply sensitive information about the system.

',1);
INSERT INTO "kb_items" VALUES (13,'ASP.NET Misconfiguration: Password in Configuration File','Description:

Storing a plaintext password in a configuration file allows anyone who can read the file access to the passwordprotected resource making them an easy target for attackers.



Mitigation:


PHASE:Implementation:
Credentials stored in configuration files should be encrypted, Use standard APIs and industry accepted algorithms to encrypt the credentials stored in configuration files.

',1);
INSERT INTO "kb_items" VALUES (14,'Compiler Removal of Code to Clear Buffers','Description:

Sensitive memory is cleared according to the source code, but compiler optimizations leave the memory untouched when it is not read from again, aka dead store removal.

This compiler optimization error occurs when: 1. Secret data are stored in memory. 2. The secret data are scrubbed from memory by overwriting its contents. 3. The source code is compiled using an optimizing compiler, which identifies and removes the function that overwrites the contents as a dead store because the memory is not used subsequently.

Mitigation:


PHASE:Implementation:
Store the sensitive data in a volatile memory location if available.

PHASE:Build and Compilation:
If possible, configure your compiler so that it does not remove dead stores.

PHASE:Architecture and Design:
Where possible, encrypt sensitive data that are used by a software system.

',1);
INSERT INTO "kb_items" VALUES (15,'External Control of System or Configuration Setting','Description:

One or more system settings or configuration elements can be externally controlled by a user.

Allowing external control of system settings can disrupt service or cause an application to behave in unexpected, and potentially malicious ways.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Implementation Architecture and Design:
Because setting manipulation covers a diverse set of functions, any attempt at illustrating it will inevitably be incomplete. Rather than searching for a tightknit relationship between the functions addressed in the setting manipulation category, take a step back and consider the sorts of system values that an attacker should not be allowed to control.

PHASE:Implementation Architecture and Design:
In general, do not allow userprovided or otherwise untrusted data to control sensitive values. The leverage that an attacker gains by controlling these values is not always immediately obvious, but do not underestimate the creativity of the attacker.

',1);
INSERT INTO "kb_items" VALUES (20,'Improper Input Validation','Description:

The product does not validate or incorrectly validates input that can affect the control flow or data flow of a program.

When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Use an input validation framework such as Struts or the OWASP ESAPI Validation API. If you use Struts, be mindful of weaknesses covered by the CWE101 category.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use an input validation framework such as Struts or the OWASP ESAPI Validation API. If you use Struts, be mindful of weaknesses covered by the CWE101 category.

PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, email, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server. Even though clientside checks provide minimal benefits with respect to serverside security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, clientside errorchecking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in serverside processing time for accidental input errors, although this is typically a small savings.

PHASE:Implementation:
When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

PHASE:Implementation:
Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

PHASE:Implementation:
Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input''''s values fall within the expected range of allowable values and that multifield consistencies are maintained.

PHASE:Implementation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180, CWE181). Make sure that your application does not inadvertently decode the same input twice (CWE174). Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid doubledecoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properlyencoded dangerous content.

PHASE:Implementation:
When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

PHASE:Testing:
Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software''''s operation may slow down, but it should not become unstable, crash, or generate incorrect results.

',1);
INSERT INTO "kb_items" VALUES (22,'Improper Limitation of a Pathname to a Restricted Directory Path Traversal','Description:

The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.

Many file operations are intended to take place within a restricted directory. By using special elements such as .. and / separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ../ sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as /usr/local/bin, which may also be useful in accessing unexpected files. This is referred to as absolute path traversal. In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the software may add .txt to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked. Use a builtin path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE23, CWE59). This includes: realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs_path() in Perl realpath() in PHP

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

PHASE:Operation:STRATEGY:Firewall:
Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF185] provide this capability.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

PHASE:Architecture and Design Operation:STRATEGY:Attack Surface Reduction:
Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server''''s access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.

PHASE:Implementation:
Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages  but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues.

',1);
INSERT INTO "kb_items" VALUES (23,'Relative Path Traversal','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as .. that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked. Use a builtin path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE23, CWE59). This includes: realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs_path() in Perl realpath() in PHP

',1);
INSERT INTO "kb_items" VALUES (24,'Path Traversal: .. filedir','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ../ sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ../ manipulation is the canonical manipulation for operating systems that use / as directory separators, such as UNIX and Linuxbased systems. In some cases, it is useful for bypassing protection schemes in environments for which / is supported but not the primary separator, such as Windows, which uses but can also accept /.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (25,'Path Traversal:  .. filedir','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize /../ sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. Sometimes a program checks for ../ at the beginning of the input, so a /../ can bypass that check.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (26,'Path Traversal:  dir .. filename','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize /dir/../filename sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''/dir/../filename'''' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only checks for ../ at the beginning of the input, so a /../ can bypass that check.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (27,'Path Traversal: dir .. .. filename','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize multiple internal ../ sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''directory/../../filename'''' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only removes one ../ sequence, so multiple ../ can bypass that check. Alternately, this manipulation could be used to bypass a check for ../ at the beginning of the pathname, moving up more than one directory level.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (28,'Path Traversal: ..filedir','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize .. sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''..'''' manipulation is the canonical manipulation for operating systems that use as directory separators, such as Windows. However, it is also useful for bypassing path traversal protection schemes that only assume that the / separator is valid.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (29,'Path Traversal: ..filename','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ''''..filename'''' (leading backslash dot dot) sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. This is similar to CWE25, except using instead of /. Sometimes a program checks for .. at the beginning of the input, so a .. can bypass that check. It is also useful for bypassing path traversal protection schemes that only assume that the / separator is valid.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (30,'Path Traversal: dir..filename','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ''''dir..filename'''' (leading backslash dot dot) sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. This is similar to CWE26, except using instead of /. The ''''dir..filename'''' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only checks for .. at the beginning of the input, so a .. can bypass that check.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (31,'Path Traversal: dir....filename','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ''''dir....filename'''' (multiple internal backslash dot dot) sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''dir....filename'''' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only removes one .. sequence, so multiple .. can bypass that check. Alternately, this manipulation could be used to bypass a check for .. at the beginning of the pathname, moving up more than one directory level.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (32,'Path Traversal: ... Triple Dot','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ''''...'''' (triple dot) sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''...'''' manipulation is useful for bypassing some path traversal protection schemes. On some Windows systems, it is equivalent to .... and might bypass checks that assume only two dots are valid. Incomplete filtering, such as removal of ./ sequences, can ultimately produce valid .. sequences due to a collapse into unsafe value (CWE182).

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (33,'Path Traversal: .... Multiple Dot','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ''''....'''' (multiple dot) sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''....'''' manipulation is useful for bypassing some path traversal protection schemes. On some Windows systems, it is equivalent to ...... and might bypass checks that assume only two dots are valid. Incomplete filtering, such as removal of ./ sequences, can ultimately produce valid .. sequences due to a collapse into unsafe value (CWE182).

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (34,'Path Traversal: ....  ','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ''''....//'''' (doubled dot dot slash) sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''....//'''' manipulation is useful for bypassing some path traversal protection schemes. If ../ is filtered in a sequential fashion, as done by some regular expression engines, then ....// can collapse into the ../ unsafe value (CWE182). It could also be useful when .. is removed, if the operating system treats // and / as equivalent.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (35,'Path Traversal: ... ...  ','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ''''.../...//'''' (doubled triple dot slash) sequences that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory. The ''''.../...//'''' manipulation is useful for bypassing some path traversal protection schemes. If ../ is filtered in a sequential fashion, as done by some regular expression engines, then .../...// can collapse into the ../ unsafe value (CWE182). Removing the first ../ yields ....//; the second removal yields ../. Depending on the algorithm, the software could be susceptible to CWE34 but not CWE35, or vice versa.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (36,'Absolute Path Traversal','Description:

The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize absolute path sequences such as /abs/path that can resolve to a location that is outside of that directory.

This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (37,'Path Traversal:  absolute pathname here','Description:

A software system that accepts input in the form of a slash absolute path (''''/absolute/pathname/here'''') without appropriate validation can allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (38,'Path Traversal: absolutepathnamehere','Description:

A software system that accepts input in the form of a backslash absolute path (''''absolutepathnamehere'''') without appropriate validation can allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (39,'Path Traversal: C:dirname','Description:

An attacker can inject a drive letter or Windows volume letter (''''C:dirname'''') into a software system to potentially redirect access to an unintended location or arbitrary file.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (40,'Path Traversal: UNCsharename Windows UNC Share','Description:

An attacker can inject a Windows UNC share (''''UNCsharename'''') into a software system to potentially redirect access to an unintended location or arbitrary file.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (41,'Improper Resolution of Path Equivalence','Description:

The system or application is vulnerable to file system contents disclosure through path equivalence. Path equivalence involves the use of special characters in file and directory names. The associated manipulations are intended to generate multiple names for the same object.

Path equivalence is usually employed in order to circumvent access controls expressed using an incomplete set of file name or file path representations. This is different from path traversal, wherein the manipulations are performed to generate a name for a different object.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (42,'Path Equivalence: filename. Trailing Dot','Description:

A software system that accepts path input in the form of trailing dot (''''filedir.'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (43,'Path Equivalence: filename.... Multiple Trailing Dot','Description:

A software system that accepts path input in the form of multiple trailing dot (''''filedir....'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (44,'Path Equivalence: file.name Internal Dot','Description:

A software system that accepts path input in the form of internal dot (''''file.ordir'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (45,'Path Equivalence: file...name Multiple Internal Dot','Description:

A software system that accepts path input in the form of multiple internal dot (''''file...dir'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (46,'Path Equivalence: filename  Trailing Space','Description:

A software system that accepts path input in the form of trailing space (''''filedir '''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (47,'Path Equivalence:  filename Leading Space','Description:

A software system that accepts path input in the form of leading space ('''' filedir'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (48,'Path Equivalence: file name Internal Whitespace','Description:

A software system that accepts path input in the form of internal space (''''file(SPACE)name'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (49,'Path Equivalence: filename  Trailing Slash','Description:

A software system that accepts path input in the form of trailing slash (''''filedir/'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (50,'Path Equivalence:   multiple leading slash','Description:

A software system that accepts path input in the form of multiple leading slash (''''//multiple/leading/slash'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (51,'Path Equivalence:  multiple  internal slash','Description:

A software system that accepts path input in the form of multiple internal slash (''''/multiple//internal/slash/'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (52,'Path Equivalence:  multiple trailing slash  ','Description:

A software system that accepts path input in the form of multiple trailing slash (''''/multiple/trailing/slash//'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (53,'Path Equivalence: multipleinternalbackslash','Description:

A software system that accepts path input in the form of multiple internal backslash (''''multipletrailingslash'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (54,'Path Equivalence: filedir Trailing Backslash','Description:

A software system that accepts path input in the form of trailing backslash (''''filedir'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (55,'Path Equivalence:  .  Single Dot Directory','Description:

A software system that accepts path input in the form of single dot directory exploit (''''/./'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (56,'Path Equivalence: filedir* Wildcard','Description:

A software system that accepts path input in the form of asterisk wildcard (''''filedir*'''') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (57,'Path Equivalence: fakedir .. realdir filename','Description:

The software contains protection mechanisms to restrict access to ''''realdir/filename'''', but it constructs pathnames using external input in the form of ''''fakedir/../realdir/filename'''' that are not handled by those mechanisms. This allows attackers to perform unauthorized actions against the targeted file.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (58,'Path Equivalence: Windows 8.3 Filename','Description:

The software contains a protection mechanism that restricts access to a long filename on a Windows operating system, but the software does not properly restrict access to the equivalent short 8.3 filename.

On later Windows operating systems, a file can have a long name and a short name that is compatible with older Windows file systems, with up to 8 characters in the filename and 3 characters for the extension. These 8.3 filenames, therefore, act as an alternate name for files with long names, so they are useful pathname equivalence manipulations.

Mitigation:


PHASE:System Configuration:
Disable Windows from supporting 8.3 filenames by editing the Windows registry. Preventing 8.3 filenames will not remove previously generated 8.3 filenames.

',1);
INSERT INTO "kb_items" VALUES (59,'Improper Link Resolution Before File Access Link Following','Description:

The software attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Follow the principle of least privilege when assigning access rights to entities in a software system. Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.

',1);
INSERT INTO "kb_items" VALUES (61,'UNIX Symbolic Link Symlink Following','Description:

The software, when opening a file or directory, does not sufficiently account for when the file is a symbolic link that resolves to a target outside of the intended control sphere. This could allow an attacker to cause the software to operate on unauthorized files.

A software system that allows UNIX symbolic links (symlink) as part of paths whether in internal code or through user input can allow an attacker to spoof the symbolic link and traverse the file system to unintended locations or access arbitrary files. The symbolic link can permit an attacker to read/write/corrupt a file that they originally did not have permissions to access.

Mitigation:


PHASE:Implementation:
Symbolic link attacks often occur when a program creates a tmp directory that stores files/links. Access to the directory should be restricted to the program as to prevent attackers from manipulating the files.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Follow the principle of least privilege when assigning access rights to entities in a software system. Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.

',1);
INSERT INTO "kb_items" VALUES (62,'UNIX Hard Link','Description:

The software, when opening a file or directory, does not sufficiently account for when the name is associated with a hard link to a target that is outside of the intended control sphere. This could allow an attacker to cause the software to operate on unauthorized files.

Failure for a system to check for hard links can result in vulnerability to different types of attacks. For example, an attacker can escalate their privileges if a file used by a privileged program is replaced with a hard link to a sensitive file (e.g. /etc/passwd). When the process opens the file, the attacker can assume the privileges of that process.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Follow the principle of least privilege when assigning access rights to entities in a software system. Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.

',1);
INSERT INTO "kb_items" VALUES (64,'Windows Shortcut Following .LNK','Description:

The software, when opening a file or directory, does not sufficiently handle when the file is a Windows shortcut (.LNK) whose target is outside of the intended control sphere. This could allow an attacker to cause the software to operate on unauthorized files.

The shortcut (file with the .lnk extension) can permit an attacker to read/write a file that they originally did not have permissions to access.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Follow the principle of least privilege when assigning access rights to entities in a software system. Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.

',1);
INSERT INTO "kb_items" VALUES (65,'Windows Hard Link','Description:

The software, when opening a file or directory, does not sufficiently handle when the name is associated with a hard link to a target that is outside of the intended control sphere. This could allow an attacker to cause the software to operate on unauthorized files.

Failure for a system to check for hard links can result in vulnerability to different types of attacks. For example, an attacker can escalate their privileges if a file used by a privileged program is replaced with a hard link to a sensitive file (e.g. AUTOEXEC.BAT). When the process opens the file, the attacker can assume the privileges of that process, or prevent the program from accurately processing data.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Follow the principle of least privilege when assigning access rights to entities in a software system. Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.

',1);
INSERT INTO "kb_items" VALUES (66,'Improper Handling of File Names that Identify Virtual Resources','Description:

The product does not handle or incorrectly handles a file name that identifies a virtual resource that is not directly specified within the directory that is associated with the file name, causing the product to perform filebased operations on a resource that is not a file.

Virtual file names are represented like normal file names, but they are effectively aliases for other resources that do not behave like normal files. Depending on their functionality, they could be alternate entities. They are not necessarily listed in directories.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (67,'Improper Handling of Windows Device Names','Description:

The software constructs pathnames from user input, but it does not handle or incorrectly handles a pathname containing a Windows device name such as AUX or CON. This typically leads to denial of service or an information exposure when the application attempts to process the pathname as a regular file.

Not properly handling virtual filenames (e.g. AUX, CON, PRN, COM1, LPT1) can result in different types of vulnerabilities. In some cases an attacker can request a device via injection of a virtual filename in a URL, which may cause an error that leads to a denial of service or an error page that reveals sensitive information. A software system that allows device names to bypass filtering runs the risk of an attacker injecting malicious code in a file with the name of a device.

Mitigation:


PHASE:Implementation:
Be familiar with the device names in the operating system where your system is deployed. Check input for these device names.

',1);
INSERT INTO "kb_items" VALUES (69,'Improper Handling of Windows ::DATA Alternate Data Stream','Description:

The software does not properly prevent access to, or detect usage of, alternate data streams (ADS).

An attacker can use an ADS to hide information about a file (e.g. size, the name of the process) from a system or file browser tools such as Windows Explorer and ''''dir'''' at the command line utility. Alternately, the attacker might be able to bypass intended access restrictions for the associated data fork.

Mitigation:


PHASE:Testing:
Software tools are capable of finding ADSs on your system.

PHASE:Implementation:
Ensure that the source code correctly parses the filename to read or write to the correct stream.

',1);
INSERT INTO "kb_items" VALUES (72,'Improper Handling of Apple HFS+ Alternate Data Stream Path','Description:

The software does not properly handle special paths that may identify the data or resource fork of a file on the HFS+ file system.

If the software chooses actions to take based on the file name, then if an attacker provides the data or resource fork, the software may take unexpected actions. Further, if the software intends to restrict access to a file, then an attacker might still be able to bypass intended access restrictions by requesting the data or resource fork for that file.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (73,'External Control of File Name or Path','Description:

The software allows user input to control or influence paths or file names that are used in filesystem operations.

This could allow an attacker to access or modify system files or other files that are critical to the application. Path manipulation errors occur when the following two conditions are met: 1. An attacker can specify a path used in an operation on the filesystem. 2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted. For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.

Mitigation:


PHASE:Architecture and Design:
When the set of filenames is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap provide this capability.

PHASE:Architecture and Design Operation:
Run your code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict all access to files within a particular directory. Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Implementation:
Use a builtin path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE23, CWE59).

PHASE:Installation Operation:
Use OSlevel permissions and run as a lowprivileged user to limit the scope of any successful attack.

PHASE:Operation Implementation:
If you are using PHP, configure your application so that it does not use register_globals. During implementation, develop your application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

PHASE:Testing:
Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software''''s operation may slow down, but it should not become unstable, crash, or generate incorrect results.

PHASE:Testing:
Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.

',1);
INSERT INTO "kb_items" VALUES (74,'Improper Neutralization of Special Elements in Output Used by a Downstream Component Injection','Description:

The software constructs all or part of a command, data structure, or record using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.

Software has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for usercontrolled input that leads to injection problems. Injection problems encompass a wide variety of issues  all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common  i.e., they allow for the injection of control plane data into the usercontrolled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.

Mitigation:


PHASE:Requirements:
Programming languages and supporting technologies might be chosen which are not subject to these issues.

PHASE:Implementation:
Utilize an appropriate mix of whitelist and blacklist parsing to filter controlplane syntax from all input.

',1);
INSERT INTO "kb_items" VALUES (75,'Failure to Sanitize Special Elements into a Different Plane Special Element Injection','Description:

The software does not adequately filter usercontrolled input for special elements with control implications.



Mitigation:


PHASE:Requirements:
Programming languages and supporting technologies might be chosen which are not subject to these issues.

PHASE:Implementation:
Utilize an appropriate mix of whitelist and blacklist parsing to filter special element syntax from all input.

',1);
INSERT INTO "kb_items" VALUES (76,'Improper Neutralization of Equivalent Special Elements','Description:

The software properly neutralizes certain special elements, but it improperly neutralizes equivalent special elements.

The software may have a fixed list of special characters it believes is complete. However, there may be alternate encodings, or representations that also have the same meaning. For example, the software may filter out a leading slash (/) to prevent absolute path names, but does not account for a tilde (~) followed by a user name, which on some *nix systems could be expanded to an absolute pathname. Alternately, the software might filter a dangerous e commandline switch when calling an external program, but it might not account for exec or other switches that have the same semantics.

Mitigation:


PHASE:Requirements:
Programming languages and supporting technologies might be chosen which are not subject to these issues.

PHASE:Implementation:
Utilize an appropriate mix of whitelist and blacklist parsing to filter equivalent special element syntax from all input.

',1);
INSERT INTO "kb_items" VALUES (77,'Improper Neutralization of Special Elements used in a Command Command Injection','Description:

The software constructs all or part of a command using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.

Command injection vulnerabilities typically occur when: 1. Data enters the application from an untrusted source. 2. The data is part of a string that is executed as a command by the application. 3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. Command injection is a common problem with wrapper programs.

Mitigation:


PHASE:Architecture and Design:
If at all possible, use library calls rather than external processes to recreate the desired functionality.

PHASE:Implementation:
If possible, ensure that all external commands called from the program are statically created.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Operation:
Run time: Run time policy enforcement may be used in a whitelist fashion to prevent use of any nonsanctioned commands.

PHASE:System Configuration:
Assign permissions to the software system that prevents the user from accessing/opening privileged files.

',1);
INSERT INTO "kb_items" VALUES (78,'Improper Neutralization of Special Elements used in an OS Command OS Command Injection','Description:

The software constructs all or part of an OS command using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.

This could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attackercontrolled commands may run with special system privileges that increases the amount of damage. There are at least two subtypes of OS command injection: The application intends to execute a single, fixed program that is under its own control. It intends to use externallysupplied inputs as arguments to that program. For example, the program might use system(nslookup [HOSTNAME]) to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing. The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use exec([COMMAND]) to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line. From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.

Mitigation:


PHASE:Architecture and Design:
If at all possible, use library calls rather than external processes to recreate the desired functionality.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:
For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session''''s state instead of sending it out to the client in a hidden form field.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:
If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.

PHASE:Architecture and Design:STRATEGY:Parameterization:
If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing OS command strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defenseindepth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support freeform text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwisedangerous inputs like ; and > characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on wellstructured subject lines in order to pass messages to other components. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injectionbased attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

PHASE:Operation:STRATEGY:Compilation or Build Hardening:
Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl''''s T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE183 and CWE184).

PHASE:Operation:STRATEGY:Environment Hardening:
Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl''''s T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE183 and CWE184).

PHASE:Implementation:
Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages  but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.

PHASE:Operation:STRATEGY:Sandbox or Jail:
Use runtime policy enforcement to create a whitelist of allowable commands, then prevent use of any command that does not appear in the whitelist. Technologies such as AppArmor are available to do this.

PHASE:Operation:STRATEGY:Firewall:
Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues.

',1);
INSERT INTO "kb_items" VALUES (79,'Improper Neutralization of Input During Web Page Generation Cross site Scripting','Description:

The software does not neutralize or incorrectly neutralizes usercontrollable input before it is placed in output that is used as a web page that is served to other users.

Crosssite scripting (XSS) vulnerabilities occur when: 1. Untrusted data enters a web application, typically from a web request. 2. The web application dynamically generates a web page that contains this untrusted data. 3. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc. 4. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data. 5. Since the script comes from a web page that was sent by the web server, the victim''''s web browser executes the malicious script in the context of the web server''''s domain. 6. This effectively violates the intention of the web browser''''s sameorigin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain. There are three main kinds of XSS: Type 1: Reflected XSS (or NonPersistent)  The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker''''s content back to the victim, the content is executed by the victim''''s browser. Type 2: Stored XSS (or Persistent)  The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker''''s perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. Type 0: DOMBased XSS  In DOMbased XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOMbased XSS generally involves servercontrolled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the serversupplied script processes usersupplied data and then injects it back into the web page (such as with dynamic HTML), then DOMbased XSS is possible. Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim''''s machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim''''s account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim''''s machine, sometimes referred to as driveby hacking. In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft''''s AntiXSS library, the OWASP ESAPI Encoding module, and Apache Wicket.

PHASE:Implementation Architecture and Design:
Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multipart mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all nonalphanumeric characters. Parts of the same output document may require different encodings, which will vary depending on whether the output is in the: HTML body Element attributes (such as src=XYZ) URIs JavaScript sections Cascading Style Sheets and style property etc. Note that HTML Entity Encoding is only appropriate for the HTML body. Consult the XSS Prevention Cheat Sheet [REF724] for more details on the types of encoding and escaping that are needed.

PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, email, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.:EFFECTIVENESS:Limited

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Architecture and Design:STRATEGY:Parameterization:
If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:
With Struts, write all data from form beans with the bean''''s filter attribute set to true.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When dynamically constructing web pages, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defenseindepth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support freeform text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (<3) would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the < character, which would need to be escaped or otherwise handled. In this case, stripping the < might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injectionbased attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address. Ensure that you perform input validation at welldefined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

PHASE:Operation:STRATEGY:Firewall:
Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues.

',1);
INSERT INTO "kb_items" VALUES (80,'Improper Neutralization of Script Related HTML Tags in a Web Page Basic XSS','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as <, >, and & that could be interpreted as webscripting elements when they are sent to a downstream component that processes web pages.

This may allow such characters to be treated as control characters, which are executed clientside in the context of the user''''s session. Although this can be classified as an injection problem, the more pertinent issue is the improper conversion of such special characters to respective contextappropriate entities before displaying them to the user.

Mitigation:


PHASE:Implementation:
Carefully check each input parameter against a rigorous positive specification (whitelist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:
With Struts, write all data from form beans with the bean''''s filter attribute set to true.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (81,'Improper Neutralization of Script in an Error Message Web Page','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters that could be interpreted as webscripting elements when they are sent to an error page.

Error pages may include customized 403 Forbidden or 404 Not Found pages. When an attacker can trigger an error that contains script syntax within the attacker''''s input, then crosssite scripting attacks may be possible.

Mitigation:


PHASE:Implementation:
Do not write usercontrolled input to error pages.

PHASE:Implementation:
Carefully check each input parameter against a rigorous positive specification (whitelist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:
With Struts, write all data from form beans with the bean''''s filter attribute set to true.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (82,'Improper Neutralization of Script in Attributes of IMG Tags in a Web Page','Description:

The web application does not neutralize or incorrectly neutralizes scripting elements within attributes of HTML IMG tags, such as the src attribute.

Attackers can embed XSS exploits into the values for IMG attributes (e.g. SRC) that is streamed and then executed in a victim''''s browser. Note that when the page is loaded into a user''''s browsers, the exploit will automatically execute.

Mitigation:


PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (83,'Improper Neutralization of Script in Attributes in a Web Page','Description:

The software does not neutralize or incorrectly neutralizes javascript: or other URIs from dangerous attributes within tags, such as onmouseover, onload, onerror, or style.



Mitigation:


PHASE:Implementation:
Carefully check each input parameter against a rigorous positive specification (whitelist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including tag attributes, hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:
With Struts, write all data from form beans with the bean''''s filter attribute set to true.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (84,'Improper Neutralization of Encoded URI Schemes in a Web Page','Description:

The web application improperly neutralizes usercontrolled input for executable script disguised with URI encodings.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Resolve all URIs to absolute or canonical representations before processing.

PHASE:Implementation:STRATEGY:Input Validation:
Carefully check each input parameter against a rigorous positive specification (whitelist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including tag attributes, hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:
With Struts, write all data from form beans with the bean''''s filter attribute set to true.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (85,'Doubled Character XSS Manipulations','Description:

The web application does not filter usercontrolled input for executable script disguised using doubling of the involved characters.



Mitigation:


PHASE:Implementation:
Resolve all filtered input to absolute or canonical representations before processing.

PHASE:Implementation:
Carefully check each input parameter against a rigorous positive specification (whitelist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including tag attributes, hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:
With Struts, write all data from form beans with the bean''''s filter attribute set to true.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (86,'Improper Neutralization of Invalid Characters in Identifiers in Web Pages','Description:

The software does not neutralize or incorrectly neutralizes invalid characters or byte sequences in the middle of tag names, URI schemes, and other identifiers.

Some web browsers may remove these sequences, resulting in output that may have unintended control implications. For example, the software may attempt to remove a javascript: URI scheme, but a java%00script: URI may bypass this check and still be rendered as active javascript by some browsers, allowing XSS or other attacks.

Mitigation:


PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (87,'Improper Neutralization of Alternate XSS Syntax','Description:

The software does not neutralize or incorrectly neutralizes usercontrolled input for alternate script syntax.



Mitigation:


PHASE:Implementation:
Resolve all input to absolute or canonical representations before processing.

PHASE:Implementation:
Carefully check each input parameter against a rigorous positive specification (whitelist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including tag attributes, hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.

PHASE:Implementation:
With Struts, write all data from form beans with the bean''''s filter attribute set to true.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
To help mitigate XSS attacks against the user''''s session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user''''s session cookie from being accessible to malicious clientside scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the SetCookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (88,'Improper Neutralization of Argument Delimiters in a Command Argument Injection','Description:

The software constructs a string for a command to executed by a separate component in another control sphere, but it does not properly delimit the intended arguments, options, or switches within that command string.

When creating commands using interpolation into a string, developers may assume that only the arguments/options that they specify will be processed. This assumption may be even stronger when the programmer has encoded the command in a way that prevents separate commands from being provided maliciously, e.g. in the case of shell metacharacters. When constructing the command, the developer may use whitespace or other delimiters that are required to separate arguments when the command. However, if an attacker can provide an untrusted input that contains argumentseparating delimiters, then the resulting command will have more arguments than intended by the developer. The attacker may then be able to change the behavior of the command. Depending on the functionality supported by the extraneous arguments, this may have securityrelevant consequences.

Mitigation:


PHASE:Implementation:STRATEGY:Parameterization:
Where possible, avoid building a single string that contains the command and its arguments. Some languages or frameworks have functions that support specifying independent arguments, e.g. as an array, which is used to automatically perform the appropriate quoting or escaping while building the command. For example, in PHP, escapeshellarg() can be used to escape a single argument to system(), or exec() can be called with an array of arguments. In C, code can often be refactored from using system()  which accepts a single string  to using exec(), which requires separate function arguments for each parameter.:EFFECTIVENESS:High

PHASE:Architecture and Design:STRATEGY:Input Validation:
Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, email, files, databases, and any external systems that provide data to the application. Perform input validation at welldefined interfaces.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:
Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input''''s values fall within the expected range of allowable values and that multifield consistencies are maintained.

PHASE:Implementation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180, CWE181). Make sure that your application does not inadvertently decode the same input twice (CWE174). Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid doubledecoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properlyencoded dangerous content.

PHASE:Implementation:
When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.

PHASE:Implementation:
When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

PHASE:Testing:
Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software''''s operation may slow down, but it should not become unstable, crash, or generate incorrect results.

',1);
INSERT INTO "kb_items" VALUES (89,'Improper Neutralization of Special Elements used in an SQL Command SQL Injection','Description:

The software constructs all or part of an SQL command using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.

Without sufficient removal or quoting of SQL syntax in usercontrollable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the backend database, possibly including execution of system commands. SQL injection has become a common issue with databasedriven web sites. The flaw is easily detected, and easily exploited, and as such, any site or software package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.

PHASE:Architecture and Design:STRATEGY:Parameterization:
If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may reintroduce the possibility of SQL injection. [REF867]

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others'''' data. Use the strictest permissions possible on all database objects, such as executeonly for stored procedures.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defenseindepth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support freeform text fields that could contain arbitrary characters. For example, the name O''''Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the '''' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow metacharacters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape metacharacters before use, and you may not have control over those processes.

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

PHASE:Implementation:
Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages  but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.

PHASE:Operation:STRATEGY:Firewall:
Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues.

',1);
INSERT INTO "kb_items" VALUES (90,'Improper Neutralization of Special Elements used in an LDAP Query LDAP Injection','Description:

The software constructs all or part of an LDAP query using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when it is sent to a downstream component.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

',1);
INSERT INTO "kb_items" VALUES (91,'XML Injection aka Blind XPath Injection','Description:

The software does not properly neutralize special elements that are used in XML, allowing attackers to modify the syntax, content, or commands of the XML before it is processed by an end system.

Within XML, special elements could include reserved words or characters such as <, >, , and &, which could then be used to add new data or modify XML syntax.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

',1);
INSERT INTO "kb_items" VALUES (93,'Improper Neutralization of CRLF Sequences CRLF Injection','Description:

The software uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.



Mitigation:


PHASE:Implementation:
Avoid using CRLF as a special sequence.

PHASE:Implementation:
Appropriately filter or quote CRLF sequences in usercontrolled input.

',1);
INSERT INTO "kb_items" VALUES (94,'Improper Control of Generation of Code Code Injection','Description:

The software constructs all or part of a code segment using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.

When software allows a user''''s input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the software. Such an alteration could lead to arbitrary code execution. Injection problems encompass a wide variety of issues  all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common  i.e., they allow for the injection of control plane data into the usercontrolled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.

Mitigation:


PHASE:Architecture and Design:
Refactor your program so that you do not have to dynamically generate code.

PHASE:Architecture and Design:
Run your code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your software. Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. To reduce the likelihood of code injection, use stringent whitelists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

PHASE:Testing:
Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software''''s operation may slow down, but it should not become unstable, crash, or generate incorrect results.

PHASE:Operation:STRATEGY:Compilation or Build Hardening:
Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl''''s T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE183 and CWE184).

PHASE:Operation:STRATEGY:Environment Hardening:
Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl''''s T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE183 and CWE184).

',1);
INSERT INTO "kb_items" VALUES (95,'Improper Neutralization of Directives in Dynamically Evaluated Code Eval Injection','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. eval).

This may allow an attacker to execute arbitrary code, or at least modify what code can be executed.

Mitigation:


PHASE:Architecture and Design Implementation:
If possible, refactor your code so that it does not need to use eval() at all.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180, CWE181). Make sure that your application does not inadvertently decode the same input twice (CWE174). Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid doubledecoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properlyencoded dangerous content.

',1);
INSERT INTO "kb_items" VALUES (96,'Improper Neutralization of Directives in Statically Saved Code Static Code Injection','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Perform proper output validation and escaping to neutralize all code syntax from data written to code files.

',1);
INSERT INTO "kb_items" VALUES (97,'Improper Neutralization of Server Side Includes SSI Within a Web Page','Description:

The software generates a web page, but does not neutralize or incorrectly neutralizes usercontrollable input that could be interpreted as a serverside include (SSI) directive.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (98,'Improper Control of Filename for Include Require Statement in PHP Program PHP Remote File Inclusion','Description:

The PHP application receives input from an upstream component, but it does not restrict or incorrectly restricts the input before its usage in require, include, or similar functions.

In certain versions and configurations of PHP, this can allow an attacker to specify a URL to a remote location from which the software will obtain the code to execute. In other cases in association with path traversal, the attacker can specify a local file that may contain executable statements that can be parsed by PHP.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF185] provide this capability.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent lists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Architecture and Design Operation:STRATEGY:Attack Surface Reduction:
Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server''''s access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.

PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, email, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.

PHASE:Operation:STRATEGY:Firewall:
Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
Develop and run your code in the most recent versions of PHP available, preferably PHP 6 or later. Many of the highly risky features in earlier PHP interpreters have been removed, restricted, or disabled by default.

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues. Often, programmers do not protect direct access to files intended only to be included by core programs. These include files may assume that critical variables have already been initialized by the calling program. As a result, the use of register_globals combined with the ability to directly access the include file may allow attackers to conduct file inclusion attacks. This remains an extremely common pattern as of 2009.

PHASE:Operation:STRATEGY:Environment Hardening:
Set allow_url_fopen to false, which limits the ability to include files from remote locations.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (99,'Improper Control of Resource Identifiers Resource Injection','Description:

The software receives input from an upstream component, but it does not restrict or incorrectly restricts the input before it is used as an identifier for a resource that may be outside the intended sphere of control.

A resource injection issue occurs when the following two conditions are met: An attacker can specify the identifier used to access a system resource. For example, an attacker might be able to specify part of the name of a file to be opened or a port number to be used. By specifying the resource, the attacker gains a capability that would not otherwise be permitted. For example, the program may give the attacker the ability to overwrite the specified file, run with a configuration controlled by the attacker, or transmit sensitive information to a thirdparty server. This may enable an attacker to access or modify otherwise protected system resources.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, it can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

',1);
INSERT INTO "kb_items" VALUES (102,'Struts: Duplicate Validation Forms','Description:

The application uses multiple validation forms with the same name, which might cause the Struts Validator to validate a form that the programmer does not expect.

If two validation forms have the same name, the Struts Validator arbitrarily chooses one of the forms to use for input validation and discards the other. This decision might not correspond to the programmer''''s expectations, possibly leading to resultant weaknesses. Moreover, it indicates that the validation logic is not uptodate, and can indicate that other, more subtle validation errors are present.

Mitigation:


PHASE:Implementation:
The DTD or schema validation will not catch the duplicate occurrence of the same form name. To find the issue in the implementation, manual checks or automated static analysis could be applied to the xml configuration files.

',1);
INSERT INTO "kb_items" VALUES (103,'Struts: Incomplete validate Method Definition','Description:

The application has a validator form that either does not define a validate() method, or defines a validate() method but does not call super.validate().

If you do not call super.validate(), the Validation Framework cannot check the contents of the form against a validation form. In other words, the validation framework will be disabled for the given form.

Mitigation:


PHASE:Implementation:
Implement the validate() method and call super.validate() within that method.

',1);
INSERT INTO "kb_items" VALUES (104,'Struts: Form Bean Does Not Extend Validation Class','Description:

If a form bean does not extend an ActionForm subclass of the Validator framework, it can expose the application to other weaknesses related to insufficient input validation.



Mitigation:


PHASE:Implementation:
Ensure that all forms extend one of the Validation Classes.

',1);
INSERT INTO "kb_items" VALUES (105,'Struts: Form Field Without Validator','Description:

The application has a form field that is not validated by a corresponding validation form, which can introduce other weaknesses related to insufficient input validation.

Omitting validation for even a single input field may give attackers the leeway they need to compromise the application. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.

Mitigation:


PHASE:Implementation:
Ensure that you validate all form fields. If a field is unused, it is still important to constrain it so that it is empty or undefined.

',1);
INSERT INTO "kb_items" VALUES (106,'Struts: Plug in Framework not in Use','Description:

When an application does not use an input validation framework such as the Struts Validator, there is a greater risk of introducing weaknesses related to insufficient input validation.

Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input leads to crosssite scripting, process control, and SQL injection vulnerabilities, among others. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Use an input validation framework such as Struts.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use an input validation framework such as Struts.

PHASE:Implementation:STRATEGY:Input Validation:
Use the Struts Validator to validate all program input before it is processed by the application. Ensure that there are no holes in your configuration of the Struts Validator. Example uses of the validator include checking to ensure that: Phone number fields contain only valid characters in phone numbers Boolean values are only T or F Freeform strings are of a reasonable length and composition

PHASE:Implementation:STRATEGY:Libraries or Frameworks:
Use the Struts Validator to validate all program input before it is processed by the application. Ensure that there are no holes in your configuration of the Struts Validator. Example uses of the validator include checking to ensure that: Phone number fields contain only valid characters in phone numbers Boolean values are only T or F Freeform strings are of a reasonable length and composition

',1);
INSERT INTO "kb_items" VALUES (107,'Struts: Unused Validation Form','Description:

An unused validation form indicates that validation logic is not uptodate.

It is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the presence of an unused validation form.

Mitigation:


PHASE:Implementation:
Remove the unused Validation Form from the validation.xml file.

',1);
INSERT INTO "kb_items" VALUES (108,'Struts: Unvalidated Action Form','Description:

Every Action Form must have a corresponding validation form.

If a Struts Action Form Mapping specifies a form, it must have a validation form defined under the Struts Validator.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Map every Action Form to a corresponding validation form. An action or a form may perform validation in other ways, but the Struts Validator provides an excellent way to verify that all input receives at least a basic level of validation. Without this approach, it is difficult, and often impossible, to establish with a high level of confidence that all input is validated.

',1);
INSERT INTO "kb_items" VALUES (109,'Struts: Validator Turned Off','Description:

Automatic filtering via a Struts bean has been turned off, which disables the Struts Validator and custom validation logic. This exposes the application to other weaknesses related to insufficient input validation.



Mitigation:


PHASE:Implementation:
Ensure that an action form mapping enables validation. Set the validate field to true.

',1);
INSERT INTO "kb_items" VALUES (110,'Struts: Validator Without Form Field','Description:

Validation fields that do not appear in forms they are associated with indicate that the validation logic is out of date.

It is easy for developers to forget to update validation logic when they make changes to an ActionForm class. One indication that validation logic is not being properly maintained is inconsistencies between the action form and the validation form. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (111,'Direct Use of Unsafe JNI','Description:

When a Java application uses the Java Native Interface (JNI) to call code written in another programming language, it can expose the application to weaknesses in that code, even if those weaknesses cannot occur in Java.

Many safety features that programmers may take for granted simply do not apply for native code, so you must carefully review all such code for potential problems. The languages used to implement native code may be more susceptible to buffer overflows and other attacks. Native code is unprotected by the security features enforced by the runtime environment, such as strong typing and array bounds checking.

Mitigation:


PHASE:Implementation:
Implement error handling around the JNI call.

PHASE:Implementation:STRATEGY:Refactoring:
Do not use JNI calls if you don''''t trust the native library.

PHASE:Implementation:STRATEGY:Refactoring:
Be reluctant to use JNI calls. A Java API equivalent may exist.

',1);
INSERT INTO "kb_items" VALUES (112,'Missing XML Validation','Description:

The software accepts XML from an untrusted source but does not validate the XML against the proper schema.

Most successful attacks begin with a violation of the programmer''''s assumptions. By accepting an XML document without validating it against a DTD or XML schema, the programmer leaves a door open for attackers to provide unexpected, unreasonable, or malicious input.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Always validate XML input against a known XML Schema or DTD. It is not possible for an XML parser to validate all aspects of a document''''s content because a parser cannot understand the complete semantics of the data. However, a parser can do a complete and thorough job of checking the document''''s structure and therefore guarantee to the code that processes the document that the content is wellformed.

',1);
INSERT INTO "kb_items" VALUES (113,'Improper Neutralization of CRLF Sequences in HTTP Headers HTTP Response Splitting','Description:

The software receives data from an upstream component, but does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.

Including unvalidated data in an HTTP header allows an attacker to specify the entirety of the HTTP response rendered by the browser. When an HTTP request contains unexpected CR (carriage return, also given by %0d or r) and LF (line feed, also given by %0a or n) characters the server may respond with an output stream that is interpreted as two different HTTP responses (instead of one). An attacker can control the second response and mount attacks such as crosssite scripting and cache poisoning attacks. HTTP response splitting weaknesses may be present when: Data enters a web application through an untrusted source, most frequently an HTTP request. The data is included in an HTTP response header sent to a web user without being validated for malicious characters.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Construct HTTP headers very carefully, avoiding the use of nonvalidated input data.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (114,'Process Control','Description:

Executing commands or loading libraries from an untrusted source or in an untrusted environment can cause an application to execute malicious commands (and payloads) on behalf of an attacker.

Process control vulnerabilities take two forms: 1. An attacker can change the command that the program executes: the attacker explicitly controls what the command is. 2. An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means. Process control vulnerabilities of the first type occur when either data enters the application from an untrusted source and the data is used as part of a string representing a command that is executed by the application. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Libraries that are loaded should be well understood and come from a trusted source. The application can execute code contained in the native libraries, which often contain calls that are susceptible to other security problems, such as buffer overflows or command injection. All native libraries should be validated to determine if the application requires the use of the library. It is very difficult to determine what these native libraries actually do, and the potential for malicious code is high. In addition, the potential for an inadvertent mistake in these native libraries is also high, as many are written in C or C++ and may be susceptible to buffer overflow or race condition problems. To help prevent buffer overflow attacks, validate all input to native calls for content and length. If the native library does not come from a trusted source, review the source code of the library. The library should be built from the reviewed source before using it.

',1);
INSERT INTO "kb_items" VALUES (115,'Misinterpretation of Input','Description:

The software misinterprets an input, whether from an attacker or another product, in a securityrelevant fashion.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (116,'Improper Encoding or Escaping of Output','Description:

The software prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.

Improper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead. Most software follows a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, GET /index.html HTTP/1.1 is a structured message containing a command (GET) with a single argument (/index.html) and metadata about which protocol version is being used (HTTP/1.1). If an application uses attackersupplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error. Alternately, use builtin functions, but consider using wrappers in case those functions are discovered to have a vulnerability.

PHASE:Architecture and Design:STRATEGY:Parameterization:
If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.

PHASE:Architecture and Design Implementation:
Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multipart mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.

PHASE:Architecture and Design:
In some cases, input validation may be an important strategy when output encoding is not a complete solution. For example, you may be providing the same output that will be processed by multiple consumers that use different encodings or representations. In other cases, you may be required to allow usersupplied input to contain control information, such as limited HTML tags that support formatting in a wiki or bulletin board. When this type of requirement must be met, use an extremely strict whitelist to limit which control sequences can be used. Verify that the resulting syntactic structure is what you expect. Use your normal encoding methods for the remainder of the input.

PHASE:Architecture and Design:
Use input validation as a defenseindepth measure to reduce the likelihood of output encoding errors (see CWE20).

PHASE:Requirements:
Fully specify which encodings are required by components that will be communicating with each other.

PHASE:Implementation:
When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.

',1);
INSERT INTO "kb_items" VALUES (117,'Improper Output Neutralization for Logs','Description:

The software does not neutralize or incorrectly neutralizes output that is written to logs.

This can allow an attacker to forge log entries or inject malicious content into logs. Log forging vulnerabilities occur when: Data enters an application from an untrusted source. The data is written to an application or system log file.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (118,'Incorrect Access of Indexable Resource Range Error','Description:

The software does not restrict or incorrectly restricts operations within the boundaries of a resource that is accessed using an index or pointer, such as memory or files.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (119,'Improper Restriction of Operations within the Bounds of a Memory Buffer','Description:

The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.

Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data. As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language''''s interface to native code may still be subject to overflows, even if the language itself is theoretically safe.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF57], and the Strsafe.h library from Microsoft [REF56]. These libraries provide safer versions of overflowprone stringhandling functions.

PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:
Consider adhering to the following rules when allocating and managing an application''''s memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULLterminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.

PHASE:Operation:STRATEGY:Environment Hardening:
Run or compile the software using features or extensions that randomly arrange the positions of a program''''s executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF58] [REF60] and PositionIndependent Executables (PIE) [REF64].:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF60] [REF61].:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:
Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate

',1);
INSERT INTO "kb_items" VALUES (120,'Buffer Copy without Checking Size of Input Classic Buffer Overflow','Description:

The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.

A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the classic case in which the program copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language''''s interface to native code may still be subject to overflows, even if the language itself is theoretically safe.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF57], and the Strsafe.h library from Microsoft [REF56]. These libraries provide safer versions of overflowprone stringhandling functions.

PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:
Consider adhering to the following rules when allocating and managing an application''''s memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULLterminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Operation:STRATEGY:Environment Hardening:
Run or compile the software using features or extensions that randomly arrange the positions of a program''''s executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF58] [REF60] and PositionIndependent Executables (PIE) [REF64].:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF60] [REF61].:EFFECTIVENESS:Defense in Depth

PHASE:Build and Compilation Operation:
Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.

PHASE:Implementation:
Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (121,'Stack based Buffer Overflow','Description:

A stackbased buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).



Mitigation:


PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth

PHASE:Architecture and Design:
Use an abstraction library to abstract away risky APIs. Not a complete solution.

PHASE:Build and Compilation:
Compilerbased canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.

PHASE:Implementation:
Implement and perform bounds checking on input.

PHASE:Implementation:
Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.

PHASE:Operation:
Use OSlevel preventative functionality, such as ASLR. This is not a complete solution.

',1);
INSERT INTO "kb_items" VALUES (122,'Heap based Buffer Overflow','Description:

A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().



Mitigation:


PHASE

DESCRIPTION:Predesign: Use a language or compiler that performs automatic bounds checking.

PHASE:Architecture and Design:
Use an abstraction library to abstract away risky APIs. Not a complete solution.

PHASE:Build and Compilation:
Predesign through Build: Canary style bounds checking, library changes which ensure the validity of chunk data, and other such fixes are possible, but should not be relied upon.

PHASE:Implementation:
Implement and perform bounds checking on input.

PHASE:Implementation:STRATEGY:Libraries or Frameworks:
Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.

PHASE:Operation:
Use OSlevel preventative functionality. This is not a complete solution, but it provides some defense in depth.

',1);
INSERT INTO "kb_items" VALUES (123,'Write what where Condition','Description:

Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Language Selection:
Use a language that provides appropriate memory abstractions.

PHASE:Operation:
Use OSlevel preventative functionality integrated after the fact. Not a complete solution.

',1);
INSERT INTO "kb_items" VALUES (124,'Buffer Underwrite Buffer Underflow','Description:

The software writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.

This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.

Mitigation:


PHASE

DESCRIPTION:Requirements specification: The choice could be made to use a language that is not susceptible to these issues.

PHASE:Implementation:
Sanity checks should be performed on all calculated values used as index or for pointer arithmetic.

',1);
INSERT INTO "kb_items" VALUES (125,'Out of bounds Read','Description:

The software reads data past the end, or before the beginning, of the intended buffer.

Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string. The expected sentinel might not be located in the outofbounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow. The software may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent read operation then produces undefined or unexpected results.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. To reduce the likelihood of introducing an outofbounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be espcially careful of relying on a sentinel (i.e. special character such as NUL) in an untrusted inputs.

PHASE:Architecture and Design:STRATEGY:Language Selection:
Use a language that provides appropriate memory abstractions.

',1);
INSERT INTO "kb_items" VALUES (126,'Buffer Over read','Description:

The software reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.

This typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (127,'Buffer Under read','Description:

The software reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.

This typically occurs when the pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. This may result in exposure of sensitive information or possibly a crash.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (128,'Wrap around Error','Description:

Wrap around errors occur whenever a value is incremented past the maximum value for its type and therefore wraps around to a very small, negative, or undefined value.



Mitigation:


PHASE

DESCRIPTION:Requirements specification: The choice could be made to use a language that is not susceptible to these issues.

PHASE:Architecture and Design:
Provide clear upper and lower bounds on the scale of any protocols designed.

PHASE:Implementation:
Place sanity checks on all incremented variables to ensure that they remain within reasonable bounds.

',1);
INSERT INTO "kb_items" VALUES (129,'Improper Validation of Array Index','Description:

The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Use an input validation framework such as Struts or the OWASP ESAPI Validation API. If you use Struts, be mindful of weaknesses covered by the CWE101 category.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server. Even though clientside checks provide minimal benefits with respect to serverside security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, clientside errorchecking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in serverside processing time for accidental input errors, although this is typically a small savings.

PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an outofbounds index is accessed.

PHASE:Operation:STRATEGY:Environment Hardening:
Run or compile the software using features or extensions that randomly arrange the positions of a program''''s executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF58] [REF60] and PositionIndependent Executables (PIE) [REF64].:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF60] [REF61].:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When accessing a usercontrolled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.

PHASE:Implementation:
Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (130,'Improper Handling of Length Parameter Inconsistency','Description:

The software parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.

If an attacker can manipulate the length parameter associated with an input such that it is inconsistent with the actual length of the input, this can be leveraged to cause the target application to behave in unexpected, and possibly, malicious ways. One of the possible motives for doing so is to pass in arbitrarily large input to the application. Another possible motivation is the modification of application state by including invalid data for subsequent properties of the application. Such weaknesses commonly lead to attacks such as buffer overflows and execution of arbitrary code.

Mitigation:


PHASE:Implementation:
When processing structured incoming data containing a size field followed by raw data, ensure that you identify and resolve any inconsistencies between the size field and the actual size of the data.

PHASE:Implementation:
Do not let the user control the size of the buffer.

PHASE:Implementation:
Validate that the length of the usersupplied data is consistent with the buffer size.

',1);
INSERT INTO "kb_items" VALUES (131,'Incorrect Calculation of Buffer Size','Description:

The software does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.



Mitigation:


PHASE:Implementation:
When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts & characters to &amp; for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer.

PHASE:Implementation:
Understand the programming language''''s underlying representation and how it interacts with numeric calculation (CWE681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, notanumber calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF7] Also be careful to account for 32bit, 64bit, and other potential differences that may affect the numeric representation.

PHASE:Implementation:STRATEGY:Input Validation:
Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Implementation:
When processing structured incoming data containing a size field followed by raw data, identify and resolve any inconsistencies between the size field and the actual size of the data (CWE130).

PHASE:Implementation:
When allocating memory that uses sentinels to mark the end of a data structure  such as NUL bytes in strings  make sure you also include the sentinel in your calculation of the total amount of memory that must be allocated.

PHASE:Implementation:
Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate

PHASE:Implementation:
Use sizeof() on the appropriate data type to avoid CWE467.

PHASE:Implementation:
Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity. This will simplify sanity checks and will reduce surprises related to unexpected casting.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences, or buffer allocation routines that automatically track buffer size. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF106]

PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Run or compile the software using features or extensions that randomly arrange the positions of a program''''s executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF58] [REF60] and PositionIndependent Executables (PIE) [REF64].:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF61] [REF60].:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:STRATEGY:Compilation or Build Hardening:
Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (134,'Use of Externally Controlled Format String','Description:

The software uses a function that accepts a format string as an argument, but the format string originates from an external source.

When an attacker can modify an externallycontrolled format string, this can lead to buffer overflows, denial of service, or data representation problems. It should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.

Mitigation:


PHASE:Requirements:
Choose a language that is not subject to this flaw.

PHASE:Implementation:
Ensure that all format string functions are passed a static string which cannot be controlled by the user and that the proper number of arguments are always sent to that function as well. If at all possible, use functions that do not support the %n operator in format strings. [REF116] [REF117]

PHASE:Build and Compilation:
Heed the warnings of compilers and linkers, since they may alert you to improper usage.

',1);
INSERT INTO "kb_items" VALUES (135,'Incorrect Calculation of Multi Byte String Length','Description:

The software does not correctly calculate the length of strings that can contain wide or multibyte characters.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Always verify the length of the string unit character.

PHASE:Implementation:STRATEGY:Libraries or Frameworks:
Use length computing functions (e.g. strlen, wcslen, etc.) appropriately with their equivalent type (e.g.: byte, wchar_t, etc.)

',1);
INSERT INTO "kb_items" VALUES (138,'Improper Neutralization of Special Elements','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.

Most languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If software does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (less than) as meaning read input from a file.

Mitigation:


PHASE:Implementation:
Developers should anticipate that special elements (e.g. delimiters, symbols) will be injected into input vectors of their software system. One defense is to create a whitelist (e.g. a regular expression) that defines valid input according to the requirements specifications. Strictly filter any input that does not match against the whitelist. Properly encode your output, and quote any elements that have special meaning to the component with which you are communicating.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:
Use and specify an appropriate output encoding to ensure that the special elements are welldefined. A normal byte sequence in one encoding could be a special element in another.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

',1);
INSERT INTO "kb_items" VALUES (140,'Improper Neutralization of Delimiters','Description:

The software does not neutralize or incorrectly neutralizes delimiters.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Developers should anticipate that delimiters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (141,'Improper Neutralization of Parameter Argument Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as parameter or argument delimiters when they are sent to a downstream component.

As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that parameter/argument delimiters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (142,'Improper Neutralization of Value Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as value delimiters when they are sent to a downstream component.

As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that value delimiters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (143,'Improper Neutralization of Record Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as record delimiters when they are sent to a downstream component.

As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that record delimiters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (144,'Improper Neutralization of Line Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as line delimiters when they are sent to a downstream component.

As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that line delimiters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (145,'Improper Neutralization of Section Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as section delimiters when they are sent to a downstream component.

As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions. One example of a section delimiter is the boundary string in a multipart MIME message. In many cases, doubled line delimiters can serve as a section delimiter.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that section delimiters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (146,'Improper Neutralization of Expression Command Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as expression or command delimiters when they are sent to a downstream component.

As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that interexpression and intercommand delimiters will be injected/removed/manipulated in the input vectors of their software system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (147,'Improper Neutralization of Input Terminators','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as input terminators when they are sent to a downstream component.

For example, a . in SMTP signifies the end of mail message data, whereas a null character can be used for the end of a string.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that terminators will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (148,'Improper Neutralization of Input Leaders','Description:

The application does not properly handle when a leading character or sequence (leader) is missing or malformed, or if multiple leaders are used when only one should be allowed.



Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that leading characters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (149,'Improper Neutralization of Quoting Syntax','Description:

Quotes injected into an application can be used to compromise a system. As data are parsed, an injected/absent/duplicate/malformed use of quotes may cause the process to take unexpected actions.



Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that quotes will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (151,'Improper Neutralization of Comment Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as comment delimiters when they are sent to a downstream component.



Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that comments will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (152,'Improper Neutralization of Macro Symbols','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as macro symbols when they are sent to a downstream component.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Developers should anticipate that macro symbols will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (153,'Improper Neutralization of Substitution Characters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as substitution characters when they are sent to a downstream component.



Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that substitution characters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (154,'Improper Neutralization of Variable Name Delimiters','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as variable name delimiters when they are sent to a downstream component.

As data is parsed, an injected delimiter may cause the process to take unexpected actions that result in an attack. Example: $ for an environment variable.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that variable name delimiters will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (155,'Improper Neutralization of Wildcards or Matching Symbols','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as wildcards or matching symbols when they are sent to a downstream component.

As data is parsed, an injected element may cause the process to take unexpected actions.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that wildcard or matching elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (156,'Improper Neutralization of Whitespace','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as whitespace when they are sent to a downstream component.

This can include space, tab, etc.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that whitespace will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (157,'Failure to Sanitize Paired Delimiters','Description:

The software does not properly handle the characters that are used to mark the beginning and ending of a group of entities, such as parentheses, brackets, and braces.

Paired delimiters might include: < and > angle brackets ( and ) parentheses { and } braces [ and ] square brackets double quotes '''' '''' single quotes

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that grouping elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (158,'Improper Neutralization of Null Byte or NUL Character','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes NUL characters or null bytes when they are sent to a downstream component.

As data is parsed, an injected NUL character or null byte may cause the software to believe the input is terminated earlier than it actually is, or otherwise cause the input to be misinterpreted. This could then be used to inject potentially dangerous input that occurs after the null byte or otherwise bypass validation routines and other protection mechanisms.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that null characters or null bytes will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (159,'Improper Handling of Invalid Use of Special Elements','Description:

The product does not properly filter, remove, quote, or otherwise manage the invalid use of special elements in usercontrolled input, which could cause adverse effect on its behavior and integrity.



Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (160,'Improper Neutralization of Leading Special Elements','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes leading special elements that could be interpreted in unexpected ways when they are sent to a downstream component.

As data is parsed, improperly handled leading special elements may cause the process to take unexpected actions that result in an attack.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that leading special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (161,'Improper Neutralization of Multiple Leading Special Elements','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes multiple leading special elements that could be interpreted in unexpected ways when they are sent to a downstream component.

As data is parsed, improperly handled multiple leading special elements may cause the process to take unexpected actions that result in an attack.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that multiple leading special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (162,'Improper Neutralization of Trailing Special Elements','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes trailing special elements that could be interpreted in unexpected ways when they are sent to a downstream component.

As data is parsed, improperly handled trailing special elements may cause the process to take unexpected actions that result in an attack.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that trailing special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (163,'Improper Neutralization of Multiple Trailing Special Elements','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes multiple trailing special elements that could be interpreted in unexpected ways when they are sent to a downstream component.

As data is parsed, improperly handled multiple trailing special elements may cause the process to take unexpected actions that result in an attack.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that multiple trailing special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (164,'Improper Neutralization of Internal Special Elements','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes internal special elements that could be interpreted in unexpected ways when they are sent to a downstream component.

As data is parsed, improperly handled internal special elements may cause the process to take unexpected actions that result in an attack.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that internal special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (165,'Improper Neutralization of Multiple Internal Special Elements','Description:

The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes multiple internal special elements that could be interpreted in unexpected ways when they are sent to a downstream component.

As data is parsed, improperly handled multiple internal special elements may cause the process to take unexpected actions that result in an attack.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that multiple internal special elements will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (166,'Improper Handling of Missing Special Element','Description:

The software receives input from an upstream component, but it does not handle or incorrectly handles when an expected special element is missing.



Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that special elements will be removed in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (167,'Improper Handling of Additional Special Element','Description:

The software receives input from an upstream component, but it does not handle or incorrectly handles when an additional unexpected special element is provided.



Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that extra special elements will be injected in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (168,'Improper Handling of Inconsistent Special Elements','Description:

The software does not properly handle input in which an inconsistency exists between two or more special characters or reserved words.

An example of this problem would be if paired characters appear in the wrong order, or if the special characters are not properly nested.

Mitigation:


PHASE

DESCRIPTION:Developers should anticipate that inconsistent special elements will be injected/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and whitelists to ensure only valid, expected and appropriate input is processed by the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (170,'Improper Null Termination','Description:

The software does not terminate or incorrectly terminates a string or array with a null character or equivalent terminator.

Null termination errors frequently occur in two different ways. An offbyone error could cause a null to be written out of bounds, leading to an overflow. Or, a program could use a strncpy() function call incorrectly, which prevents a null terminator from being added at all. Other scenarios are possible.

Mitigation:


PHASE:Requirements:
Use a language that is not susceptible to these issues. However, be careful of null byte interaction errors (CWE626) with lowerlevel constructs that may be written in a language that is susceptible.

PHASE:Implementation:
Ensure that all string functions used are understood fully as to how they append null characters. Also, be wary of offbyone errors when appending nulls to the end of strings.

PHASE:Implementation:
If performance constraints permit, special code can be added that validates nulltermination of string buffers, this is a rather naive and errorprone solution.

PHASE:Implementation:
Switch to bounded string manipulation functions. Inspect buffer lengths involved in the buffer overrun trace reported with the defect.

PHASE:Implementation:
Add code that fills buffers with nulls (however, the length of buffers still needs to be inspected, to ensure that the non nullterminated string is not written at the physical end of the buffer).

',1);
INSERT INTO "kb_items" VALUES (172,'Encoding Error','Description:

The software does not properly encode or decode the data, resulting in unexpected values.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
While it is risky to use dynamicallygenerated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE88).

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (173,'Improper Handling of Alternate Encoding','Description:

The software does not properly handle when an input uses an alternate encoding that is valid for the control sphere to which the input is being sent.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (174,'Double Decoding of the Same Data','Description:

The software decodes the same input twice, which can limit the effectiveness of any protection mechanism that occurs in between the decoding operations.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (175,'Improper Handling of Mixed Encoding','Description:

The software does not properly handle when the same input uses several different (mixed) encodings.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Output Encoding:
Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO88591, UTF7, and UTF8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (176,'Improper Handling of Unicode Encoding','Description:

The software does not properly handle when an input contains Unicode encoding.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (177,'Improper Handling of URL Encoding Hex Encoding','Description:

The software does not properly handle when all or part of an input has been URL encoded.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (178,'Improper Handling of Case Sensitivity','Description:

The software does not properly account for differences in case sensitivity when accessing or determining the properties of a resource, leading to inconsistent results.

Improperly handled case sensitive data can lead to several possible consequences, including: caseinsensitive passwords reducing the size of the key space, making brute force attacks easier bypassing filters or access controls using alternate names multiple interpretation errors using alternate names.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (179,'Incorrect Behavior Order: Early Validation','Description:

The software validates input before applying protection mechanisms that modify the input, which could allow an attacker to bypass the validation via dangerous inputs that only arise after the modification.

Software needs to validate data at the proper time, after data has been canonicalized and cleansed. Early validation is susceptible to various manipulations that result in dangerous inputs that are produced by canonicalization and cleansing.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (180,'Incorrect Behavior Order: Validate Before Canonicalize','Description:

The software validates input before it is canonicalized, which prevents the software from detecting data that becomes invalid after the canonicalization step.

This can be used by an attacker to bypass the validation and launch attacks that expose weaknesses that would otherwise be prevented, such as injection.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (181,'Incorrect Behavior Order: Validate Before Filter','Description:

The software validates data before it has been filtered, which prevents the software from detecting data that becomes invalid after the filtering step.

This can be used by an attacker to bypass the validation and launch attacks that expose weaknesses that would otherwise be prevented, such as injection.

Mitigation:


PHASE:Implementation Architecture and Design:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being filtered.

',1);
INSERT INTO "kb_items" VALUES (182,'Collapse of Data into Unsafe Value','Description:

The software filters data in a way that causes it to be reduced or collapsed into an unsafe value that violates an expected security property.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

PHASE

DESCRIPTION:Canonicalize the name to match that of the file system''''s representation of the name. This can sometimes be achieved with an available API (e.g. in Win32 the GetFullPathName function).

',1);
INSERT INTO "kb_items" VALUES (183,'Permissive List of Allowed Inputs','Description:

The product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are explicitly allowed by policy because the inputs are assumed to be safe, but the list is too permissive  that is, it allows an input that is unsafe, leading to resultant weaknesses.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (184,'Incomplete List of Disallowed Inputs','Description:

The product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete, leading to resultant weaknesses.

Developers often try to protect their products against malicious input by performing tests against inputs that are known to be bad, such as special characters that can invoke new commands. However, such lists often only account for the most wellknown bad inputs. Attackers may be able to find other malicious inputs that were not expected by the developer, allowing them to bypass the intended protection mechanism.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Do not rely exclusively on detecting disallowed inputs. There are too many variants to encode a character, especially when different environments are used, so there is a high likelihood of missing some variants. Only use detection of disallowed inputs as a mechanism for detecting suspicious activity. Ensure that you are using other protection mechanisms that only identify good input  such as lists of allowed inputs  and ensure that you are properly encoding your outputs.

',1);
INSERT INTO "kb_items" VALUES (185,'Incorrect Regular Expression','Description:

The software specifies a regular expression in a way that causes data to be improperly matched or compared.

When the regular expression is used in protection mechanisms such as filtering or validation, this may allow an attacker to bypass the intended restrictions on the incoming data.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Refactoring:
Regular expressions can become error prone when defining a complex language even for those experienced in writing grammars. Determine if several smaller regular expressions simplify one large regular expression. Also, subject the regular expression to thorough testing techniques such as equivalence partitioning, boundary value analysis, and robustness. After testing and a reasonable confidence level is achieved, a regular expression may not be foolproof. If an exploit is allowed to slip through, then record the exploit and refactor the regular expression.

',1);
INSERT INTO "kb_items" VALUES (186,'Overly Restrictive Regular Expression','Description:

A regular expression is overly restrictive, which prevents dangerous values from being detected.

This weakness is not about regular expression complexity. Rather, it is about a regular expression that does not match all values that are intended. Consider the use of a regexp to identify acceptable values or to spot unwanted terms. An overly restrictive regexp misses some potentially securityrelevant values leading to either false positives *or* false negatives, depending on how the regexp is being used within the code. Consider the expression /[08]/ where the intention was /[09]/. This expression is not complex but the value 9 is not matched when maybe the programmer planned to check for it.

Mitigation:


PHASE:Implementation:
Regular expressions can become error prone when defining a complex language even for those experienced in writing grammars. Determine if several smaller regular expressions simplify one large regular expression. Also, subject your regular expression to thorough testing techniques such as equivalence partitioning, boundary value analysis, and robustness. After testing and a reasonable confidence level is achieved, a regular expression may not be foolproof. If an exploit is allowed to slip through, then record the exploit and refactor your regular expression.

',1);
INSERT INTO "kb_items" VALUES (187,'Partial String Comparison','Description:

The software performs a comparison that only examines a portion of a factor before determining whether there is a match, such as a substring, leading to resultant weaknesses.

For example, an attacker might succeed in authentication by providing a small password that matches the associated portion of the larger, correct password.

Mitigation:


PHASE:Testing:
Thoroughly test the comparison scheme before deploying code into production. Perform positive testing as well as negative testing.

',1);
INSERT INTO "kb_items" VALUES (188,'Reliance on Data Memory Layout','Description:

The software makes invalid assumptions about how protocol data or memory is organized at a lower level, resulting in unintended program behavior.

When changing platforms or protocol versions, inmemory organization of data may change in unintended ways. For example, some architectures may place local variables A and B right next to each other with A on top; some may place them next to each other with B on top; and others may add some padding to each. The padding size may vary to ensure that each variable is aligned to a proper word size. In protocol implementations, it is common to calculate an offset relative to another field to pick out a specific piece of data. Exceptional conditions, often involving new protocol versions, may add corner cases that change the data layout in an unusual way. The result can be that an implementation accesses an unintended field in the packet, treating data of one type as data of another type.

Mitigation:


PHASE:Implementation Architecture and Design:
In flat address space situations, never allow computing memory addresses as offsets from another memory address.

PHASE:Architecture and Design:
Fully specify protocol layout unambiguously, providing a structured grammar (e.g., a compilable yacc grammar).

PHASE:Testing:
Testing: Test that the implementation properly handles each case in the protocol grammar.

',1);
INSERT INTO "kb_items" VALUES (190,'Integer Overflow or Wraparound','Description:

The software performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.

An integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using usersupplied inputs. This becomes securitycritical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc.

Mitigation:


PHASE:Requirements:
Ensure that all protocols are strictly defined, such that all outofbounds behavior can be identified simply, and require strict conformance to the protocol.

PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. If possible, choose a language or compiler that performs automatic bounds checking.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF106]

PHASE:Implementation:STRATEGY:Input Validation:
Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range. Use unsigned integers where possible. This makes it easier to perform sanity checks for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.

PHASE:Implementation:
Understand the programming language''''s underlying representation and how it interacts with numeric calculation (CWE681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, notanumber calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF7] Also be careful to account for 32bit, 64bit, and other potential differences that may affect the numeric representation.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Implementation:STRATEGY:Compilation or Build Hardening:
Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.

',1);
INSERT INTO "kb_items" VALUES (191,'Integer Underflow Wrap or Wraparound','Description:

The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.

This can happen in signed and unsigned cases.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (192,'Integer Coercion Error','Description:

Integer coercion refers to a set of flaws pertaining to the type casting, extension, or truncation of primitive data types.

Several flaws fall under the category of integer coercion errors. For the most part, these errors in and of themselves result only in availability and data integrity issues. However, in some circumstances, they may result in other, more complicated security related flaws, such as buffer overflow conditions.

Mitigation:


PHASE:Requirements:
A language which throws exceptions on ambiguous data casts might be chosen.

PHASE:Architecture and Design:
Design objects and program flow such that multiple or complex casts are unnecessary

PHASE:Implementation:
Ensure that any data type casting that you must used is entirely understood in order to reduce the plausibility of error in use.

',1);
INSERT INTO "kb_items" VALUES (193,'Off by one Error','Description:

A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.



Mitigation:


PHASE:Implementation:
When copying character arrays or using character manipulation methods, the correct size parameter must be used to account for the null terminator that needs to be added at the end of the array. Some examples of functions susceptible to this weakness in C include strcpy(), strncpy(), strcat(), strncat(), printf(), sprintf(), scanf() and sscanf().

',1);
INSERT INTO "kb_items" VALUES (194,'Unexpected Sign Extension','Description:

The software performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type. When the original number is negative, this can produce unexpected values that lead to resultant weaknesses.



Mitigation:


PHASE:Implementation:
Avoid using signed variables if you don''''t need to represent negative values. When negative values are needed, perform sanity checks after you save those values to larger data types, or before passing them to functions that are expecting unsigned values.

',1);
INSERT INTO "kb_items" VALUES (195,'Signed to Unsigned Conversion Error','Description:

The software uses a signed primitive and performs a cast to an unsigned primitive, which can produce an unexpected value if the value of the signed primitive can not be represented using an unsigned primitive.

It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program. Often, functions will return negative values to indicate a failure. When the result of a function is to be used as a size parameter, using these negative return values can have unexpected results. For example, if negative size values are passed to the standard memory copy or allocation functions they will be implicitly cast to a large unsigned value. This may lead to an exploitable buffer overflow or underflow condition.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (196,'Unsigned to Signed Conversion Error','Description:

The software uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value if the value of the unsigned primitive can not be represented using a signed primitive.

Although less frequent an issue than signedtounsigned conversion, unsignedtosigned conversion can be the perfect precursor to dangerous buffer underwrite conditions that allow attackers to move down the stack where they otherwise might not have access in a normal buffer overflow condition. Buffer underwrites occur frequently when large unsigned values are cast to signed values, and then used as indexes into a buffer or for pointer arithmetic.

Mitigation:


PHASE:Requirements:
Choose a language which is not subject to these casting flaws.

PHASE:Architecture and Design:
Design object accessor functions to implicitly check values for valid sizes. Ensure that all functions which will be used as a size are checked previous to use as a size. If the language permits, throw exceptions rather than using inband errors.

PHASE:Implementation:
Error check the return values of all functions. Be aware of implicit casts made, and use unsigned variables for sizes if at all possible.

',1);
INSERT INTO "kb_items" VALUES (197,'Numeric Truncation Error','Description:

Truncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.

When a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.

Mitigation:


PHASE:Implementation:
Ensure that no casts, implicit or explicit, take place that move from a larger size primitive or a smaller size primitive.

',1);
INSERT INTO "kb_items" VALUES (198,'Use of Incorrect Byte Ordering','Description:

The software receives input from an upstream component, but it does not account for byte ordering (e.g. bigendian and littleendian) when processing the input, causing an incorrect number or value to be used.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (200,'Exposure of Sensitive Information to an Unauthorized Actor','Description:

The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.

There are many different kinds of mistakes that introduce information exposures. The severity of the error can range widely, depending on the context in which the product operates, the type of sensitive information that is revealed, and the benefits it may provide to an attacker. Some kinds of sensitive information include: private, personal information, such as personal messages, ficial data, health records, geographic location, or contact details system status and environment, such as the operating system and installed packages business secrets and intellectual property network status and configuration the product''''s own code or internal state metadata, e.g. logging of connections or message headers indirect information, such as a discrepancy between two internal operations that can be observed by an outsider Information might be sensitive to different parties, each of which may have their own expectations for whether the information should be protected. These parties include: the product''''s own users people or organizations whose information is created or used by the product, even if they are not direct product users the product''''s administrators, including the admins of the system(s) and/or networks on which the product operates the developer Information exposures can occur in different ways: the code explicitly inserts sensitive information into resources that are made accessible to unauthorized actors a different weakness or mistake inadvertently makes the sensitive information available, such as a web script error revealing the full system path of the program

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (201,'Exposure of Sensitive Information Through Sent Data','Description:

The code transmits data to another actor, but the data contains sensitive information that should not be accessible to the actor that is receiving the data.

Sensitive information could include data that is sensitive in and of itself (such as credentials or private messages), or otherwise useful in the further exploitation of the system (such as internal file system structure).

Mitigation:


PHASE:Requirements:
Specify which data in the software should be regarded as sensitive. Consider which types of users should have access to which types of data.

PHASE:Implementation:
Ensure that any possibly sensitive data specified in the requirements is verified with designers to ensure that it is either a calculated risk or mitigated elsewhere. Any information that is not necessary to the functionality should be removed in order to lower both the overhead and the possibility of security sensitive data being sent.

PHASE:System Configuration:
Setup default error messages so that unexpected errors do not disclose sensitive information.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (202,'Exposure of Sensitive Information Through Data Queries','Description:

When trying to keep information confidential, an attacker can often infer some of the information by using statistics.

In situations where data should not be tied to individual users, but a large number of users should be able to make queries that scrub the identity of users, it may be possible to get information about a user  e.g., by specifying search terms that are known to be unique to that user.

Mitigation:


PHASE:Architecture and Design:
This is a complex topic. See the book Translucent Databases for a good discussion of best practices.

',1);
INSERT INTO "kb_items" VALUES (203,'Observable Discrepancy','Description:

The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes securityrelevant information about the state of the product, such as whether a particular operation was successful or not.

Discrepancies can take many forms and include things like responses, timing, control flow, or general behavior. These discrepancies can reveal information about the product''''s operation or internal state to an unauthorized actor. In some cases, discrepancies can be used by attackers to form a side channel.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Implementation:
Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages  but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not.

',1);
INSERT INTO "kb_items" VALUES (204,'Observable Response Discrepancy','Description:

The product provides different responses to incoming requests in a way that reveals internal state information to an unauthorized actor outside of the intended control sphere.

This issue frequently occurs during authentication, where a difference in failedlogin messages could allow an attacker to determine if the username is valid or not. These exposures can be inadvertent (bug) or intentional (design).

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Implementation:
Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages  but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not.

',1);
INSERT INTO "kb_items" VALUES (205,'Observable Behavioral Discrepancy','Description:

The product''''s behaviors indicate important differences that may be observed by unauthorized actors in a way that reveals (1) its internal state or decision process, or (2) differences from other products with equivalent functionality.

Ideally, a product should provide as little information about its internal operations as possible. Otherwise, attackers could use knowledge of these internal operations to simplify or optimize their attack. In some cases, behavioral discrepancies can be used by attackers to form a side channel.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (206,'Observable Internal Behavioral Discrepancy','Description:

The product performs multiple behaviors that are combined to produce a single result, but the individual behaviors are observable separately in a way that allows attackers to reveal internal state or internal decision points.

Ideally, a product should provide as little information as possible to an attacker. Any hints that the attacker may be making progress can then be used to simplify or optimize the attack. For example, in a login procedure that requires a username and password, ultimately there is only one decision: success or failure. However, internally, two separate actions are performed: determining if the username exists, and checking if the password is correct. If the product behaves differently based on whether the username exists or not, then the attacker only needs to concentrate on the password.

Mitigation:


PHASE

DESCRIPTION:Setup generic response pages for error conditions. The error page should not disclose information about the success or failure of a sensitive operation. For instance, the login page should not confirm that the login is correct and the password incorrect. The attacker who tries random account name may be able to guess some of them. Confirming that the account exists would make the login page more susceptible to brute force attack.

',1);
INSERT INTO "kb_items" VALUES (207,'Observable Behavioral Discrepancy With Equivalent Products','Description:

The product operates in an environment in which its existence or specific identity should not be known, but it behaves differently than other products with equivalent functionality, in a way that is observable to an attacker.

For many kinds of products, multiple products may be available that perform the same functionality, such as a web server, network interface, or intrusion detection system. Attackers often perform fingerprinting, which uses discrepancies in order to identify which specific product is in use. Once the specific product has been identified, the attacks can be made more customized and efficient. Often, an organization might intentionally allow the specific product to be identifiable. However, in some environments, the ability to identify a distinct product is unacceptable, and it is expected that every product would behave in exactly the same way. In these more restricted environments, a behavioral difference might pose an unacceptable risk if it makes it easier to identify the product''''s vendor, model, configuration, version, etc.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (208,'Observable Timing Discrepancy','Description:

Two separate operations in a product require different amounts of time to complete, in a way that is observable to an actor and reveals securityrelevant information about the state of the product, such as whether a particular operation was successful or not.

In securityrelevant contexts, even small variations in timing can be exploited by attackers to indirectly infer certain details about the product''''s internal operations. For example, in some cryptographic algorithms, attackers can use timing differences to infer certain properties about a private key, making the key easier to guess. Timing discrepancies effectively form a timing side channel.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (209,'Generation of Error Message Containing Sensitive Information','Description:

The software generates an error message that includes sensitive information about its environment, users, or associated data.

The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more serious attacks. The error message may be created in different ways: selfgenerated: the source code explicitly constructs the error message and delivers it externallygenerated: the external environment, such as a language interpreter, handles the error and constructs its own message, whose contents are not under direct control by the programmer An attacker may use the contents of error messages to help launch another, more focused attack. For example, an attempt to exploit a path traversal weakness (CWE22) might yield the full pathname of the installed application. In turn, this could be used to select the proper number of .. sequences to navigate to the targeted file. An attack using SQL injection (CWE89) might not initially succeed, but an error message could reveal the malformed query, which would expose query logic and possibly even passwords or other sensitive information used within the query.

Mitigation:


PHASE:Implementation:
Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages  but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not.

PHASE:Implementation:
Handle exceptions internally and do not display errors containing potentially sensitive information to a user.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and nonsensitive data as much as possible.:EFFECTIVENESS:Defense in Depth

PHASE:Implementation Build and Compilation:STRATEGY:Compilation or Build Hardening:
Debugging information should not make its way into a production release.

PHASE:Implementation Build and Compilation:STRATEGY:Environment Hardening:
Debugging information should not make its way into a production release.

PHASE:System Configuration:
Where available, configure the environment to use less verbose error messages. For example, in PHP, disable the display_errors setting during configuration, or at runtime using the error_reporting() function.

PHASE:System Configuration:
Create default error pages or messages that do not leak any information.

',1);
INSERT INTO "kb_items" VALUES (210,'Self generated Error Message Containing Sensitive Information','Description:

The software identifies an error condition and creates its own diagnostic or error messages that contain sensitive information.



Mitigation:


PHASE:Implementation Build and Compilation:STRATEGY:Compilation or Build Hardening:
Debugging information should not make its way into a production release.

PHASE:Implementation Build and Compilation:STRATEGY:Environment Hardening:
Debugging information should not make its way into a production release.

',1);
INSERT INTO "kb_items" VALUES (211,'Externally Generated Error Message Containing Sensitive Information','Description:

The application performs an operation that triggers an external diagnostic or error message that is not directly generated or controlled by the application, such as an error generated by the programming language interpreter that the software uses. The error can contain sensitive system information.



Mitigation:


PHASE:System Configuration:
Configure the application''''s environment in a way that prevents errors from being generated. For example, in PHP, disable display_errors.

PHASE:Implementation Build and Compilation:STRATEGY:Compilation or Build Hardening:
Debugging information should not make its way into a production release.

PHASE:Implementation Build and Compilation:STRATEGY:Environment Hardening:
Debugging information should not make its way into a production release.

PHASE:Implementation:
Handle exceptions internally and do not display errors containing potentially sensitive information to a user. Create default error pages if necessary.

PHASE:Implementation:
The best way to prevent this weakness during implementation is to avoid any bugs that could trigger the external error message. This typically happens when the program encounters fatal errors, such as a dividebyzero. You will not always be able to control the use of error pages, and you might not be using a language that handles exceptions.

',1);
INSERT INTO "kb_items" VALUES (212,'Improper Removal of Sensitive Information Before Storage or Transfer','Description:

The product stores, transfers, or shares a resource that contains sensitive information, but it does not properly remove that information before the product makes the resource available to unauthorized actors.

Resources that may contain sensitive data include documents, packets, messages, databases, etc. While this data may be useful to an individual user or small set of users who share the resource, it may need to be removed before the resource can be shared outside of the trusted group. The process of removal is sometimes called cleansing or scrubbing. For example, software that is used for editing documents might not remove sensitive data such as reviewer comments or the local pathname where the document is stored. Or, a proxy might not remove an internal IP address from headers before making an outgoing request to an Internet site.

Mitigation:


PHASE:Requirements:
Clearly specify which information should be regarded as private or sensitive, and require that the product offers functionality that allows the user to cleanse the sensitive information from the resource before it is published or exported to other parties.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and nonsensitive data as much as possible.:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:
Avoid errors related to improper resource shutdown or release (CWE404), which may leave the sensitive data within the resource if it is in an incomplete state.

',1);
INSERT INTO "kb_items" VALUES (213,'Exposure of Sensitive Information Due to Incompatible Policies','Description:

The product''''s intended functionality exposes information to certain actors in accordance with the developer''''s security policy, but this information is regarded as sensitive according to the intended security policies of other stakeholders such as the product''''s administrator, users, or others whose information is being processed.

When handling information, the developer must consider whether the information is regarded as sensitive by different stakeholders, such as users or administrators. Each stakeholder effectively has its own intended security policy that the product is expected to uphold. When a developer does not treat that information as sensitive, this can introduce a vulnerability that violates the expectations of the product''''s users.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (214,'Invocation of Process Using Visible Sensitive Information','Description:

A process is invoked with sensitive commandline arguments, environment variables, or other elements that can be seen by other processes on the operating system.

Many operating systems allow a user to list information about processes that are owned by other users. Other users could see information such as command line arguments or environment variable settings. When this data contains sensitive information such as credentials, it might allow other users to launch an attack against the software or related resources.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (215,'Insertion of Sensitive Information Into Debugging Code','Description:

The application inserts sensitive information into debugging code, which could expose this information if the debugging code is not disabled in production.

When debugging, it may be necessary to report detailed information to the programmer. However, if the debugging code is not disabled when the application is operating in a production environment, then this sensitive information may be exposed to attackers.

Mitigation:


PHASE:Implementation:
Do not leave debug statements that could be executed in the source code. Ensure that all debug information is eradicated before releasing the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (219,'Storage of File with Sensitive Data Under Web Root','Description:

The application stores sensitive data under the web document root with insufficient access control, which might make it accessible to untrusted parties.

Besides publicfacing web pages and code, applications may store sensitive data, code that is not directly invoked, or other files under the web document root of the web server. If the server is not configured or otherwise used to prevent direct access to those files, then attackers may obtain this sensitive data.

Mitigation:


PHASE:Implementation System Configuration:
Avoid storing information under the web root directory.

PHASE:System Configuration:
Access control permissions should be set to prevent reading/writing of sensitive files inside/outside of the web directory.

',1);
INSERT INTO "kb_items" VALUES (220,'Storage of File With Sensitive Data Under FTP Root','Description:

The application stores sensitive data under the FTP server root with insufficient access control, which might make it accessible to untrusted parties.



Mitigation:


PHASE:Implementation System Configuration:
Avoid storing information under the FTP root directory.

PHASE:System Configuration:
Access control permissions should be set to prevent reading/writing of sensitive files inside/outside of the FTP directory.

',1);
INSERT INTO "kb_items" VALUES (221,'Information Loss or Omission','Description:

The software does not record, or improperly records, securityrelevant information that leads to an incorrect decision or hampers later analysis.

This can be resultant, e.g. a buffer overflow might trigger a crash before the product can log the event.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (222,'Truncation of Security relevant Information','Description:

The application truncates the display, recording, or processing of securityrelevant information in a way that can obscure the source or nature of an attack.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (223,'Omission of Security relevant Information','Description:

The application does not record or display information that would be important for identifying the source or nature of an attack, or determining if an action is safe.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (224,'Obscured Security relevant Information by Alternate Name','Description:

The software records securityrelevant information according to an alternate name of the affected entity, instead of the canonical name.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (226,'Sensitive Information Uncleared in Resource Before Release for Reuse','Description:

The product prepares to release a resource such as memory or a file so that the resource can be reused by other entities, but the product does not fully clear previouslyused sensitive information from that resource before the resource is released.

When resources are released, they can be made available to other parties for reuse. For example, after memory is used and released, an operating system may make the memory available to another process, or disk space may be reallocated when a file is deleted. It is not necessarily guaranteed that the operating system will reinitialize the resource or otherwise remove the original contents. Even when the resource is reused by the same process, this weakness can arise when new data is not as large as the old data, which leaves portions of the old data still available. Equivalent errors can occur in other situations where the length of data is variable but the associated data structure is not. If memory is not cleared after use, it may allow unintended actors to read the data when the memory is reallocated.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (228,'Improper Handling of Syntactically Invalid Structure','Description:

The product does not handle or incorrectly handles input that is not syntactically wellformed with respect to the associated specification.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (229,'Improper Handling of Values','Description:

The software does not properly handle when the expected number of values for parameters, fields, or arguments is not provided in input, or if those values are undefined.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (230,'Improper Handling of Missing Values','Description:

The software does not handle or incorrectly handles when a parameter, field, or argument name is specified, but the associated value is missing, i.e. it is empty, blank, or null.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (231,'Improper Handling of Extra Values','Description:

The software does not handle or incorrectly handles when more values are provided than expected.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (232,'Improper Handling of Undefined Values','Description:

The software does not handle or incorrectly handles when a value is not defined or supported for the associated parameter, field, or argument name.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (233,'Improper Handling of Parameters','Description:

The software does not properly handle when the expected number of parameters, fields, or arguments is not provided in input, or if those parameters are undefined.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (234,'Failure to Handle Missing Parameter','Description:

If too few arguments are sent to a function, the function will still pop the expected number of arguments from the stack. Potentially, a variable number of arguments could be exhausted in a function as well.



Mitigation:


PHASE:Build and Compilation:
This issue can be simply combated with the use of proper build process.

PHASE:Implementation:
Forward declare all functions. This is the recommended solution. Properly forward declaration of all used functions will result in a compiler error if too few arguments are sent to a function.

',1);
INSERT INTO "kb_items" VALUES (235,'Improper Handling of Extra Parameters','Description:

The software does not handle or incorrectly handles when the number of parameters, fields, or arguments with the same name exceeds the expected amount.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (236,'Improper Handling of Undefined Parameters','Description:

The software does not handle or incorrectly handles when a particular parameter, field, or argument name is not defined or supported by the product.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (237,'Improper Handling of Structural Elements','Description:

The software does not handle or incorrectly handles inputs that are related to complex structures.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (238,'Improper Handling of Incomplete Structural Elements','Description:

The software does not handle or incorrectly handles when a particular structural element is not completely specified.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (239,'Failure to Handle Incomplete Element','Description:

The software does not properly handle when a particular element is not completely specified.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (240,'Improper Handling of Inconsistent Structural Elements','Description:

The software does not handle or incorrectly handles when two or more structural elements should be consistent, but are not.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (241,'Improper Handling of Unexpected Data Type','Description:

The software does not handle or incorrectly handles when a particular element is not the expected type, e.g. it expects a digit (09) but is provided with a letter (AZ).



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (242,'Use of Inherently Dangerous Function','Description:

The program calls a function that can never be guaranteed to work safely.

Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account. The gets() function is unsafe because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarilysized input to gets() and overflow the destination buffer. Similarly, the >> operator is unsafe to use when reading into a staticallyallocated character array because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarilysized input to the >> operator and overflow the destination buffer.

Mitigation:


PHASE:Implementation Requirements:
Ban the use of dangerous functions. Use their safe equivalent.

PHASE:Testing:
Use grep or static analysis tools to spot usage of dangerous functions.

',1);
INSERT INTO "kb_items" VALUES (243,'Creation of chroot Jail Without Changing Working Directory','Description:

The program uses the chroot() system call to create a jail, but does not change the working directory afterward. This does not prevent access to files outside of the jail.

Improper use of chroot() may allow attackers to escape from the chroot jail. The chroot() function call does not change the process''''s current working directory, so relative paths may still refer to file system resources outside of the chroot jail after chroot() has been called.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (244,'Improper Clearing of Heap Memory Before Release Heap Inspection','Description:

Using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.

When sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a heap inspection attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (245,'J2EE Bad Practices: Direct Management of Connections','Description:

The J2EE application directly manages connections, instead of using the container''''s connection management facilities.

The J2EE standard forbids the direct management of connections. It requires that applications use the container''''s resource management facilities to obtain connections to resources. Every major web application container provides pooled database connection management as part of its resource management framework. Duplicating this functionality in an application is difficult and error prone, which is part of the reason it is forbidden under the J2EE standard.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (246,'J2EE Bad Practices: Direct Use of Sockets','Description:

The J2EE application directly uses sockets instead of using framework method calls.

The J2EE standard permits the use of sockets only for the purpose of communication with legacy systems when no higherlevel protocol is available. Authoring your own communication protocol requires wrestling with difficult security issues. Without significant scrutiny by a security expert, chances are good that a custom communication protocol will suffer from security problems. Many of the same issues apply to a custom implementation of a standard protocol. While there are usually more resources available that address security concerns related to implementing a standard protocol, these resources are also available to attackers.

Mitigation:


PHASE:Architecture and Design:
Use framework method calls instead of using sockets directly.

',1);
INSERT INTO "kb_items" VALUES (248,'Uncaught Exception','Description:

An exception is thrown from a function, but it is not caught.

When an exception is not caught, it may cause the program to crash or expose sensitive information.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (250,'Execution with Unnecessary Privileges','Description:

The software performs an operation at a privilege level that is higher than the minimum level required, which creates new weaknesses or amplifies the consequences of other weaknesses.

New weaknesses can be exposed because running with extra privileges, such as root or Administrator, can disable the normal security checks being performed by the operating system or surrounding environment. Other preexisting weaknesses can turn into security vulnerabilities if they occur while operating at raised privileges. Privilege management functions can behave in some lessthanobvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one nonroot user to another. Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as root when a signal fires or a subprocess is executed, the signal handler or subprocess will operate with root privileges.

Mitigation:


PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE271. Avoid weaknesses such as CWE288 and CWE420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.

PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:
Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE271. Avoid weaknesses such as CWE288 and CWE420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.

PHASE:Implementation:
Perform extensive input validation for any privileged code that must be exposed to the user and reject anything that does not fit your strict requirements.

PHASE:Implementation:
When dropping privileges, ensure that they have been dropped successfully to avoid CWE273. As protection mechanisms in the environment get stronger, privilegedropping calls may fail even if it seems like they would always succeed.

PHASE:Implementation:
If circumstances force you to run with extra privileges, then determine the minimum access level necessary. First identify the different permissions that the software and its users will need to perform their actions, such as file read and write permissions, network socket permissions, and so forth. Then explicitly allow those actions while denying all else [REF76]. Perform extensive input validation and canonicalization to minimize the chances of introducing a separate vulnerability. This mitigation is much more prone to error than dropping the privileges in the first place.

PHASE:Operation System Configuration:STRATEGY:Environment Hardening:
Ensure that the software runs properly under the Federal Desktop Core Configuration (FDCC) [REF199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.

',1);
INSERT INTO "kb_items" VALUES (252,'Unchecked Return Value','Description:

The software does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.

Two common programmer assumptions are this function call can never fail and it doesn''''t matter if this function call fails. If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the software is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges.

Mitigation:


PHASE:Implementation:
Check the results of all functions that return a value and verify that the value is expected.:EFFECTIVENESS:High

PHASE:Implementation:
Ensure that you account for all possible return values from the function.

PHASE:Implementation:
When designing a function, make sure you return a value or throw an exception in case of an error.

',1);
INSERT INTO "kb_items" VALUES (253,'Incorrect Check of Function Return Value','Description:

The software incorrectly checks a return value from a function, which prevents the software from detecting errors or exceptional conditions.

Important and common functions will return some value about the success of its actions. This will alert the program whether or not to handle any errors caused by that function.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Language Selection:
Use a language or compiler that uses exceptions and requires the catching of those exceptions.

PHASE:Implementation:
Properly check all functions which return a value.

PHASE:Implementation:
When designing any function make sure you return a value or throw an exception in case of an error.

',1);
INSERT INTO "kb_items" VALUES (256,'Unprotected Storage of Credentials','Description:

Storing a password in plaintext may result in a system compromise.

Password management issues occur when a password is stored in plaintext in an application''''s properties or configuration file. Storing a plaintext password in a configuration file allows anyone who can read the file access to the passwordprotected resource.

Mitigation:


PHASE:Architecture and Design:
Avoid storing passwords in easily accessible locations.

PHASE:Architecture and Design:
Consider storing cryptographic hashes of passwords as an alternative to storing in plaintext.

PHASE

DESCRIPTION:A programmer might attempt to remedy the password management problem by obscuring the password with an encoding function, such as base 64 encoding, but this effort does not adequately protect the password because the encoding can be detected and decoded easily.:EFFECTIVENESS:None

',1);
INSERT INTO "kb_items" VALUES (257,'Storing Passwords in a Recoverable Format','Description:

The storage of passwords in a recoverable format makes them subject to password reuse attacks by malicious users. In fact, it should be noted that recoverable encrypted passwords provide no significant benefit over plaintext passwords since they are subject not only to reuse by malicious attackers but also by malicious insiders. If a system administrator can recover a password directly, or use a brute force search on the available information, the administrator can use the password on other accounts.



Mitigation:


PHASE:Architecture and Design:
Use strong, nonreversible encryption to protect stored passwords.

',1);
INSERT INTO "kb_items" VALUES (258,'Empty Password in Configuration File','Description:

Using an empty string as a password is insecure.



Mitigation:


PHASE:System Configuration:
Passwords should be at least eight characters long  the longer the better. Avoid passwords that are in any way similar to other passwords you have. Avoid using words that may be found in a dictionary, names book, on a map, etc. Consider incorporating numbers and/or punctuation into your password. If you do use common words, consider replacing letters in that word with numbers and punctuation. However, do not use similarlooking punctuation. For example, it is not a good idea to change cat to c@t, ca+, (@+, or anything similar. Finally, it is never appropriate to use an empty string as a password.

',1);
INSERT INTO "kb_items" VALUES (259,'Use of Hard coded Password','Description:

The software contains a hardcoded password, which it uses for its own inbound authentication or for outbound communication to external components.

A hardcoded password typically leads to a significant authentication failure that can be difficult for the system administrator to detect. Once detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the software contains an authentication mechanism that checks for a hardcoded password. Outbound: the software connects to another system or component, and it contains hardcoded password for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hardcoded into the product and associated with that account. This hardcoded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the software. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the software will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to frontend systems that authenticate with a backend service. The backend service may require a fixed password which can be easily discovered. The programmer may simply hardcode those backend credentials into the frontend software. Any user of that program may be able to extract the password. Clientside systems with hardcoded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.

Mitigation:


PHASE:Architecture and Design:
For outbound authentication: store passwords outside of the code in a stronglyprotected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible.

PHASE:Architecture and Design:
For inbound authentication: Rather than hardcode a default username and password for first time logins, utilize a first login mode that requires the user to enter a unique strong password.

PHASE:Architecture and Design:
Perform access control checks and limit which entities can access the feature that requires the hardcoded password. For example, a feature might only be enabled through the system console instead of through a network connection.

PHASE:Architecture and Design:
For inbound authentication: apply strong oneway hashes to your passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When receiving an incoming password during authentication, take the hash of the password and compare it to the hash that you have saved. Use randomly assigned salts for each separate hash that you generate. This increases the amount of computation that an attacker needs to conduct a bruteforce attack, possibly limiting the effectiveness of the rainbow table method.

PHASE:Architecture and Design:
For frontend to backend connections: Three solutions are possible, although none are complete. The first suggestion involves the use of generated passwords which are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals. Next, the passwords used should be limited at the back end to only performing actions valid for the front end, as opposed to having full access. Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay style attacks.

',1);
INSERT INTO "kb_items" VALUES (260,'Password in Configuration File','Description:

The software stores a password in a configuration file that might be accessible to actors who do not know the password.

This can result in compromise of the system for which the password is used. An attacker could gain access to this file and learn the stored password or worse yet, change the password to one of their choosing.

Mitigation:


PHASE:Architecture and Design:
Avoid storing passwords in easily accessible locations.

PHASE:Architecture and Design:
Consider storing cryptographic hashes of passwords as an alternative to storing in plaintext.

',1);
INSERT INTO "kb_items" VALUES (261,'Weak Encoding for Password','Description:

Obscuring a password with a trivial encoding does not protect the password.

Password management issues occur when a password is stored in plaintext in an application''''s properties or configuration file. A programmer can attempt to remedy the password management problem by obscuring the password with an encoding function, such as base 64 encoding, but this effort does not adequately protect the password.

Mitigation:


PHASE

DESCRIPTION:Passwords should be encrypted with keys that are at least 128 bits in length for adequate security.

',1);
INSERT INTO "kb_items" VALUES (262,'Not Using Password Aging','Description:

If no mechanism is in place for managing password aging, users will have no incentive to update passwords in a timely manner.

Security experts have often recommended that users change their passwords regularly and avoid reusing passwords. Although this can be an effective mitigation, if the expiration window is too short, it can cause users to generate poor or predictable passwords. As such, it is important to discourage creating similar passwords. It is also useful to have a password aging mechanism that notifies users when passwords are considered old and requests that they replace them with new, strong passwords. Companion documentation which stresses how important this practice is can help users understand and better support this approach.

Mitigation:


PHASE:Architecture and Design:
As part of a product''''s design, require users to change their passwords regularly and avoid reusing previous passwords.

',1);
INSERT INTO "kb_items" VALUES (263,'Password Aging with Long Expiration','Description:

Allowing password aging to occur unchecked can result in the possibility of diminished password integrity.

Just as neglecting to include functionality for the management of password aging is dangerous, so is allowing password aging to continue unchecked. Passwords must be given a maximum life span, after which a user is required to update with a new and different password.

Mitigation:


PHASE:Architecture and Design:
Ensure that password aging is limited so that there is a defined maximum age for passwords and so that the user is notified several times leading up to the password expiration.

',1);
INSERT INTO "kb_items" VALUES (265,'privileges','Description:

Weaknesses in this category occur with improper handling, assignment, or management of privileges. A privilege is a property of an agent, such as a user. It lets the agent do things that are not ordinarily allowed. For example, there are privileges which allow an agent to perform maintenance functions such as restart a computer.


Mitigation:


This can strongly overlap authorization errors.

Many of the following concepts require deeper study. Most privilege problems are not classified at such a low level of detail, and terminology is very sparse. Certain classes of software, such as web browsers and software bug trackers, provide a rich set of examples for further research. Operating systems have matured to the point that these kinds of weaknesses are rare, but finergrained models for privileges, capabilities, or roles might introduce subtler issues.

A sandbox could be regarded as an explicitly defined sphere of control, in that the sandbox only defines a limited set of behaviors, which can only access a limited set of resources.
',1);
INSERT INTO "kb_items" VALUES (266,'Incorrect Privilege Assignment','Description:

A product incorrectly assigns a privilege to a particular actor, creating an unintended sphere of control for that actor.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

',1);
INSERT INTO "kb_items" VALUES (267,'Privilege Defined With Unsafe Actions','Description:

A particular privilege, role, capability, or right can be used to perform unsafe actions that were not intended, even when it is assigned to the correct entity.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

',1);
INSERT INTO "kb_items" VALUES (268,'Privilege Chaining','Description:

Two distinct privileges, roles, capabilities, or rights can be combined in a way that allows an entity to perform unsafe actions that would not be allowed without that combination.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.

PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

',1);
INSERT INTO "kb_items" VALUES (269,'Improper Privilege Management','Description:

The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Follow the principle of least privilege when assigning access rights to entities in a software system.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.

',1);
INSERT INTO "kb_items" VALUES (270,'Privilege Context Switching Error','Description:

The software does not properly manage privileges while it is switching between different contexts that have different privileges or spheres of control.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.

',1);
INSERT INTO "kb_items" VALUES (271,'Privilege Dropping   Lowering Errors','Description:

The software does not drop privileges before passing control of a resource to an actor that does not have those privileges.

In some contexts, a system executing with elevated permissions will hand off a process/file/etc. to another process or user. If the privileges of an entity are not reduced, then elevated privileges are spread throughout a system and possibly to an attacker.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.

',1);
INSERT INTO "kb_items" VALUES (272,'Least Privilege Violation','Description:

The elevated privilege level required to perform operations such as chroot() should be dropped immediately after the operation is performed.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Follow the principle of least privilege when assigning access rights to entities in a software system.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (273,'Improper Check for Dropped Privileges','Description:

The software attempts to drop privileges but does not check or incorrectly checks to see if the drop succeeded.

If the drop fails, the software will continue to run with the raised privileges, which might provide additional access to unprivileged users.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Implementation:
Check the results of all functions that return a value and verify that the value is expected.:EFFECTIVENESS:High

PHASE:Implementation:
In Windows, make sure that the process token has the SeImpersonatePrivilege(Microsoft Server 2003). Code that relies on impersonation for security must ensure that the impersonation succeeded, i.e., that a proper privilege demotion happened.

',1);
INSERT INTO "kb_items" VALUES (274,'Improper Handling of Insufficient Privileges','Description:

The software does not handle or incorrectly handles when it has insufficient privileges to perform an operation, leading to resultant weaknesses.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (276,'Incorrect Default Permissions','Description:

The product, upon installation, sets incorrect permissions for an object that exposes it to an unintended actor.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (277,'Insecure Inherited Permissions','Description:

A product defines a set of insecure permissions that are inherited by objects that are created by the program.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (278,'Insecure Preserved Inherited Permissions','Description:

A product inherits a set of insecure permissions for an object, e.g. when copying from an archive file, without user awareness or involvement.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (279,'Incorrect Execution Assigned Permissions','Description:

While it is executing, the software sets the permissions of an object in a way that violates the intended permissions that have been specified by the user.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (280,'Improper Handling of Insufficient Permissions or Privileges ','Description:

The application does not handle or incorrectly handles when it has insufficient privileges to access resources or functionality as specified by their permissions. This may cause it to follow unexpected code paths that may leave the application in an invalid state.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Implementation:
Always check to see if you have successfully accessed a resource or system functionality, and use proper error handling if it is unsuccessful. Do this even when you are operating in a highly privileged mode, because errors or environmental conditions might still cause a failure. For example, environments with highly granular permissions/privilege models, such as Windows or Linux capabilities, can cause unexpected failures.

',1);
INSERT INTO "kb_items" VALUES (281,'Improper Preservation of Permissions','Description:

The software does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (282,'Improper Ownership Management','Description:

The software assigns the wrong ownership, or does not properly verify the ownership, of an object or resource.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

',1);
INSERT INTO "kb_items" VALUES (283,'Unverified Ownership','Description:

The software does not properly verify that a critical resource is owned by the proper entity.



Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.

',1);
INSERT INTO "kb_items" VALUES (284,'Improper Access Control','Description:

The software does not restrict or incorrectly restricts access to a resource from an unauthorized actor.

Access control involves the use of several protection mechanisms such as: Authentication (proving the identity of an actor) Authorization (ensuring that a given actor can access a resource), and Accountability (tracking of activities that were performed) When any mechanism is not applied or otherwise fails, attackers can compromise the security of the software by gaining privileges, reading sensitive information, executing commands, evading detection, etc. There are two distinct behaviors that can introduce access control weaknesses: Specification: incorrect privileges, permissions, ownership, etc. are explicitly specified for either the user or the resource (for example, setting a password file to be worldwritable, or giving administrator capabilities to a guest user). This action could be performed by the program or the administrator. Enforcement: the mechanism contains errors that prevent it from properly enforcing the specified access control requirements (e.g., allowing the user to specify their own privileges, or allowing a syntacticallyincorrect ACL to produce insecure settings). This problem occurs within the program itself, in that it does not actually enforce the intended security policy that the administrator specifies.

Mitigation:


PHASE:Architecture and Design Operation:
Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

',1);
INSERT INTO "kb_items" VALUES (285,'Improper Authorization','Description:

The software does not perform or incorrectly performs an authorization check when an actor attempts to access a resource or perform an action.

Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user''''s privileges and any permissions or other accesscontrol specifications that apply to the resource. When access control checks are not applied consistently  or not at all  users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.

Mitigation:


PHASE:Architecture and Design:
Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use rolebased access control (RBAC) to enforce the roles at the appropriate boundaries. Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.

PHASE:Architecture and Design:
Ensure that you perform access control checks related to your business logic. These checks may be different than the access control checks that you apply to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient''''s doctor.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF233] and the OWASP ESAPI Access Control feature [REF45].

PHASE:Architecture and Design:
For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page. One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.

PHASE:System Configuration Installation:
Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a default deny policy when defining these ACLs.

',1);
INSERT INTO "kb_items" VALUES (286,'Incorrect User Management','Description:

The software does not properly manage a user within its environment.

Users can be assigned to the wrong group (class) of permissions resulting in unintended access rights to sensitive objects.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (287,'Improper Authentication','Description:

When an actor claims to have a given identity, the software does not prove or insufficiently proves that the claim is correct.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use an authentication framework or library such as the OWASP ESAPI Authentication feature.

',1);
INSERT INTO "kb_items" VALUES (288,'Authentication Bypass Using an Alternate Path or Channel','Description:

A product requires authentication, but the product has an alternate path or channel that does not require authentication.



Mitigation:


PHASE:Architecture and Design:
Funnel all access through a single choke point to simplify how users can access a resource. For every access, perform a check to determine if the user has permissions to access the resource.

',1);
INSERT INTO "kb_items" VALUES (289,'Authentication Bypass by Alternate Name','Description:

The software performs authentication based on the name of a resource being accessed, or the name of the actor performing the access, but it does not properly check all possible names for that resource or actor.



Mitigation:


PHASE:Architecture and Design:STRATEGY:Input Validation:
Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (290,'Authentication Bypass by Spoofing','Description:

This attackfocused weakness is caused by improperly implemented authentication schemes that are subject to spoofing attacks.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (291,'Reliance on IP Address for Authentication','Description:

The software uses an IP address for authentication.

IP addresses can be easily spoofed. Attackers can forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication.

Mitigation:


PHASE:Architecture and Design:
Use other means of identity verification that cannot be simply spoofed. Possibilities include a username/password or certificate.

',1);
INSERT INTO "kb_items" VALUES (293,'Using Referer Field for Authentication','Description:

The referer field in HTTP requests can be easily modified and, as such, is not a valid means of message integrity checking.



Mitigation:


PHASE:Architecture and Design:
In order to usefully check if a given action is authorized, some means of strong authentication and method protection must be used. Use other means of authorization that cannot be simply spoofed. Possibilities include a username/password or certificate.

',1);
INSERT INTO "kb_items" VALUES (294,'Authentication Bypass by Capture replay','Description:

A capturereplay flaw exists when the design of the software makes it possible for a malicious user to sniff network traffic and bypass authentication by replaying it to the server in question to the same effect as the original message (or with minor changes).

Capturereplay attacks are common and can be difficult to defeat without cryptography. They are a subset of network injection attacks that rely on observing previouslysent valid commands, then changing them slightly if necessary and resending the same commands to the server.

Mitigation:


PHASE:Architecture and Design:
Utilize some sequence or time stamping functionality along with a checksum which takes this into account in order to ensure that messages can be parsed only once.

PHASE:Architecture and Design:
Since any attacker who can listen to traffic can see sequence numbers, it is necessary to sign messages with some kind of cryptography to ensure that sequence numbers are not simply doctored along with content.

',1);
INSERT INTO "kb_items" VALUES (295,'Improper Certificate Validation','Description:

The software does not validate, or incorrectly validates, a certificate.

When a certificate is invalid or malicious, it might allow an attacker to spoof a trusted entity by interfering in the communication path between the host and client. The software might connect to a malicious host while believing it is a trusted host, or the software might be deceived into accepting spoofed data that appears to originate from a trusted host.

Mitigation:


PHASE:Architecture and Design Implementation:
Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner''''s public key.

PHASE:Implementation:
If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.

',1);
INSERT INTO "kb_items" VALUES (296,'Improper Following of a Certificates Chain of Trust','Description:

The software does not follow, or incorrectly follows, the chain of trust for a certificate back to a trusted root certificate, resulting in incorrect trust of any resource that is associated with that certificate.

If a system does not follow the chain of trust of a certificate to a root server, the certificate loses all usefulness as a metric of trust. Essentially, the trust gained from a certificate is derived from a chain of trust  with a reputable trusted entity at the end of that list. The end user must trust that reputable source, and this reputable source must vouch for the resource in question through the medium of the certificate. In some cases, this trust traverses several entities who vouch for one another. The entity trusted by the end user is at one end of this trust chain, while the certificatewielding resource is at the other end of the chain. If the user receives a certificate at the end of one of these trust chains and then proceeds to check only that the first link in the chain, no real trust has been derived, since the entire chain must be traversed back to a trusted source to verify the certificate. There are several ways in which the chain of trust might be broken, including but not limited to: Any certificate in the chain is selfsigned, unless it the root. Not every intermediate certificate is checked, starting from the original certificate all the way up to the root certificate. An intermediate, CAsigned certificate does not have the expected Basic Constraints or other important extensions. The root certificate has been compromised or authorized to the wrong party.

Mitigation:


PHASE:Architecture and Design:
Ensure that proper certificate checking is included in the system design.

PHASE:Implementation:
Understand, and properly implement all checks necessary to ensure the integrity of certificate trust integrity.

PHASE:Implementation:
If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the full chain of trust.

',1);
INSERT INTO "kb_items" VALUES (297,'Improper Validation of Certificate with Host Mismatch','Description:

The software communicates with a host that provides a certificate, but the software does not properly ensure that the certificate is actually associated with that host.

Even if a certificate is wellformed, signed, and follows the chain of trust, it may simply be a valid certificate for a different site than the site that the software is interacting with. If the certificate''''s hostspecific data is not properly checked  such as the Common Name (CN) in the Subject or the Subject Alternative Name (SAN) extension of an X.509 certificate  it may be possible for a redirection or spoofing attack to allow a malicious host with a valid certificate to provide data, impersonating a trusted host. In order to ensure data integrity, the certificate must be valid and it must pertain to the site that is being accessed. Even if the software attempts to check the hostname, it is still possible to incorrectly check the hostname. For example, attackers could create a certificate with a name that begins with a trusted name followed by a NUL byte, which could cause some stringbased comparisons to only examine the portion that contains the trusted name. This weakness can occur even when the software uses Certificate Pinning, if the software does not verify the hostname at the time a certificate is pinned.

Mitigation:


PHASE:Architecture and Design:
Fully check the hostname of the certificate and provide the user with adequate information about the nature of the problem and how to proceed.

PHASE:Implementation:
If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.

',1);
INSERT INTO "kb_items" VALUES (298,'Improper Validation of Certificate Expiration','Description:

A certificate expiration is not validated or is incorrectly validated, so trust may be assigned to certificates that have been abandoned due to age.

When the expiration of a certificate is not taken into account, no trust has necessarily been conveyed through it. Therefore, the validity of the certificate cannot be verified and all benefit of the certificate is lost.

Mitigation:


PHASE:Architecture and Design:
Check for expired certificates and provide the user with adequate information about the nature of the problem and how to proceed.

PHASE:Implementation:
If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the expiration.

',1);
INSERT INTO "kb_items" VALUES (299,'Improper Check for Certificate Revocation','Description:

The software does not check or incorrectly checks the revocation status of a certificate, which may cause it to use a certificate that has been compromised.

An improper check for certificate revocation is a far more serious flaw than related certificate failures. This is because the use of any revoked certificate is almost certainly malicious. The most common reason for certificate revocation is compromise of the system in question, with the result that no legitimate servers will be using a revoked certificate, unless they are sorely out of sync.

Mitigation:


PHASE:Architecture and Design:
Ensure that certificates are checked for revoked status.

PHASE:Implementation:
If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the revoked status.

',1);
INSERT INTO "kb_items" VALUES (300,'Channel Accessible by Non Endpoint','Description:

The product does not adequately verify the identity of actors at both ends of a communication channel, or does not adequately ensure the integrity of the channel, in a way that allows the channel to be accessed or influenced by an actor that is not an endpoint.

In order to establish secure communication between two parties, it is often important to adequately verify the identity of entities at each end of the communication channel. Inadequate or inconsistent verification may result in insufficient or incorrect identification of either communicating entity. This can have negative consequences such as misplaced trust in the entity at the other end of the channel. An attacker can leverage this by interposing between the communicating entities and masquerading as the original entity. In the absence of sufficient verification of identity, such an attacker can eavesdrop and potentially modify the communication between the original entities.

Mitigation:


PHASE:Implementation:
Always fully authenticate both ends of any communications channel.

PHASE:Architecture and Design:
Adhere to the principle of complete mediation.

PHASE:Implementation:
A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer''''s private key. The certificate can be validated by deciphering the certificate with the issuer''''s public key. See also X.509 certificate signature chains and the PGP certification structure.

',1);
INSERT INTO "kb_items" VALUES (301,'Reflection Attack in an Authentication Protocol','Description:

Simple authentication protocols are subject to reflection attacks if a malicious user can use the target machine to impersonate a trusted user.

A mutual authentication protocol requires each party to respond to a random challenge by the other party by encrypting it with a preshared key. Often, however, such protocols employ the same preshared key for communication with a number of different entities. A malicious user or an attacker can easily compromise this protocol without possessing the correct key by employing a reflection attack on the protocol.

Mitigation:


PHASE:Architecture and Design:
Use different keys for the initiator and responder or of a different type of challenge for the initiator and responder.

PHASE:Architecture and Design:
Let the initiator prove its identity before proceeding.

',1);
INSERT INTO "kb_items" VALUES (302,'Authentication Bypass by Assumed Immutable Data','Description:

The authentication scheme or implementation uses key data elements that are assumed to be immutable, but can be controlled or modified by the attacker.



Mitigation:


PHASE:Architecture and Design Operation Implementation:
Implement proper protection for immutable data (e.g. environment variable, hidden form fields, etc.)

',1);
INSERT INTO "kb_items" VALUES (303,'Incorrect Implementation of Authentication Algorithm','Description:

The requirements for the software dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.

This incorrect implementation may allow authentication to be bypassed.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (304,'Missing Critical Step in Authentication','Description:

The software implements an authentication technique, but it skips a step that weakens the technique.

Authentication techniques should follow the algorithms that define them exactly, otherwise authentication can be bypassed or more easily subjected to brute force attacks.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (305,'Authentication Bypass by Primary Weakness','Description:

The authentication algorithm is sound, but the implemented mechanism can be bypassed as the result of a separate weakness that is primary to the authentication error.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (306,'Missing Authentication for Critical Function','Description:

The software does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.



Mitigation:


PHASE:Architecture and Design:
Divide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability. Identify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port. In general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Architecture and Design:
Where possible, avoid implementing custom authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These may make it easier to provide a clear separation between authentication tasks and authorization tasks. In environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF45].

',1);
INSERT INTO "kb_items" VALUES (307,'Improper Restriction of Excessive Authentication Attempts','Description:

The software does not implement sufficient measures to prevent multiple failed authentication attempts within in a short time frame, making it more susceptible to brute force attacks.



Mitigation:


PHASE:Architecture and Design:
Common protection mechanisms include: Disconnecting the user after a small number of failed attempts Implementing a timeout Locking out a targeted account Requiring a computational task on the user''''s part.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator. [REF45]

',1);
INSERT INTO "kb_items" VALUES (308,'Use of Single factor Authentication','Description:

The use of singlefactor authentication can lead to unnecessary risk of compromise when compared with the benefits of a dualfactor authentication scheme.

While the use of multiple authentication schemes is simply piling on more complexity on top of authentication, it is inestimably valuable to have such measures of redundancy. The use of weak, reused, and common passwords is rampant on the internet. Without the added protection of multiple authentication schemes, a single mistake can result in the compromise of an account. For this reason, if multiple schemes are possible and also easy to use, they should be implemented and required.

Mitigation:


PHASE:Architecture and Design:
Use multiple independent authentication schemes, which ensures that  if one of the methods is compromised  the system itself is still likely safe from compromise.

',1);
INSERT INTO "kb_items" VALUES (309,'Use of Password System for Primary Authentication','Description:

The use of password systems as the primary means of authentication may be subject to several flaws or shortcomings, each reducing the effectiveness of the mechanism.



Mitigation:


PHASE:Architecture and Design:
In order to protect password systems from compromise, the following should be noted: Passwords should be stored safely to prevent insider attack and to ensure that  if a system is compromised  the passwords are not retrievable. Due to password reuse, this information may be useful in the compromise of other systems these users work with. In order to protect these passwords, they should be stored encrypted, in a nonreversible state, such that the original text password cannot be extracted from the stored value. Password aging should be strictly enforced to ensure that passwords do not remain unchanged for long periods of time. The longer a password remains in use, the higher the probability that it has been compromised. For this reason, passwords should require refreshing periodically, and users should be informed of the risk of passwords which remain in use for too long. Password strength should be enforced intelligently. Rather than restrict passwords to specific content, or specific length, users should be encouraged to use upper and lower case letters, numbers, and symbols in their passwords. The system should also ensure that no passwords are derived from dictionary words.

PHASE:Architecture and Design:
Use a zeroknowledge password protocol, such as SRP.

PHASE:Architecture and Design:
Ensure that passwords are stored safely and are not reversible.

PHASE:Architecture and Design:
Implement password aging functionality that requires passwords be changed after a certain point.

PHASE:Architecture and Design:
Use a mechanism for determining the strength of a password and notify the user of weak password use.

PHASE:Architecture and Design:
Inform the user of why password protections are in place, how they work to protect data integrity, and why it is important to heed their warnings.

',1);
INSERT INTO "kb_items" VALUES (310,'cryptpgraphic issues','Description:

Weaknesses in this category are related to the design and implementation of data confidentiality and integrity. Frequently these deal with the use of encoding techniques, encryption libraries, and hashing algorithms. The weaknesses in this category could lead to a degradation of the quality data if they are not addressed.


Mitigation:


Follow the link to CWE for the references.
',1);
INSERT INTO "kb_items" VALUES (311,'Missing Encryption of Sensitive Data','Description:

The software does not encrypt sensitive or critical information before storage or transmission.

The lack of proper data encryption passes up the guarantees of confidentiality, integrity, and accountability that properly implemented encryption conveys.

Mitigation:


PHASE:Requirements:
Clearly specify which data or resources are valuable enough that they should be protected by encryption. Require that any transmission or storage of this data/resource should use wellvetted encryption algorithms.

PHASE:Architecture and Design:
Ensure that encryption is properly integrated into the system design, including but not necessarily limited to: Encryption that is needed to store or transmit private data of the users of the system Encryption that is needed to protect the system itself from unauthorized disclosure or tampering Identify the separate needs and contexts for encryption: Oneway (i.e., only the user or recipient needs to have the key). This can be achieved using public key cryptography, or other techniques in which the encrypting party (i.e., the software) does not need to have access to a private key. Twoway (i.e., the encryption can be automatically performed on behalf of a user, but the key must be available so that the plaintext can be automatically recoverable by that user). This requires storage of the private key in a format that is recoverable only by the user (or perhaps by the operating system) in a way that cannot be recovered by others. Using threat modeling or other techniques, assume that data can be compromised through a separate vulnerability or weakness, and determine where encryption will be most effective. Ensure that data that should be private is not being inadvertently exposed using weaknesses such as insecure permissions (CWE732). [REF7]

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
When there is a need to store or transmit sensitive data, use strong, uptodate cryptographic algorithms to encrypt that data. Select a wellvetted algorithm that is currently considered to be strong by experts in the field, and use welltested implementations. As with all cryptographic mechanisms, the source code should be available for analysis. For example, US government systems require FIPS 1402 certification. Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are wellunderstood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak. Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF267]

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.

PHASE:Implementation Architecture and Design:
When using industryapproved techniques, use them correctly. Don''''t cut corners by skipping resourceintensive steps (CWE325). These steps are often essential for preventing common attacks.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and nonsensitive data as much as possible.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (312,'Cleartext Storage of Sensitive Information','Description:

The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.

Because the information is stored in cleartext, attackers could potentially read it. Even if the information is encoded in a way that is not humanreadable, certain techniques could determine which encoding is being used, then decode the information.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (313,'Cleartext Storage in a File or on Disk','Description:

The application stores sensitive information in cleartext in a file, or on disk.

The sensitive information could be read by attackers with access to the file, or with physical or administrator access to the raw disk. Even if the information is encoded in a way that is not humanreadable, certain techniques could determine which encoding is being used, then decode the information.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (314,'Cleartext Storage in the Registry','Description:

The application stores sensitive information in cleartext in the registry.

Attackers can read the information by accessing the registry key. Even if the information is encoded in a way that is not humanreadable, certain techniques could determine which encoding is being used, then decode the information.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (315,'Cleartext Storage of Sensitive Information in a Cookie','Description:

The application stores sensitive information in cleartext in a cookie.

Attackers can use widelyavailable tools to view the cookie and read the sensitive information. Even if the information is encoded in a way that is not humanreadable, certain techniques could determine which encoding is being used, then decode the information.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (316,'Cleartext Storage of Sensitive Information in Memory','Description:

The application stores sensitive information in cleartext in memory.

The sensitive memory might be saved to disk, stored in a core dump, or remain uncleared if the application crashes, or if the programmer does not properly clear the memory before freeing it. It could be argued that such problems are usually only exploitable by those with administrator privileges. However, swapping could cause the memory to be written to disk and leave it accessible to physical attack afterwards. Core dump files might have insecure permissions or be stored in archive files that are accessible to untrusted people. Or, uncleared sensitive memory might be inadvertently exposed to attackers due to another weakness.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (317,'Cleartext Storage of Sensitive Information in GUI','Description:

The application stores sensitive information in cleartext within the GUI.

An attacker can often obtain data from a GUI, even if hidden, by using an API to directly access GUI objects such as windows and menus. Even if the information is encoded in a way that is not humanreadable, certain techniques could determine which encoding is being used, then decode the information.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (318,'Cleartext Storage of Sensitive Information in Executable','Description:

The application stores sensitive information in cleartext in an executable.

Attackers can reverse engineer binary code to obtain secret data. This is especially easy when the cleartext is plain ASCII. Even if the information is encoded in a way that is not humanreadable, certain techniques could determine which encoding is being used, then decode the information.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (319,'Cleartext Transmission of Sensitive Information','Description:

The software transmits sensitive or securitycritical data in cleartext in a communication channel that can be sniffed by unauthorized actors.

Many communication channels can be sniffed by attackers during data transmission. For example, network traffic can often be sniffed by any attacker who has access to a network interface. This significantly lowers the difficulty of exploitation by attackers.

Mitigation:


PHASE:Architecture and Design:
Encrypt the data with a reliable encryption scheme before transmitting.

PHASE:Implementation:
When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.

PHASE:Testing:
Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.

PHASE:Operation:
Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.

',1);
INSERT INTO "kb_items" VALUES (320,'key management errors','Description:

Weaknesses in this category are related to errors in the management of cryptographic keys.



Mitigation:


This entry heavily overlaps other categories and has been marked obsolete.
This entry is a Category, but various sources map to it anyway despite CWE guidance that Categories should not be mapped. Future mappings should use an appropriate weakness going forward

Please follow the link for more information.
',1);
INSERT INTO "kb_items" VALUES (321,'Use of Hard coded Cryptographic Key','Description:

The use of a hardcoded cryptographic key significantly increases the possibility that encrypted data may be recovered.



Mitigation:


PHASE:Architecture and Design:
Prevention schemes mirror that of hardcoded password storage.

',1);
INSERT INTO "kb_items" VALUES (322,'Key Exchange without Entity Authentication','Description:

The software performs a key exchange with an actor without verifying the identity of that actor.

Performing a key exchange will preserve the integrity of the information sent between two entities, but this will not guarantee that the entities are who they claim they are. This may enable an attacker to impersonate an actor by modifying traffic between the two entities. Typically, this involves a victim client that contacts a malicious server that is impersonating a trusted server. If the client skips authentication or ignores an authentication failure, the malicious server may request authentication information from the user. The malicious server can then use this authentication information to log in to the trusted server using the victim''''s credentials, sniff traffic between the victim and trusted server, etc.

Mitigation:


PHASE:Architecture and Design:
Ensure that proper authentication is included in the system design.

PHASE:Implementation:
Understand and properly implement all checks necessary to ensure the identity of entities involved in encrypted communications.

',1);
INSERT INTO "kb_items" VALUES (324,'Use of a Key Past its Expiration Date','Description:

The product uses a cryptographic key or password past its expiration date, which diminishes its safety significantly by increasing the timing window for cracking attacks against that key.

While the expiration of keys does not necessarily ensure that they are compromised, it is a significant concern that keys which remain in use for prolonged periods of time have a decreasing probability of integrity. For this reason, it is important to replace keys within a period of time proportional to their strength.

Mitigation:


PHASE:Architecture and Design:
Adequate consideration should be put in to the user interface in order to notify users previous to the key''''s expiration, to explain the importance of new key generation and to walk users through the process as painlessly as possible.

',1);
INSERT INTO "kb_items" VALUES (325,'Missing Required Cryptographic Step','Description:

The product does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by that algorithm.

Cryptographic implementations should precisely follow the algorithms that define them, otherwise encryption can be weaker than expected.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (326,'Inadequate Encryption Strength','Description:

The software stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.

A weak encryption scheme can be subjected to brute force attacks that have a reasonable chance of succeeding using current attack methods and resources.

Mitigation:


PHASE:Architecture and Design:
Use an encryption scheme that is currently considered to be strong by experts in the field.

',1);
INSERT INTO "kb_items" VALUES (327,'Use of a Broken or Risky Cryptographic Algorithm','Description:

The use of a broken or risky cryptographic algorithm is an unnecessary risk that may result in the exposure of sensitive information.

The use of a nonstandard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has been protected. Wellknown techniques may exist to break the algorithm.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
When there is a need to store or transmit sensitive data, use strong, uptodate cryptographic algorithms to encrypt that data. Select a wellvetted algorithm that is currently considered to be strong by experts in the field, and use welltested implementations. As with all cryptographic mechanisms, the source code should be available for analysis. For example, US government systems require FIPS 1402 certification. Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are wellunderstood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak. Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF267]

PHASE:Architecture and Design:
Design the software so that one cryptographic algorithm can be replaced with another. This will make it easier to upgrade to stronger algorithms.

PHASE:Architecture and Design:
Carefully manage and protect cryptographic keys (see CWE320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industrystandard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.

PHASE:Implementation Architecture and Design:
When using industryapproved techniques, use them correctly. Don''''t cut corners by skipping resourceintensive steps (CWE325). These steps are often essential for preventing common attacks.

',1);
INSERT INTO "kb_items" VALUES (328,'Reversible One Way Hash','Description:

The product uses a hashing algorithm that produces a hash value that can be used to determine the original input, or to find an input that can produce the same hash, more efficiently than brute force techniques.

This weakness is especially dangerous when the hash is used in security algorithms that require the oneway property to hold. For example, if an authentication system takes an incoming password and generates a hash, then compares the hash to another hash that it has stored in its authentication database, then the ability to create a collision could allow an attacker to provide an alternate password that produces the same target hash, bypassing authentication.

Mitigation:


PHASE:Architecture and Design:
Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (stretching) or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionallyfast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use. Some hash functions that have one or more of these desired properties include bcrypt [REF291], scrypt [REF292], and PBKDF2 [REF293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead. Note that using these functions can have an impact on performance, so they require special consideration to avoid denialofservice attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment''''s needs.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (329,'Not Using a Random IV with CBC Mode','Description:

Not using a random initialization Vector (IV) with Cipher Block Chaining (CBC) Mode causes algorithms to be susceptible to dictionary attacks.



Mitigation:


PHASE:Implementation:
It is important to properly initialize CBC operating block ciphers or their utility is lost.

',1);
INSERT INTO "kb_items" VALUES (330,'Use of Insufficiently Random Values','Description:

The software uses insufficiently random numbers or values in a security context that depends on unpredictable numbers.

When software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that will be generated, and use this guess to impersonate another user or access sensitive information.

Mitigation:


PHASE:Architecture and Design:
Use a wellvetted algorithm that is currently considered to be strong by experts in the field, and select welltested implementations with adequate length seeds. In general, if a pseudorandom number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in securitysensitive contexts. Pseudorandom number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256bit seed is a good starting point for producing a random enough number.

PHASE:Implementation:
Consider a PRNG that reseeds itself as needed from high quality pseudorandom output sources, such as hardware devices.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

PHASE:Testing:
Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.

',1);
INSERT INTO "kb_items" VALUES (331,'Insufficient Entropy','Description:

The software uses an algorithm or scheme that produces insufficient entropy, leaving patterns or clusters of values that are more likely to occur than others.



Mitigation:


PHASE:Implementation:
Determine the necessary entropy to adequately provide for randomness and predictability. This can be achieved by increasing the number of bits of objects such as keys and seeds.

',1);
INSERT INTO "kb_items" VALUES (332,'Insufficient Entropy in PRNG','Description:

The lack of entropy available for, or used by, a PseudoRandom Number Generator (PRNG) can be a stability and security threat.



Mitigation:


PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

PHASE:Implementation:
Consider a PRNG that reseeds itself as needed from highquality pseudorandom output, such as hardware devices.

PHASE:Architecture and Design:
When deciding which PRNG to use, look at its sources of entropy. Depending on what your security needs are, you may need to use a random number generator that always uses strong random data  i.e., a random number generator that attempts to be strong but will fail in a weak way or will always provide some middle ground of protection through techniques like reseeding. Generally, something that always provides a predictable amount of strength is preferable.

',1);
INSERT INTO "kb_items" VALUES (333,'Improper Handling of Insufficient Entropy in TRNG','Description:

True random number generators (TRNG) generally have a limited source of entropy and therefore can fail or block.

The rate at which true random numbers can be generated is limited. It is important that one uses them only when they are needed for security.

Mitigation:


PHASE:Implementation:
Rather than failing on a lack of random numbers, it is often preferable to wait for more numbers to be created.

',1);
INSERT INTO "kb_items" VALUES (334,'Small Space of Random Values','Description:

The number of possible random values is smaller than needed by the product, making it more susceptible to brute force attacks.



Mitigation:


PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

',1);
INSERT INTO "kb_items" VALUES (335,'Incorrect Usage of Seeds in Pseudo Random Number Generator PRNG','Description:

The software uses a PseudoRandom Number Generator (PRNG) that does not correctly manage seeds.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (336,'Same Seed in Pseudo Random Number Generator PRNG','Description:

A PseudoRandom Number Generator (PRNG) uses the same seed each time the product is initialized.

If an attacker can guess (or knows) the seed, then the attacker may be able to determine the random numbers that will be produced from the PRNG.

Mitigation:


PHASE:Architecture and Design:
Do not reuse PRNG seeds. Consider a PRNG that periodically reseeds itself as needed from a high quality pseudorandom output, such as hardware devices.

PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

',1);
INSERT INTO "kb_items" VALUES (337,'Predictable Seed in Pseudo Random Number Generator PRNG','Description:

A PseudoRandom Number Generator (PRNG) is initialized from a predictable seed, such as the process ID or system time.

The use of predictable seeds significantly reduces the number of possible seeds that an attacker would need to test in order to predict which random numbers will be generated by the PRNG.

Mitigation:


PHASE

DESCRIPTION:Use nonpredictable inputs for seed generation.

PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

PHASE:Implementation:
Use a PRNG that periodically reseeds itself using input from highquality sources, such as hardware devices with high entropy. However, do not reseed too frequently, or else the entropy source might block.

',1);
INSERT INTO "kb_items" VALUES (338,'Use of Cryptographically Weak Pseudo Random Number Generator PRNG','Description:

The product uses a PseudoRandom Number Generator (PRNG) in a security context, but the PRNG''''s algorithm is not cryptographically strong.

When a noncryptographic PRNG is used in a cryptographic context, it can expose the cryptography to certain types of attacks. Often a pseudorandom number generator (PRNG) is not designed for cryptography. Sometimes a mediocre source of randomness is sufficient or preferable for algorithms that use random numbers. Weak generators generally take less processing power and/or do not use the precious, finite, entropy sources on a system. While such PRNGs might have very useful features, these same features could be used to break the cryptography.

Mitigation:


PHASE:Implementation:
Use functions or hardware which use a hardwarebased random number generation for all crypto. This is the recommended solution. Use CyptGenRandom on Windows, or hw_rand() on Linux.

',1);
INSERT INTO "kb_items" VALUES (339,'Small Seed Space in PRNG','Description:

A PRNG uses a relatively small space of seeds.



Mitigation:


PHASE:Architecture and Design:
Use well vetted pseudorandom number generating algorithms with adequate length seeds. Pseudorandom number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256bit seed is a good starting point for producing a random enough number.

PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

',1);
INSERT INTO "kb_items" VALUES (340,'Generation of Predictable Numbers or Identifiers','Description:

The product uses a scheme that generates numbers or identifiers that are more predictable than required.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (341,'Predictable from Observable State','Description:

A number or object is predictable based on observations that the attacker can make about the state of the system or network, such as time, process ID, etc.



Mitigation:


PHASE:Implementation:
Increase the entropy used to seed a PRNG.

PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

PHASE:Implementation:
Use a PRNG that periodically reseeds itself using input from highquality sources, such as hardware devices with high entropy. However, do not reseed too frequently, or else the entropy source might block.

',1);
INSERT INTO "kb_items" VALUES (342,'Predictable Exact Value from Previous Values','Description:

An exact value or random number can be precisely predicted by observing previous values.



Mitigation:


PHASE

DESCRIPTION:Increase the entropy used to seed a PRNG.

PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

PHASE:Implementation:
Use a PRNG that periodically reseeds itself using input from highquality sources, such as hardware devices with high entropy. However, do not reseed too frequently, or else the entropy source might block.

',1);
INSERT INTO "kb_items" VALUES (343,'Predictable Value Range from Previous Values','Description:

The software''''s random number generator produces a series of values which, when observed, can be used to infer a relatively small range of possibilities for the next value that could be generated.

The output of a random number generator should not be predictable based on observations of previous values. In some cases, an attacker cannot predict the exact value that will be produced next, but can narrow down the possibilities significantly. This reduces the amount of effort to perform a brute force attack. For example, suppose the product generates random numbers between 1 and 100, but it always produces a larger value until it reaches 100. If the generator produces an 80, then the attacker knows that the next value will be somewhere between 81 and 100. Instead of 100 possibilities, the attacker only needs to consider 20.

Mitigation:


PHASE

DESCRIPTION:Increase the entropy used to seed a PRNG.

PHASE:Architecture and Design Requirements:STRATEGY:Libraries or Frameworks:
Use products or modules that conform to FIPS 1402 [REF267] to avoid obvious entropy problems. Consult FIPS 1402 Annex C (Approved Random Number Generators).

PHASE:Implementation:
Use a PRNG that periodically reseeds itself using input from highquality sources, such as hardware devices with high entropy. However, do not reseed too frequently, or else the entropy source might block.

',1);
INSERT INTO "kb_items" VALUES (344,'Use of Invariant Value in Dynamically Changing Context','Description:

The product uses a constant value, name, or reference, but this value can (or should) vary across different environments.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (345,'Insufficient Verification of Data Authenticity','Description:

The software does not sufficiently verify the origin or authenticity of data, in a way that causes it to accept invalid data.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (346,'Origin Validation Error','Description:

The software does not properly verify that the source of data or communication is valid.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (347,'Improper Verification of Cryptographic Signature','Description:

The software does not verify, or incorrectly verifies, the cryptographic signature for data.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (348,'Use of Less Trusted Source','Description:

The software has two different sources of the same data or information, but it uses the source that has less support for verification, is less trusted, or is less resistant to attack.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (349,'Acceptance of Extraneous Untrusted Data With Trusted Data','Description:

The software, when processing trusted data, accepts any untrusted data that is also included with the trusted data, treating the untrusted data as if it were trusted.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (350,'Reliance on Reverse DNS Resolution for a Security Critical Action','Description:

The software performs reverse DNS resolution on an IP address to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname.

Since DNS names can be easily spoofed or misreported, and it may be difficult for the software to detect if a trusted DNS server has been compromised, DNS names do not constitute a valid authentication mechanism. When the software performs a reverse DNS resolution for an IP address, if an attacker controls the server for that IP address, then the attacker can cause the server to return an arbitrary hostname. As a result, the attacker may be able to bypass authentication, cause the wrong hostname to be recorded in log files to hide activities, or perform other attacks. Attackers can spoof DNS names by either (1) compromising a DNS server and modifying its records (sometimes called DNS cache poisoning), or (2) having legitimate control over a DNS server associated with their IP address.

Mitigation:


PHASE:Architecture and Design:
Use other means of identity verification that cannot be simply spoofed. Possibilities include a username/password or certificate.

PHASE:Implementation:
Perform proper forward and reverse DNS lookups to detect DNS spoofing.

',1);
INSERT INTO "kb_items" VALUES (351,'Insufficient Type Distinction','Description:

The software does not properly distinguish between different types of elements in a way that leads to insecure behavior.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (352,'Cross Site Request Forgery CSRF','Description:

The web application does not, or can not, sufficiently verify whether a wellformed, valid, consistent request was intentionally provided by the user who submitted the request.

When a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, use antiCSRF packages such as the OWASP CSRFGuard. [REF330] Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF45]

PHASE:Implementation:
Ensure that the application is free of crosssite scripting issues (CWE79), because most CSRF defenses can be bypassed using attackercontrolled script.

PHASE:Architecture and Design:
Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE330). [REF332]

PHASE:Architecture and Design:
Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.

PHASE:Architecture and Design:
Use the doublesubmitted cookie method as described by Felten and Zeller: When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user''''s machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same. Because of the sameorigin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult. This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF331]

PHASE:Architecture and Design:
Do not use the GET method for any request that triggers a state change.

PHASE:Implementation:
Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.

',1);
INSERT INTO "kb_items" VALUES (353,'Missing Support for Integrity Check','Description:

The software uses a transmission protocol that does not include a mechanism for verifying the integrity of the data during transmission, such as a checksum.

If integrity check values or checksums are omitted from a protocol, there is no way of determining if data has been corrupted in transmission. The lack of checksum functionality in a protocol removes the first applicationlevel check of data that can be used. The endtoend philosophy of checks states that integrity checks should be performed at the lowest level that they can be completely implemented. Excluding further sanity checks and input validation performed by applications, the protocol''''s checksum is the most important level of checksum, since it can be performed more completely than at any previous level and takes into account entire messages, as opposed to single packets.

Mitigation:


PHASE:Architecture and Design:
Add an appropriately sized checksum to the protocol, ensuring that data received may be simply validated before it is parsed and used.

PHASE:Implementation:
Ensure that the checksums present in the protocol design are properly implemented and added to each message before it is sent.

',1);
INSERT INTO "kb_items" VALUES (354,'Improper Validation of Integrity Check Value','Description:

The software does not validate or incorrectly validates the integrity check values or checksums of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.

Improper validation of checksums before use results in an unnecessary risk that can easily be mitigated. The protocol specification describes the algorithm used for calculating the checksum. It is then a simple matter of implementing the calculation and verifying that the calculated checksum and the received checksum match. Improper verification of the calculated checksum and the received checksum can lead to far greater consequences.

Mitigation:


PHASE:Implementation:
Ensure that the checksums present in messages are properly checked in accordance with the protocol specification before they are parsed and used.

',1);
INSERT INTO "kb_items" VALUES (356,'Product UI does not Warn User of Unsafe Actions','Description:

The software''''s user interface does not warn the user before undertaking an unsafe action on behalf of that user. This makes it easier for attackers to trick users into inflicting damage to their system.

Software systems should warn users that a potentially dangerous action may occur if the user proceeds. For example, if the user downloads a file from an unknown source and attempts to execute the file on their machine, then the application''''s GUI can indicate that the file is unsafe.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (357,'Insufficient UI Warning of Dangerous Operations','Description:

The user interface provides a warning to a user regarding dangerous or sensitive operations, but the warning is not noticeable enough to warrant attention.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (358,'Improperly Implemented Security Check for Standard','Description:

The software does not implement or incorrectly implements one or more securityrelevant checks as specified by the design of a standardized algorithm, protocol, or technique.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (359,'Exposure of Private Personal Information to an Unauthorized Actor','Description:

The product does not properly prevent a person''''s private, personal information from being accessed by actors who either (1) are not explicitly authorized to access the information or (2) do not have the implicit consent of the person about whom the information is collected.

There are many types of sensitive information that products must protect from attackers, including system data, communications, configuration, business secrets, intellectual property, and an individual''''s personal (private) information. Private personal information may include a password, phone number, geographic location, personal messages, credit card number, etc. Private information is important to consider whether the person is a user of the product, or part of a data set that is processed by the product. An exposure of private information does not necessarily prevent the product from working properly, and in fact the exposure might be intended by the developer, e.g. as part of data sharing with other organizations. However, the exposure of personal private information can still be undesirable or explicitly prohibited by law or regulation. Some types of private information include: Government identifiers, such as Social Security Numbers Contact information, such as home addresses and telephone numbers Geographic location  where the user is (or was) Employment history Ficial data  such as credit card numbers, salary, bank accounts, and debts Pictures, video, or audio Behavioral patterns  such as web surfing history, when certain activities are performed, etc. Relationships (and types of relationships) with others  family, friends, contacts, etc. Communications  email addresses, private messages, text messages, chat logs, etc. Health  medical conditions, insurance status, prescription records Account passwords and other credentials Some of this information may be characterized as PII (Personally Identifiable Information), Protected Health Information (PHI), etc. Categories of private information may overlap or vary based on the intended usage or the policies and practices of a particular industry. Sometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publiclyavailable mapping to an individual student''''s personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.

Mitigation:


PHASE:Requirements:
Identify and consult all relevant regulations for personal privacy. An organization may be required to comply with certain federal and state regulations, depending on its location, the type of business it conducts, and the nature of any private data it handles. Regulations may include Safe Harbor Privacy Framework [REF340], GrammLeach Bliley Act (GLBA) [REF341], Health Insurance Portability and Accountability Act (HIPAA) [REF342], General Data Protection Regulation (GDPR) [REF1047], California Consumer Privacy Act (CCPA) [REF1048], and others.

PHASE:Architecture and Design:
Carefully evaluate how secure design may interfere with privacy, and vice versa. Security and privacy concerns often seem to compete with each other. From a security perspective, all important operations should be recorded so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. Although there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable store private information on the file system, in the registry, or in other locallycontrolled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted.

',1);
INSERT INTO "kb_items" VALUES (360,'Trust of System Event Data','Description:

Security based on event locations are insecure and can be spoofed.

Events are a messaging system which may provide control data to programs listening for events. Events often do not have any type of authentication framework to allow them to be verified from a trusted source. Any application, in Windows, on a given desktop can send a message to any window on the same desktop. There is no authentication framework for these messages. Therefore, any message can be used to manipulate any process on the desktop if the process does not check the validity and safeness of those messages.

Mitigation:


PHASE:Architecture and Design:
Never trust or rely any of the information in an Event for security.

',1);
INSERT INTO "kb_items" VALUES (362,'Concurrent Execution using Shared Resource with Improper Synchronization Race Condition','Description:

The program contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.

This can have security implications when the expected synchronization is in securitycritical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity  the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity  the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an interfering code sequence can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single x++ statement may appear atomic at the code layer, but it is actually nonatomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x). The interfering code sequence could be trusted or untrusted. A trusted interfering code sequence occurs within the program; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable program.

Mitigation:


PHASE:Architecture and Design:
In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.

PHASE:Architecture and Design:
Use threadsafe capabilities such as the data access abstraction in Spring.

PHASE:Architecture and Design:
Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE400).

PHASE:Implementation:
When using multithreading and operating on shared variables, only use threadsafe functions.

PHASE:Implementation:
Use atomic operations on shared variables. Be wary of innocentlooking constructs such as x++. This may appear atomic at the code layer, but it is actually nonatomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.

PHASE:Implementation:
Use a mutex if available, but be sure to avoid related weaknesses such as CWE412.

PHASE:Implementation:
Avoid doublechecked locking (CWE609) and other implementation errors that arise when trying to avoid the overhead of synchronization.

PHASE:Implementation:
Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.

PHASE:Implementation:
Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

',1);
INSERT INTO "kb_items" VALUES (363,'Race Condition Enabling Link Following','Description:

The software checks the status of a file or directory before accessing it, which produces a race condition in which the file can be replaced with a link before the access is performed, causing the software to access the wrong file.

While developers might expect that there is a very narrow time window between the time of check and time of use, there is still a race condition. An attacker could cause the software to slow down (e.g. with memory consumption), causing the time window to become larger. Alternately, in some situations, the attacker could win the race by performing a large number of attacks.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (364,'Signal Handler Race Condition','Description:

The software uses a signal handler that introduces a race condition.

Race conditions frequently occur in signal handlers, since signal handlers support asynchronous actions. These race conditions have a variety of root causes and symptoms. Attackers may be able to exploit a signal handler race condition to cause the software state to be corrupted, possibly leading to a denial of service or even code execution. These issues occur when nonreentrant functions, or statesensitive actions occur in the signal handler, where they may be called at any time. These behaviors can violate assumptions being made by the regular code that is interrupted, or by other signal handlers that may also be invoked. If these functions are called at an inopportune moment  such as while a nonreentrant function is already running  memory corruption could occur that may be exploitable for code execution. Another signal race condition commonly found occurs when free is called within a signal handler, resulting in a double free and therefore a writewhatwhere condition. Even if a given pointer is set to NULL after it has been freed, a race condition still exists between the time the memory was freed and the pointer was set to NULL. This is especially problematic if the same signal handler has been set for more than one signal  since it means that the signal handler itself may be reentered. There are several known behaviors related to signal handlers that have received the label of signal handler race condition: Shared state (e.g. global data or static variables) that are accessible to both a signal handler and regular code Shared state between a signal handler and other signal handlers Use of nonreentrant functionality within a signal handler  which generally implies that shared state is being used. For example, malloc() and free() are nonreentrant because they may use global or static data structures for managing memory, and they are indirectly used by innocentseeming functions such as syslog(); these functions could be exploited for memory corruption and, possibly, code execution. Association of the same signal handler function with multiple signals  which might imply shared state, since the same code and resources are accessed. For example, this can be a source of doublefree and useafterfree weaknesses. Use of setjmp and longjmp, or other mechanisms that prevent a signal handler from returning control back to the original functionality While not technically a race condition, some signal handlers are designed to be called at most once, and being called more than once can introduce security problems, even when there are not any concurrent calls to the signal handler. This can be a source of doublefree and useafterfree weaknesses. Signal handler vulnerabilities are often classified based on the absence of a specific protection mechanism, although this style of classification is discouraged in CWE because programmers often have a choice of several different mechanisms for addressing the weakness. Such protection mechanisms may preserve exclusivity of access to the shared resource, and behavioral atomicity for the relevant code: Avoiding shared state Using synchronization in the signal handler Using synchronization in the regular code Disabling or masking other signals, which provides atomicity (which effectively ensures exclusivity)

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

PHASE:Architecture and Design:
Design signal handlers to only set flags, rather than perform complex functionality. These flags can then be checked and acted upon within the main program loop.

PHASE:Implementation:
Only use reentrant functions within signal handlers. Also, use sanity checks to ensure that state is consistent while performing asynchronous actions that affect the state of execution.

',1);
INSERT INTO "kb_items" VALUES (365,'Race Condition in Switch','Description:

The code contains a switch statement in which the switched variable can be modified while the switch is still executing, resulting in unexpected behavior.

This issue is particularly important in the case of switch statements that involve fallthrough style case statements  i.e., those which do not end with break. If the variable being tested by the switch changes in the course of execution, this could change the intended logic of the switch so much that it places the process in a contradictory state and in some cases could even result in memory corruption.

Mitigation:


PHASE:Implementation:
Variables that may be subject to race conditions should be locked before the switch statement starts and only unlocked after the statement ends.

',1);
INSERT INTO "kb_items" VALUES (366,'Race Condition within a Thread','Description:

If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.



Mitigation:


PHASE:Architecture and Design:
Use locking functionality. This is the recommended solution. Implement some form of locking mechanism around code which alters or reads persistent data in a multithreaded environment.

PHASE:Architecture and Design:
Create resourcelocking sanity checks. If no inherent locking mechanisms exist, use flags and signals to enforce your own blocking scheme when resources are being used by other threads of execution.

',1);
INSERT INTO "kb_items" VALUES (367,'Time of check Time of use TOCTOU Race Condition','Description:

The software checks the state of a resource before using that resource, but the resource''''s state can change between the check and the use in a way that invalidates the results of the check. This can cause the software to perform invalid actions when the resource is in an unexpected state.

This weakness can be securityrelevant when an attacker can influence the state of the resource between check and use. This can happen with shared resources such as files, memory, or even variables in multithreaded programs.

Mitigation:


PHASE:Implementation:
The most basic advice for TOCTOU vulnerabilities is to not perform a check before the use. This does not resolve the underlying issue of the execution of a function on a resource whose state and identity cannot be assured, but it does help to limit the false sense of security given by the check.

PHASE:Implementation:
When the file being altered is owned by the current user and group, set the effective gid and uid to that of the current user and group when executing this statement.

PHASE:Architecture and Design:
Limit the interleaving of operations on files from multiple processes.

PHASE:Implementation Architecture and Design:
If you cannot perform operations atomically and you must share access to the resource between multiple processes or threads, then try to limit the amount of time (CPU cycles) between the check and use of the resource. This will not fix the problem, but it could make it more difficult for an attack to succeed.

PHASE:Implementation:
Recheck the resource after the use call to verify that the action was taken appropriately.

PHASE:Architecture and Design:
Ensure that some environmental locking mechanism can be used to protect resources effectively.

PHASE:Implementation:
Ensure that locking occurs before the check, as opposed to afterwards, such that the resource, as checked, is the same as it is when in use.

',1);
INSERT INTO "kb_items" VALUES (368,'Context Switching Race Condition','Description:

A product performs a series of nonatomic actions to switch between contexts that cross privilege or other security boundaries, but a race condition allows an attacker to modify or misrepresent the product''''s behavior during the switch.

This is commonly seen in web browser vulnerabilities in which the attacker can perform certain actions while the browser is transitioning from a trusted to an untrusted domain, or vice versa, and the browser performs the actions on one domain using the trust level and resources of the other domain.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (369,'Divide By Zero','Description:

The product divides a value by zero.

This weakness typically occurs when an unexpected value is provided to the product, or if an error occurs that is not properly detected. It frequently occurs in calculations involving physical dimensions such as size, length, width, and height.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (370,'Missing Check for Certificate Revocation after Initial Check','Description:

The software does not check the revocation status of a certificate after its initial revocation check, which can cause the software to perform privileged actions even after the certificate is revoked at a later time.

If the revocation status of a certificate is not checked before each action that requires privileges, the system may be subject to a race condition. If a certificate is revoked after the initial check, all subsequent actions taken with the owner of the revoked certificate will lose all benefits guaranteed by the certificate. In fact, it is almost certain that the use of a revoked certificate indicates malicious activity.

Mitigation:


PHASE:Architecture and Design:
Ensure that certificates are checked for revoked status before each use of a protected resource. If the certificate is checked before each access of a protected resource, the delay subject to a possible race condition becomes almost negligible and significantly reduces the risk associated with this issue.

',1);
INSERT INTO "kb_items" VALUES (372,'Incomplete Internal State Distinction','Description:

The software does not properly determine which state it is in, causing it to assume it is in state X when in fact it is in state Y, causing it to perform incorrect operations in a securityrelevant manner.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (374,'Passing Mutable Objects to an Untrusted Method','Description:

The program sends noncloned mutable data as an argument to a method or function.

The function or method that has been called can alter or delete the mutable data. This could violate assumptions that the calling function has made about its state. In situations where unknown code is called with references to mutable data, this external code could make changes to the data sent. If this data was not previously cloned, the modified data might not be valid in the context of execution.

Mitigation:


PHASE:Implementation:
Pass in data which should not be altered as constant or immutable.

PHASE:Implementation:
Clone all mutable data before passing it into an external function . This is the preferred mitigation. This way, regardless of what changes are made to the data, a valid copy is retained for use by the class.

',1);
INSERT INTO "kb_items" VALUES (375,'Returning a Mutable Object to an Untrusted Caller','Description:

Sending noncloned mutable data as a return value may result in that data being altered or deleted by the calling function.

In situations where functions return references to mutable data, it is possible that the external code which called the function may make changes to the data sent. If this data was not previously cloned, the class will then be using modified data which may violate assumptions about its internal state.

Mitigation:


PHASE:Implementation:
Declare returned data which should not be altered as constant or immutable.

PHASE:Implementation:
Clone all mutable data before returning references to it. This is the preferred mitigation. This way, regardless of what changes are made to the data, a valid copy is retained for use by the class.

',1);
INSERT INTO "kb_items" VALUES (377,'Insecure Temporary File','Description:

Creating and using insecure temporary files can leave application and system data vulnerable to attack.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (378,'Creation of Temporary File With Insecure Permissions','Description:

Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.



Mitigation:


PHASE:Requirements:
Many contemporary languages have functions which properly handle this condition. Older C temp file functions are especially susceptible.

PHASE:Implementation:
Ensure that you use proper file permissions. This can be achieved by using a safe temp file function. Temporary files should be writable and readable only by the process that owns the file.

PHASE:Implementation:
Randomize temporary file names. This can also be achieved by using a safe tempfile function. This will ensure that temporary files will not be created in predictable places.

',1);
INSERT INTO "kb_items" VALUES (379,'Creation of Temporary File in Directory with Insecure Permissions','Description:

The software creates a temporary file in a directory whose permissions allow unintended actors to determine the file''''s existence or otherwise access that file.

On some operating systems, the fact that the temporary file exists may be apparent to any user with sufficient privileges to access that directory. Since the file is visible, the application that is using the temporary file could be known. If one has access to list the processes on the system, the attacker has gained information about what the user is doing at that time. By correlating this with the applications the user is running, an attacker could potentially discover what a user''''s actions are. From this, higher levels of security could be breached.

Mitigation:


PHASE:Requirements:
Many contemporary languages have functions which properly handle this condition. Older C temp file functions are especially susceptible.

PHASE:Implementation:
Try to store sensitive tempfiles in a directory which is not world readable  i.e., peruser directories.

PHASE:Implementation:
Avoid using vulnerable temp file functions.

',1);
INSERT INTO "kb_items" VALUES (382,'J2EE Bad Practices: Use of System.exit','Description:

A J2EE application uses System.exit(), which also shuts down its container.

It is never a good idea for a web application to attempt to shut down the application container. Access to a function that can shut down the application is an avenue for Denial of Service (DoS) attacks.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
The shutdown function should be a privileged function available only to a properly authorized administrative user

PHASE:Implementation:
Web applications should not call methods that cause the virtual machine to exit, such as System.exit()

PHASE:Implementation:
Web applications should also not throw any Throwables to the application server as this may adversely affect the container.

PHASE:Implementation:
Nonweb applications may have a main() method that contains a System.exit(), but generally should not call System.exit() from other locations in the code

',1);
INSERT INTO "kb_items" VALUES (383,'J2EE Bad Practices: Direct Use of Threads','Description:

Thread management in a Web application is forbidden in some circumstances and is always highly error prone.

Thread management in a web application is forbidden by the J2EE standard in some circumstances and is always highly error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application container. Even without interfering with the container, thread management usually leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors.

Mitigation:


PHASE:Architecture and Design:
For EJB, use framework approaches for parallel execution, instead of using threads.

',1);
INSERT INTO "kb_items" VALUES (384,'Session Fixation','Description:

Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.

Such a scenario is commonly observed when: 1. A web application authenticates a user without first invalidating the existing session, thereby continuing to use the session already associated with the user. 2. An attacker is able to force a known session identifier on a user so that, once the user authenticates, the attacker has access to the authenticated session. 3. The application or container uses predictable session identifiers. In the generic exploit of session fixation vulnerabilities, an attacker creates a new session on a web application and records the associated session identifier. The attacker then causes the victim to associate, and possibly authenticate, against the server using that session identifier, giving the attacker access to the user''''s account through the active session.

Mitigation:


PHASE:Architecture and Design:
Invalidate any existing session identifiers prior to authorizing a new user session.

PHASE:Architecture and Design:
For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user''''s browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don''''t match, invalidate the session, and force the user to log on again.

',1);
INSERT INTO "kb_items" VALUES (385,'Covert Timing Channel','Description:

Covert timing channels convey information by modulating some aspect of system behavior over time, so that the program receiving the information can observe system behavior and infer protected information.

In some instances, knowing when data is transmitted between parties can provide a malicious user with privileged information. Also, externally monitoring the timing of operations can potentially reveal sensitive data. For example, a cryptographic operation can expose its internal state if the time it takes to perform the operation varies, based on the state. Covert channels are frequently classified as either storage or timing channels. Some examples of covert timing channels are the system''''s paging rate, the time a certain transaction requires to execute, and the time it takes to gain access to a shared bus.

Mitigation:


PHASE:Architecture and Design:
Whenever possible, specify implementation strategies that do not introduce time variances in operations.

PHASE:Implementation:
Often one can artificially manipulate the time which operations take or  when operations occur  can remove information from the attacker.

PHASE:Implementation:
It is reasonable to add artificial or random delays so that the amount of CPU time consumed is independent of the action being taken by the application.

',1);
INSERT INTO "kb_items" VALUES (386,'Symbolic Name not Mapping to Correct Object','Description:

A constant symbolic reference to an object is used, even though the reference can resolve to a different object over time.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (390,'Detection of Error Condition Without Action','Description:

The software detects a specific error, but takes no actions to handle the error.



Mitigation:


PHASE:Implementation:
Properly handle each exception. This is the recommended solution. Ensure that all exceptions are handled in such a way that you can be sure of the state of your system at any given moment.

PHASE:Implementation:
If a function returns an error, it is important to either fix the problem and try again, alert the user that an error has happened and let the program continue, or alert the user and close and cleanup the program.

PHASE:Testing:
Subject the software to extensive testing to discover some of the possible instances of where/how errors or return values are not handled. Consider testing techniques such as ad hoc, equivalence partitioning, robustness and fault tolerance, mutation, and fuzzing.

',1);
INSERT INTO "kb_items" VALUES (391,'Unchecked Error Condition','Description:

[PLANNED FOR DEPRECATION. SEE MAINTENANCE NOTES.] Ignoring exceptions and other error conditions may allow an attacker to induce unexpected behavior unnoticed.



Mitigation:


PHASE:Requirements:
The choice between a language which has named or unnamed exceptions needs to be done. While unnamed exceptions exacerbate the chance of not properly dealing with an exception, named exceptions suffer from the up call version of the weak base class problem.

PHASE:Requirements:
A language can be used which requires, at compile time, to catch all serious exceptions. However, one must make sure to use the most current version of the API as new exceptions could be added.

PHASE:Implementation:
Catch all relevant exceptions. This is the recommended solution. Ensure that all exceptions are handled in such a way that you can be sure of the state of your system at any given moment.

',1);
INSERT INTO "kb_items" VALUES (392,'Missing Report of Error Condition','Description:

The software encounters an error but does not provide a status code or return value to indicate that an error has occurred.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (393,'Return of Wrong Status Code','Description:

A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.

This can lead to unpredictable behavior. If the function is used to make securitycritical decisions or provide securitycritical information, then the wrong status code can cause the software to assume that an action is safe, even when it is not.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (394,'Unexpected Status Code or Return Value','Description:

The software does not properly check when a function or operation returns a value that is legitimate for the function, but is not expected by the software.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (395,'Use of NullPointerException Catch to Detect NULL Pointer Dereference','Description:

Catching NullPointerException should not be used as an alternative to programmatic checks to prevent dereferencing a null pointer.

Programmers typically catch NullPointerException under three circumstances: The program contains a null pointer dereference. Catching the resulting exception was easier than fixing the underlying problem. The program explicitly throws a NullPointerException to signal an error condition. The code is part of a test harness that supplies unexpected input to the classes under test. Of these three circumstances, only the last is acceptable.

Mitigation:


PHASE:Architecture and Design Implementation:
Do not extensively rely on catching exceptions (especially for validating user input) to handle errors. Handling exceptions can decrease the performance of an application.

',1);
INSERT INTO "kb_items" VALUES (396,'Declaration of Catch for Generic Exception','Description:

Catching overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.

Multiple catch blocks can get ugly and repetitive, but condensing catch blocks by catching a highlevel class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java''''s typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (397,'Declaration of Throws for Generic Exception','Description:

Throwing overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.

Declaring a method to throw Exception or Throwable makes it difficult for callers to perform proper error handling and error recovery. Java''''s exception mechanism, for example, is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (400,'Uncontrolled Resource Consumption','Description:

The software does not properly control the allocation and maintenance of a limited resource thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.

Limited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the software, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system. There are at least three distinct scenarios which can commonly lead to resource exhaustion: Lack of throttling for the number of allocated resources Losing all references to a resource before reaching the shutdown stage Not closing/returning resource after processing Resource exhaustion problems are often result due to an incorrect implementation of the following situations: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for releasing the resource.

Mitigation:


PHASE:Architecture and Design:
Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.

PHASE:Architecture and Design:
Mitigation of resource exhaustion attacks requires that the target system either: recognizes the attack and denies that user further access for a given amount of time, or uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question. The second solution is simply difficult to effectively institute  and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.

PHASE:Architecture and Design:
Ensure that protocols have specific limits of scale placed on them.

PHASE:Implementation:
Ensure that all failures in resource allocation place the system into a safe posture.

',1);
INSERT INTO "kb_items" VALUES (401,'Missing Release of Memory after Effective Lifetime','Description:

The software does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.

This is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.

Mitigation:


PHASE:Implementation:STRATEGY:Libraries or Frameworks:
Choose a language or tool that provides automatic memory management, or makes manual memory management less errorprone. For example, glibc in Linux provides protection against free of invalid pointers. When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF391]. To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std

auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std

shared_ptr and std

unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.

PHASE:Architecture and Design:
Use an abstraction library to abstract away risky APIs. Not a complete solution.

PHASE:Architecture and Design Build and Compilation:
The BoehmDemersWeiser Garbage Collector or valgrind can be used to detect leaks in code.

',1);
INSERT INTO "kb_items" VALUES (402,'Transmission of Private Resources into a New Sphere Resource Leak','Description:

The software makes resources available to untrusted parties when those resources are only intended to be accessed by the software.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (403,'Exposure of File Descriptor to Unintended Control Sphere File Descriptor Leak','Description:

A process does not close sensitive file descriptors before invoking a child process, which allows the child to perform unauthorized I/O operations using those descriptors.

When a new process is forked or executed, the child process inherits any open file descriptors. When the child process has fewer privileges than the parent process, this might introduce a vulnerability if the child process can access the file descriptor but does not have the privileges to access the associated file.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (404,'Improper Resource Shutdown or Release','Description:

The program does not release or incorrectly releases a resource before it is made available for reuse.

When a resource is created or allocated, the developer is responsible for properly releasing the resource as well as accounting for all potential paths of expiration or invalidation, such as a set period of time or revocation.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, languages such as Java, Ruby, and Lisp perform automatic garbage collection that releases memory for objects that have been deallocated.

PHASE:Implementation:
It is good practice to be responsible for freeing all resources you allocate and to be consistent with how and where you free memory in a function. If you allocate memory that you intend to free upon completion of the function, you must be sure to free the memory at all exit points for that function including error conditions.

PHASE:Implementation:
Memory should be allocated/freed using matching functions such as malloc/free, new/delete, and new[]/delete[].

PHASE:Implementation:
When releasing a complex object or structure, ensure that you properly dispose of all of its member components, not just the object itself.

',1);
INSERT INTO "kb_items" VALUES (405,'Asymmetric Resource Consumption Amplification','Description:

Software that does not appropriately monitor or control resource consumption can lead to adverse system performance.

This situation is amplified if the software allows malicious users or attackers to consume more resources than their access level permits. Exploiting such a weakness can lead to asymmetric resource consumption, aiding in amplification attacks against the system or the network.

Mitigation:


PHASE:Architecture and Design:
An application must make resources available to a client commensurate with the client''''s access level.

PHASE:Architecture and Design:
An application must, at all times, keep track of allocated resources and meter their usage appropriately.

',1);
INSERT INTO "kb_items" VALUES (406,'Insufficient Control of Network Message Volume Network Amplification','Description:

The software does not sufficiently monitor or control transmitted network traffic volume, so that an actor can cause the software to transmit more traffic than should be allowed for that actor.

In the absence of a policy to restrict asymmetric resource consumption, the application or system cannot distinguish between legitimate transmissions and traffic intended to serve as an amplifying attack on target systems. Systems can often be configured to restrict the amount of traffic sent out on behalf of a client, based on the client''''s origin or access level. This is usually defined in a resource allocation policy. In the absence of a mechanism to keep track of transmissions, the system or application can be easily abused to transmit asymmetrically greater traffic than the request or client should be permitted to.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
An application must make network resources available to a client commensurate with the client''''s access level.

PHASE:Policy:
Define a clear policy for network resource allocation and consumption.

PHASE:Implementation:
An application must, at all times, keep track of network resources and meter their usage appropriately.

',1);
INSERT INTO "kb_items" VALUES (407,'Inefficient Algorithmic Complexity','Description:

An algorithm in a product has an inefficient worstcase computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (408,'Incorrect Behavior Order: Early Amplification','Description:

The software allows an entity to perform a legitimate but expensive operation before authentication or authorization has taken place.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (409,'Improper Handling of Highly Compressed Data Data Amplification','Description:

The software does not handle or incorrectly handles a compressed input with a very high compression ratio that produces a large output.

An example of data amplification is a decompression bomb, a small ZIP file that can produce a large amount of data when it is decompressed.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (410,'Insufficient Resource Pool','Description:

The software''''s resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.

Frequently the consequence is a flood of connection or sessions.

Mitigation:


PHASE:Architecture and Design:
Do not perform resourceintensive transactions for unauthenticated users and/or invalid requests.

PHASE:Architecture and Design:
Consider implementing a velocity check mechanism which would detect abusive behavior.

PHASE:Operation:
Consider load balancing as an option to handle heavy loads.

PHASE:Implementation:
Make sure that resource handles are properly closed when no longer needed.

PHASE:Architecture and Design:
Identify the system''''s resource intensive operations and consider protecting them from abuse (e.g. malicious automated script which runs the resources out).

',1);
INSERT INTO "kb_items" VALUES (412,'Unrestricted Externally Accessible Lock','Description:

The software properly checks for the existence of a lock, but the lock can be externally controlled or influenced by an actor that is outside of the intended sphere of control.

This prevents the software from acting on associated resources or performing other behaviors that are controlled by the presence of the lock. Relevant locks might include an exclusive lock or mutex, or modifying a shared resource that is treated as a lock. If the lock can be held for an indefinite period of time, then the denial of service could be permanent.

Mitigation:


PHASE:Architecture and Design Implementation:
Use any access control that is offered by the functionality that is offering the lock.

PHASE:Architecture and Design Implementation:
Use unpredictable names or identifiers for the locks. This might not always be possible or feasible.

PHASE:Architecture and Design:
Consider modifying your code to use nonblocking synchronization methods.

',1);
INSERT INTO "kb_items" VALUES (413,'Improper Resource Locking','Description:

The software does not lock or does not correctly lock a resource when the software must have exclusive access to the resource.

When a resource is not properly locked, an attacker could modify the resource while it is being operated on by the software. This might violate the software''''s assumption that the resource will not change, potentially leading to unexpected behaviors.

Mitigation:


PHASE:Architecture and Design:
Use a nonconflicting privilege scheme.

PHASE:Architecture and Design Implementation:
Use synchronization when locking a resource.

',1);
INSERT INTO "kb_items" VALUES (414,'Missing Lock Check','Description:

A product does not check to see if a lock is present before performing sensitive operations on a resource.



Mitigation:


PHASE:Architecture and Design Implementation:
Implement a reliable lock mechanism.

',1);
INSERT INTO "kb_items" VALUES (415,'Double Free','Description:

The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.

When a program calls free() twice with the same argument, the program''''s memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doublyallocated memory, the program becomes vulnerable to a buffer overflow attack.

Mitigation:


PHASE:Architecture and Design:
Choose a language that provides automatic memory management.

PHASE:Implementation:
Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that cleanup routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.

PHASE:Implementation:
Use a static analysis tool to find double free instances.

',1);
INSERT INTO "kb_items" VALUES (416,'Use After Free','Description:

Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.

The use of previouslyfreed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system''''s reuse of the freed memory. Useafterfree errors have two common and sometimes overlapping causes: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for freeing the memory. In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process. If the newly allocated data chances to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.

Mitigation:


PHASE:Architecture and Design:
Choose a language that provides automatic memory management.

PHASE:Implementation:
When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.

',1);
INSERT INTO "kb_items" VALUES (419,'Unprotected Primary Channel','Description:

The software uses a primary channel for administration or restricted functionality, but it does not properly protect the channel.



Mitigation:


PHASE:Architecture and Design:
Do not expose administrative functionnality on the user UI.

PHASE:Architecture and Design:
Protect the administrative/restricted functionality with a strong authentication mechanism.

',1);
INSERT INTO "kb_items" VALUES (420,'Unprotected Alternate Channel','Description:

The software protects a primary channel, but it does not use the same level of protection for an alternate channel.



Mitigation:


PHASE:Architecture and Design:
Identify all alternate channels and use the same protection mechanisms that are used for the primary channels.

',1);
INSERT INTO "kb_items" VALUES (421,'Race Condition During Access to Alternate Channel','Description:

The product opens an alternate channel to communicate with an authorized user, but the channel is accessible to other actors.

This creates a race condition that allows an attacker to access the channel before the authorized user does.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (422,'Unprotected Windows Messaging Channel Shatter','Description:

The software does not properly verify the source of a message in the Windows Messaging System while running at elevated privileges, creating an alternate channel through which an attacker can directly send a message to the product.



Mitigation:


PHASE:Architecture and Design:
Always verify and authenticate the source of the message.

',1);
INSERT INTO "kb_items" VALUES (424,'Improper Protection of Alternate Path','Description:

The product does not sufficiently protect all possible paths that a user can take to access restricted functionality or resources.



Mitigation:


PHASE:Architecture and Design:
Deploy different layers of protection to implement security in depth.

',1);
INSERT INTO "kb_items" VALUES (425,'Direct Request Forced Browsing','Description:

The web application does not adequately enforce appropriate authorization on all restricted URLs, scripts, or files.

Web applications susceptible to direct request attacks often make the false assumption that such resources can only be reached through a given navigation path and so only apply authorization at certain points in the path.

Mitigation:


PHASE:Architecture and Design Operation:
Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

PHASE:Architecture and Design:
Consider using MVC based frameworks such as Struts.

',1);
INSERT INTO "kb_items" VALUES (426,'Untrusted Search Path','Description:

The application searches for critical resources using an externallysupplied search path that can point to resources that are not under the application''''s direct control.

This might allow attackers to execute their own programs, access unauthorized data files, or modify configuration in unexpected ways. If the application uses a search path to locate critical resources such as programs, then an attacker could modify that search path to point to a malicious program, which the targeted application would then execute. The problem extends to any type of critical resource that the application trusts. Some of the most common variants of untrusted search path are: In various UNIX and Linuxbased systems, the PATH environment variable may be consulted to locate executable programs, and LD_PRELOAD may be used to locate a separate library. In various Microsoftbased systems, the PATH environment variable is consulted to locate a DLL, if the DLL is not found in other paths that appear earlier in the search order.

Mitigation:


PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Hardcode the search path to a set of knownsafe values (such as system directories), or only allow them to be specified by the administrator in a configuration file. Do not allow these settings to be modified by an external party. Be careful to avoid related weaknesses such as CWE426 and CWE428.

PHASE:Implementation:
When invoking other programs, specify those programs using fullyqualified pathnames. While this is an effective approach, code that uses fullyqualified pathnames might not be portable to other systems that do not use the same pathnames. The portability can be improved by locating the fullqualified paths in a centralized, easilymodifiable location within the source code, and having the code refer to these paths.

PHASE:Implementation:
Remove or restrict all environment settings before invoking other programs. This includes the PATH environment variable, LD_LIBRARY_PATH, and other settings that identify the location of code libraries, and any applicationspecific search paths.

PHASE:Implementation:
Check your search path before use and remove any elements that are likely to be unsafe, such as the current working directory or a temporary files directory.

PHASE:Implementation:
Use other functions that require explicit paths. Making use of any of the other readily available functions that require explicit paths is a safe way to avoid this problem. For example, system() in C does not require a full path since the shell can take care of it, while execl() and execv() require a full path.

',1);
INSERT INTO "kb_items" VALUES (427,'Uncontrolled Search Path Element','Description:

The product uses a fixed or controlled search path to find resources, but one or more locations in that path can be under the control of unintended actors.

Although this weakness can occur with any type of resource, it is frequently introduced when a product uses a directory search path to find executables or code libraries, but the path contains a directory that can be modified by an attacker, such as /tmp or the current working directory. In Windowsbased systems, when the LoadLibrary or LoadLibraryEx function is called with a DLL name that does not contain a fully qualified path, the function follows a search order that includes two path elements that might be uncontrolled: the directory from which the program has been loaded the current working directory. In some cases, the attack can be conducted remotely, such as when SMB or WebDAV network shares are used. In some Unixbased systems, a PATH might be created that contains an empty element, e.g. by splicing an empty variable into the PATH. This empty element can be interpreted as equivalent to the current working directory, which might be an untrusted search element.

Mitigation:


PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Hardcode the search path to a set of knownsafe values (such as system directories), or only allow them to be specified by the administrator in a configuration file. Do not allow these settings to be modified by an external party. Be careful to avoid related weaknesses such as CWE426 and CWE428.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
When invoking other programs, specify those programs using fullyqualified pathnames. While this is an effective approach, code that uses fullyqualified pathnames might not be portable to other systems that do not use the same pathnames. The portability can be improved by locating the fullqualified paths in a centralized, easilymodifiable location within the source code, and having the code refer to these paths.

PHASE:Implementation:STRATEGY:Attack Surface Reduction:
Remove or restrict all environment settings before invoking other programs. This includes the PATH environment variable, LD_LIBRARY_PATH, and other settings that identify the location of code libraries, and any applicationspecific search paths.

PHASE:Implementation:
Check your search path before use and remove any elements that are likely to be unsafe, such as the current working directory or a temporary files directory. Since this is a blacklist approach, it might not be a complete solution.

PHASE:Implementation:
Use other functions that require explicit paths. Making use of any of the other readily available functions that require explicit paths is a safe way to avoid this problem. For example, system() in C does not require a full path since the shell can take care of finding the program using the PATH environment variable, while execl() and execv() require a full path.

',1);
INSERT INTO "kb_items" VALUES (428,'Unquoted Search Path or Element','Description:

The product uses a search path that contains an unquoted element, in which the element contains whitespace or other separators. This can cause the product to access resources in a parent path.

If a malicious individual has access to the file system, it is possible to elevate privileges by inserting such a file as C:Program.exe to be run by a privileged program making use of WinExec.

Mitigation:


PHASE:Implementation:
Properly quote the full search path before executing a program on the system.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (430,'Deployment of Wrong Handler','Description:

The wrong handler is assigned to process an object.

An example of deploying the wrong handler would be calling a servlet to reveal source code of a .JSP file, or automatically determining type of the object even if it is contradictory to an explicitly specified type.

Mitigation:


PHASE:Architecture and Design:
Perform a type check before interpreting an object.

PHASE:Architecture and Design:
Reject any inconsistent types, such as a file with a .GIF extension that appears to consist of PHP code.

',1);
INSERT INTO "kb_items" VALUES (431,'Missing Handler','Description:

A handler is not available or implemented.

When an exception is thrown and not caught, the process has given up an opportunity to decide if a given failure or event is worth a change in execution.

Mitigation:


PHASE:Implementation:
Handle all possible situations (e.g. error condition).

PHASE:Implementation:
If an operation can throw an Exception, implement a handler for that specific exception.

',1);
INSERT INTO "kb_items" VALUES (432,'Dangerous Signal Handler not Disabled During Sensitive Operations','Description:

The application uses a signal handler that shares state with other signal handlers, but it does not properly mask or prevent those signal handlers from being invoked while the original signal handler is still running.

During the execution of a signal handler, it can be interrupted by another handler when a different signal is sent. If the two handlers share state  such as global variables  then an attacker can corrupt the state by sending another signal before the first handler has completed execution.

Mitigation:


PHASE:Implementation:
Turn off dangerous handlers when performing sensitive operations.

',1);
INSERT INTO "kb_items" VALUES (433,'Unparsed Raw Web Content Delivery','Description:

The software stores raw content or supporting code under the web document root with an extension that is not specifically handled by the server.

If code is stored in a file with an extension such as .inc or .pl, and the web server does not have a handler for that extension, then the server will likely send the contents of the file directly to the requester without the preprocessing that was expected. When that file contains sensitive information such as database credentials, this may allow the attacker to compromise the application or associated components.

Mitigation:


PHASE:Architecture and Design:
Perform a type check before interpreting files.

PHASE:Architecture and Design:
Do not store sensitive information in files which may be misinterpreted.

',1);
INSERT INTO "kb_items" VALUES (434,'Unrestricted Upload of File with Dangerous Type','Description:

The software allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product''''s environment.



Mitigation:


PHASE:Architecture and Design:
Generate a new, unique filename for an uploaded file instead of using the usersupplied filename, so that no external input is used at all.[REF422] [REF423]

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

PHASE:Architecture and Design:
Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF423]

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.

PHASE:Architecture and Design:
Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE79) before allowing .html or .htm file types.

PHASE:Implementation:STRATEGY:Input Validation:
Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that filename.php.gif is fed to the PHP interpreter.[REF422] [REF423]

PHASE:Implementation:
When running on a web server that supports caseinsensitive filenames, perform caseinsensitive evaluations of the extensions that are provided.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Implementation:
Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a freeform comments field.

PHASE:Implementation:
Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (435,'Improper Interaction Between Multiple Correctly Behaving Entities','Description:

An interaction error occurs when two entities have correct behavior when running independently of each other, but when they are integrated as components in a larger system or process, they introduce incorrect behaviors that may cause resultant weaknesses.

When a system or process combines multiple independent components, this often produces new, emergent behaviors at the system level. However, if the interactions between these components are not fully accounted for, some of the emergent behaviors can be incorrect or even insecure.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (436,'Interpretation Conflict','Description:

Product A handles inputs or steps differently than Product B, which causes A to perform incorrect actions based on its perception of B''''s state.

This is generally found in proxies, firewalls, antivirus software, and other intermediary devices that monitor, allow, deny, or modify traffic based on how the client or server is expected to behave.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (437,'Incomplete Model of Endpoint Features','Description:

A product acts as an intermediary or monitor between two or more endpoints, but it does not have a complete model of an endpoint''''s features, behaviors, or state, potentially causing the product to perform incorrect actions based on this incomplete model.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (439,'Behavioral Change in New Version or Environment','Description:

A''''s behavior or functionality changes with a new version of A, or a new environment, which is not known (or manageable) by B.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (440,'Expected Behavior Violation','Description:

A feature, API, or function being used by a product behaves differently than the product expects.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (441,'Unintended Proxy or Intermediary Confused Deputy','Description:

The software receives a request, message, or directive from an upstream component, but the software does not sufficiently preserve the original source of the request before forwarding the request to an external actor that is outside of the software''''s control sphere. This causes the software to appear to be the source of the request, leading it to act as a proxy or other intermediary between the upstream component and the external actor.

If an attacker cannot directly contact a target, but the software has access to the target, then the attacker can send a request to the software and have it be forwarded from the target. The request would appear to be coming from the software''''s system, not the attacker''''s system. As a result, the attacker can bypass access controls (such as firewalls) or hide the source of malicious requests, since the requests would not be coming directly from the attacker. Since proxy functionality and messageforwarding often serve a legitimate purpose, this issue only becomes a vulnerability when: The software runs with different privileges or on a different system, or otherwise has different levels of access than the upstream component; The attacker is prevented from making the request directly to the target; and The attacker can create a request that the proxy does not explicitly intend to be forwarded on the behalf of the requester. Such a request might point to an unexpected hostname, port number, or service. Or, the request might be sent to an allowed service, but the request could contain disallowed directives, commands, or resources.

Mitigation:


PHASE:Architecture and Design:
Enforce the use of strong mutual authentication mechanism between the two parties.

',1);
INSERT INTO "kb_items" VALUES (444,'Inconsistent Interpretation of HTTP Requests HTTP Request Smuggling','Description:

When malformed or abnormal HTTP requests are interpreted by one or more entities in the data flow between the user and the web server, such as a proxy or firewall, they can be interpreted inconsistently, allowing the attacker to smuggle a request to one device without the other device being aware of it.



Mitigation:


PHASE:Implementation:
Use a web server that employs a strict HTTP parsing procedure, such as Apache [REF433].

PHASE:Implementation:
Use only SSL communication.

PHASE:Implementation:
Terminate the client session after each request.

PHASE:System Configuration:
Turn all pages to noncacheable.

',1);
INSERT INTO "kb_items" VALUES (446,'UI Discrepancy for Security Feature','Description:

The user interface does not correctly enable or configure a security feature, but the interface provides feedback that causes the user to believe that the feature is in a secure state.

When the user interface does not properly reflect what the user asks of it, then it can lead the user into a false sense of security. For example, the user might check a box to enable a security option to enable encrypted communications, but the software does not actually enable the encryption. Alternately, the user might provide a restrict ALL'''' access control rule, but the software only implements restrict SOME.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (447,'Unimplemented or Unsupported Feature in UI','Description:

A UI function for a security feature appears to be supported and gives feedback to the user that suggests that it is supported, but the underlying functionality is not implemented.



Mitigation:


PHASE:Testing:
Perform functionality testing before deploying the application.

',1);
INSERT INTO "kb_items" VALUES (448,'Obsolete Feature in UI','Description:

A UI function is obsolete and the product does not warn the user.



Mitigation:


PHASE:Architecture and Design:
Remove the obsolete feature from the UI. Warn the user that the feature is no longer supported.

',1);
INSERT INTO "kb_items" VALUES (449,'The UI Performs the Wrong Action','Description:

The UI performs the wrong action with respect to the user''''s request.



Mitigation:


PHASE:Testing:
Perform extensive functionality testing of the UI. The UI should behave as specified.

',1);
INSERT INTO "kb_items" VALUES (450,'Multiple Interpretations of UI Input','Description:

The UI has multiple interpretations of user input but does not prompt the user when it selects the less secure interpretation.



Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (451,'User Interface UI Misrepresentation of Critical Information','Description:

The user interface (UI) does not properly represent critical information to the user, allowing the information  or its source  to be obscured or spoofed. This is often a component in phishing attacks.

If an attacker can cause the UI to display erroneous data, or to otherwise convince the user to display information that appears to come from a trusted source, then the attacker could trick the user into performing the wrong action. This is often a component in phishing attacks, but other kinds of problems exist. For example, if the UI is used to monitor the security state of a system or network, then omitting or obscuring an important indicator could prevent the user from detecting and reacting to a securitycritical event. UI misrepresentation can take many forms: Incorrect indicator: incorrect information is displayed, which prevents the user from understanding the true state of the software or the environment the software is monitoring, especially of potentiallydangerous conditions or operations. This can be broken down into several different subtypes. Overlay: an area of the display is intended to give critical information, but another process can modify the display by overlaying another element on top of it. The user is not interacting with the expected portion of the user interface. This is the problem that enables clickjacking attacks, although many other types of attacks exist that involve overlay. Icon manipulation: the wrong icon, or the wrong color indicator, can be influenced (such as making a dangerous .EXE executable look like a harmless .GIF) Timing: the software is performing a state transition or context switch that is presented to the user with an indicator, but a race condition can cause the wrong indicator to be used before the product has fully switched context. The race window could be extended indefinitely if the attacker can trigger an error. Visual truncation: important information could be truncated from the display, such as a long filename with a dangerous extension that is not displayed in the GUI because the malicious portion is truncated. The use of excessive whitespace can also cause truncation, or place the potentiallydangerous indicator outside of the user''''s field of view (e.g. filename.txt .exe). A different type of truncation can occur when a portion of the information is removed due to reasons other than length, such as the accidental insertion of an endofinput marker in the middle of an input, such as a NUL byte in a Cstyle string. Visual distinction: visual information might be presented in a way that makes it difficult for the user to quickly and correctly distinguish between critical and unimportant segments of the display. Homographs: letters from different character sets, fonts, or languages can appear very similar (i.e. may be visually equivalent) in a way that causes the human user to misread the text (for example, to conduct phishing attacks to trick a user into visiting a malicious web site with a visuallysimilar name as a trusted site). This can be regarded as a type of visual distinction issue.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Perform data validation (e.g. syntax, length, etc.) before interpreting the data.

PHASE:Architecture and Design:STRATEGY:Output Encoding:
Create a strategy for presenting information, and plan for how to display unusual characters.

',1);
INSERT INTO "kb_items" VALUES (453,'Insecure Default Variable Initialization','Description:

The software, by default, initializes an internal variable with an insecure or less secure value than is possible.



Mitigation:


PHASE:System Configuration:
Disable or change default settings when they can be used to abuse the system. Since those default settings are shipped with the product they are likely to be known by a potential attacker who is familiar with the product. For instance, default credentials should be changed or the associated accounts should be disabled.

',1);
INSERT INTO "kb_items" VALUES (454,'External Initialization of Trusted Variables or Data Stores','Description:

The software initializes critical internal variables or data stores using inputs that can be modified by untrusted actors.

A software system should be reluctant to trust variables that have been initialized outside of its trust boundary, especially if they are initialized by users. The variables may have been initialized incorrectly. If an attacker can initialize the variable, then they can influence what the vulnerable system will do.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
A software system should be reluctant to trust variables that have been initialized outside of its trust boundary. Ensure adequate checking (e.g. input validation) is performed when relying on input from outside a trust boundary.

PHASE:Architecture and Design:
Avoid any external control of variables. If necessary, restrict the variables that can be modified using a whitelist, and use a different namespace or naming convention if possible.

',1);
INSERT INTO "kb_items" VALUES (455,'Non exit on Failed Initialization','Description:

The software does not exit or otherwise modify its operation when securityrelevant errors occur during initialization, such as when a configuration file has a format error, which can cause the software to execute in a less secure fashion than intended by the administrator.



Mitigation:


PHASE:Implementation:
Follow the principle of failing securely when an error occurs. The system should enter a state where it is not vulnerable and will not display sensitive error messages to a potential attacker.

',1);
INSERT INTO "kb_items" VALUES (456,'Missing Initialization of a Variable','Description:

The software does not initialize critical variables, which causes the execution environment to use unexpected values.



Mitigation:


PHASE:Implementation:
Check that critical variables are initialized.

PHASE:Testing:
Use a static analysis tool to spot noninitialized variables.

',1);
INSERT INTO "kb_items" VALUES (457,'Use of Uninitialized Variable','Description:

The code uses a variable that has not been initialized, leading to unpredictable or unintended results.

In some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code.

Mitigation:


PHASE:Implementation:STRATEGY:Attack Surface Reduction:
Assign all variables to an initial value.

PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Most compilers will complain about the use of uninitialized variables if warnings are turned on.

PHASE:Implementation Operation:
When using a language that does not require explicit declaration of variables, run or compile the software in a mode that reports undeclared or unknown variables. This may indicate the presence of a typographic error in the variable''''s name.

PHASE:Requirements:
The choice could be made to use a language that is not susceptible to these issues.

PHASE:Architecture and Design:
Mitigating technologies such as safe string libraries and container abstractions could be introduced.

',1);
INSERT INTO "kb_items" VALUES (459,'Incomplete Cleanup','Description:

The software does not properly clean up and remove temporary or supporting resources after they have been used.



Mitigation:


PHASE:Architecture and Design Implementation:
Temporary files and other supporting resources should be deleted/released immediately after they are no longer needed.

',1);
INSERT INTO "kb_items" VALUES (460,'Improper Cleanup on Thrown Exception','Description:

The product does not clean up its state or incorrectly cleans up its state when an exception is thrown, leading to unexpected state or control flow.

Often, when functions or loops become complicated, some level of resource cleanup is needed throughout execution. Exceptions can disturb the flow of the code and prevent the necessary cleanup from happening.

Mitigation:


PHASE:Implementation:
If one breaks from a loop or function by throwing an exception, make sure that cleanup happens or that you should exit the program. Use throwing exceptions sparsely.

',1);
INSERT INTO "kb_items" VALUES (462,'Duplicate Key in Associative List Alist','Description:

Duplicate keys in associative lists can lead to nonunique keys being mistaken for an error.

A duplicate key entry  if the alist is designed properly  could be used as a constant time replace function. However, duplicate key entries could be inserted by mistake. Because of this ambiguity, duplicate key entries in an association list are not recommended and should not be allowed.

Mitigation:


PHASE:Architecture and Design:
Use a hash table instead of an alist.

PHASE:Architecture and Design:
Use an alist which checks the uniqueness of hash keys with each entry before inserting the entry.

',1);
INSERT INTO "kb_items" VALUES (463,'Deletion of Data Structure Sentinel','Description:

The accidental deletion of a datastructure sentinel can cause serious programming logic problems.

Often times datastructure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety.

Mitigation:


PHASE:Architecture and Design:
Use an abstraction library to abstract away risky APIs. Not a complete solution.

PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth

PHASE:Operation:
Use OSlevel preventative functionality. Not a complete solution.

',1);
INSERT INTO "kb_items" VALUES (464,'Addition of Data Structure Sentinel','Description:

The accidental addition of a datastructure sentinel can cause serious programming logic problems.

Datastructure sentinels are often used to mark the structure of data. A common example of this is the null character at the end of strings or a special sentinel to mark the end of a linked list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the addition or modification of sentinels.

Mitigation:


PHASE:Implementation Architecture and Design:
Encapsulate the user from interacting with data sentinels. Validate user input to verify that sentinels are not present.

PHASE:Implementation:
Proper error checking can reduce the risk of inadvertently introducing sentinel values into data. For example, if a parsing function fails or encounters an error, it might return a value that is the same as the sentinel.

PHASE:Architecture and Design:
Use an abstraction library to abstract away risky APIs. This is not a complete solution.

PHASE:Operation:
Use OSlevel preventative functionality. This is not a complete solution.

',1);
INSERT INTO "kb_items" VALUES (466,'Return of Pointer Value Outside of Expected Range','Description:

A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (467,'Use of sizeof on a Pointer Type','Description:

The code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated.

The use of sizeof() on a pointer can sometimes generate useful information. An obvious case is to find out the wordsize on a platform. More often than not, the appearance of sizeof(pointer) indicates a bug.

Mitigation:


PHASE:Implementation:
Use expressions such as sizeof(*pointer) instead of sizeof(pointer), unless you intend to run sizeof() on a pointer type to gain some platform independence or if you are allocating a variable on the stack.

',1);
INSERT INTO "kb_items" VALUES (468,'Incorrect Pointer Scaling','Description:

In C and C++, one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled.



Mitigation:


PHASE:Architecture and Design:
Use a platform with highlevel memory abstractions.

PHASE:Implementation:
Always use array indexing instead of direct pointer manipulation.

PHASE:Architecture and Design:
Use technologies for preventing buffer overflows.

',1);
INSERT INTO "kb_items" VALUES (469,'Use of Pointer Subtraction to Determine Size','Description:

The application subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.



Mitigation:


PHASE:Implementation:
Save an index variable. This is the recommended solution. Rather than subtract pointers from one another, use an index variable of the same size as the pointers in question. Use this variable to walk from one pointer to the other and calculate the difference. Always sanity check this number.

',1);
INSERT INTO "kb_items" VALUES (470,'Use of Externally Controlled Input to Select Classes or Code Unsafe Reflection','Description:

The application uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.

If the application uses external inputs to determine which class to instantiate or which method to invoke, then an attacker could supply values to select unexpected classes or methods. If this occurs, then the attacker could create control flow paths that were not intended by the developer. These paths could bypass authentication or access control checks, or otherwise cause the application to behave in an unexpected manner. This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the application''''s classpath (CWE427) or add new entries to the application''''s classpath (CWE426). Under either of these conditions, the attacker can use reflection to introduce new, malicious behavior into the application.

Mitigation:


PHASE:Architecture and Design:
Refactor your code to avoid using reflection.

PHASE:Architecture and Design:
Do not use usercontrolled inputs to select and load classes or code.

PHASE:Implementation:
Apply strict input validation by using whitelists or indirect selection to ensure that the user is only selecting allowable classes or code.

',1);
INSERT INTO "kb_items" VALUES (471,'Modification of Assumed Immutable Data MAID','Description:

The software does not properly protect an assumedimmutable element from being modified by an attacker.

This occurs when a particular input is critical enough to the functioning of the application that it should not be modifiable at all, but it is. Certain resources are often assumed to be immutable when they are not, such as hidden form fields in web applications, cookies, and reverse DNS lookups.

Mitigation:


PHASE:Architecture and Design Operation Implementation:
When the data is stored or transmitted through untrusted sources that could modify the data, implement integrity checks to detect unauthorized modification, or store/transmit the data in a trusted location that is free from external influence.

',1);
INSERT INTO "kb_items" VALUES (472,'External Control of Assumed Immutable Web Parameter','Description:

The web application does not sufficiently verify inputs that are assumed to be immutable but are actually externally controllable, such as hidden form fields.

If a web product does not properly protect assumedimmutable values from modification in hidden form fields, parameters, cookies, or URLs, this can lead to modification of critical data. Web applications often mistakenly make the assumption that data passed to the client in hidden fields or cookies is not susceptible to tampering. Improper validation of data that are usercontrollable can lead to the application processing incorrect, and often malicious, input. For example, custom cookies commonly store session data or persistent data across sessions. This kind of session data is normally involved in security related decisions on the server side, such as user authentication and access control. Thus, the cookies might contain sensitive data such as user credentials and privileges. This is a dangerous practice, as it can often lead to improper reliance on the value of the clientprovided cookie by the server side application.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Implementation:STRATEGY:Input Validation:
Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated (CWE180). Make sure that the application does not decode the same input twice (CWE174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (473,'PHP External Variable Modification','Description:

A PHP application does not properly protect against the modification of variables from external sources, such as query parameters or cookies. This can expose the application to numerous weaknesses that would not exist otherwise.



Mitigation:


PHASE:Requirements Implementation:
Carefully identify which variables can be controlled or influenced by an external user, and consider adopting a naming convention to emphasize when externally modifiable variables are being used. An application should be reluctant to trust variables that have been initialized outside of its trust boundary. Ensure adequate checking is performed when relying on input from outside a trust boundary. Do not allow your application to run with register_globals enabled. If you implement a register_globals emulator, be extremely careful of variable extraction, dynamic evaluation, and similar issues, since weaknesses in your emulation could allow external variable modification to take place even without register_globals.

',1);
INSERT INTO "kb_items" VALUES (474,'Use of Function with Inconsistent Implementations','Description:

The code uses a function that has inconsistent implementations across operating systems and versions.

The use of inconsistent implementations can cause changes in behavior when the code is ported or built under a different environment than the programmer expects, which can lead to security problems in some cases. The implementation of many functions varies by platform, and at times, even by different versions of the same platform. Implementation differences can include: Slight differences in the way parameters are interpreted leading to inconsistent results. Some implementations of the function carry significant security risks. The function might not be defined on all platforms. The function might change which return codes it can provide, or change the meaning of its return codes.

Mitigation:


PHASE:Architecture and Design Requirements:
Do not accept inconsistent behavior from the API specifications when the deviant behavior increase the risk level.

',1);
INSERT INTO "kb_items" VALUES (475,'Undefined Behavior for Input to API','Description:

The behavior of this function is undefined unless its control parameter is set to a specific value.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (476,'NULL Pointer Dereference','Description:

A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.

NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.

Mitigation:


PHASE:Implementation:
If all pointers that could have been modified are sanitychecked previous to use, nearly all NULL pointer dereferences can be prevented.

PHASE:Requirements:
The choice could be made to use a language that is not susceptible to these issues.

PHASE:Implementation:
Check the results of all functions that return a value and verify that the value is nonnull before acting upon it.:EFFECTIVENESS:Moderate

PHASE:Architecture and Design:
Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.

PHASE:Implementation:
Explicitly initialize all your variables and other data stores, either during declaration or just before the first usage.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

',1);
INSERT INTO "kb_items" VALUES (477,'Use of Obsolete Function','Description:

The code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained.

As programming languages evolve, functions occasionally become obsolete due to: Advances in the language Improved understanding of how operations should be performed effectively and securely Changes in the conventions that govern certain operations Functions that are removed are usually replaced by newer counterparts that perform the same task in some different and hopefully improved way.

Mitigation:


PHASE:Implementation:
Refer to the documentation for the obsolete function in order to determine why it is deprecated or obsolete and to learn about alternative ways to achieve the same functionality.

PHASE:Requirements:
Consider seriously the security implications of using an obsolete function. Consider using alternate functions.

',1);
INSERT INTO "kb_items" VALUES (478,'Missing Default Case in Switch Statement','Description:

The code does not have a default case in a switch statement, which might lead to complex logical errors and resultant weaknesses.

This flaw represents a common problem in software development, in which not all possible values for a variable are considered or handled by a given process. Because of this, further decisions are made based on poor information, and cascading failure results. This cascading failure may result in any number of security issues, and constitutes a significant failure in the system.

Mitigation:


PHASE:Implementation:
Ensure that there are no unaccounted for cases, when adjusting flow or values based on the value of a given variable. In switch statements, this can be accomplished through the use of the default label.

PHASE:Implementation:
In the case of switch style statements, the very simple act of creating a default case can mitigate this situation, if done correctly. Often however, the default case is used simply to represent an assumed option, as opposed to working as a check for invalid input. This is poor practice and in some cases is as bad as omitting a default case entirely.

',1);
INSERT INTO "kb_items" VALUES (479,'Signal Handler Use of a Non reentrant Function','Description:

The program defines a signal handler that calls a nonreentrant function.

Nonreentrant functions are functions that cannot safely be called, interrupted, and then recalled before the first call has finished without resulting in memory corruption. This can lead to an unexpected system state and unpredictable results with a variety of potential consequences depending on context, including denial of service and code execution. Many functions are not reentrant, but some of them can result in the corruption of memory if they are used in a signal handler. The function call syslog() is an example of this. In order to perform its functionality, it allocates a small amount of memory as scratch space. If syslog() is suspended by a signal call and the signal handler calls syslog(), the memory used by both of these functions enters an undefined, and possibly, exploitable state. Implementations of malloc() and free() manage metadata in global structures in order to track which memory is allocated versus which memory is available, but they are nonreentrant. Simultaneous calls to these functions can cause corruption of the metadata.

Mitigation:


PHASE:Requirements:
Require languages or libraries that provide reentrant functionality, or otherwise make it easier to avoid this weakness.

PHASE:Architecture and Design:
Design signal handlers to only set flags rather than perform complex functionality.

PHASE:Implementation:
Ensure that nonreentrant functions are not found in signal handlers.

PHASE:Implementation:
Use sanity checks to reduce the timing window for exploitation of race conditions. This is only a partial solution, since many attacks might fail, but other attacks still might work within the narrower window, even accidentally.:EFFECTIVENESS:Defense in Depth

',1);
INSERT INTO "kb_items" VALUES (480,'Use of Incorrect Operator','Description:

The programmer accidentally uses the wrong operator, which changes the application logic in securityrelevant ways.

These types of errors are generally the result of a typo.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (481,'Assigning instead of Comparing','Description:

The code uses an operator for assignment when the intention was to perform a comparison.

In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the righthand side of the predicate.

Mitigation:


PHASE:Testing:
Many IDEs and static analysis products will detect this problem.

PHASE:Implementation:
Place constants on the left. If one attempts to assign a constant with a variable, the compiler will of course produce an error.

',1);
INSERT INTO "kb_items" VALUES (482,'Comparing instead of Assigning','Description:

The code uses an operator for comparison when the intention was to perform an assignment.

In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.

Mitigation:


PHASE:Testing:
Many IDEs and static analysis products will detect this problem.

',1);
INSERT INTO "kb_items" VALUES (483,'Incorrect Block Delimitation','Description:

The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.

In some languages, braces (or other delimiters) are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. In some cases, the logic error can have security implications.

Mitigation:


PHASE:Implementation:
Always use explicit block delimitation and use staticanalysis technologies to enforce this practice.

',1);
INSERT INTO "kb_items" VALUES (484,'Omitted Break Statement in Switch','Description:

The program omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition.

This can lead to critical code executing in situations where it should not.

Mitigation:


PHASE:Implementation:
Omitting a break statement so that one may fall through is often indistinguishable from an error, and therefore should be avoided. If you need to use fallthrough capabilities, make sure that you have clearly documented this within the switch statement, and ensure that you have examined all the logical possibilities.

PHASE:Implementation:
The functionality of omitting a break statement could be clarified with an if statement. This method is much safer.

',1);
INSERT INTO "kb_items" VALUES (486,'Comparison of Classes by Name','Description:

The program compares classes by name, which can cause it to use the wrong class when multiple classes can have the same name.

If the decision to trust the methods and data of an object is based on the name of a class, it is possible for malicious users to send objects of the same name as trusted classes and thereby gain the trust afforded to known classes and types.

Mitigation:


PHASE:Implementation:
Use class equivalency to determine type. Rather than use the class name to determine if an object is of a given type, use the getClass() method, and == operator.

',1);
INSERT INTO "kb_items" VALUES (487,'Reliance on Package level Scope','Description:

Java packages are not inherently closed; therefore, relying on them for code security is not a good practice.

The purpose of package scope is to prevent accidental access by other parts of a program. This is an easeofsoftwaredevelopment feature but not a security feature.

Mitigation:


PHASE:Architecture and Design Implementation:
Data should be private static and final whenever possible. This will assure that your code is protected by instantiating early, preventing access and tampering.

',1);
INSERT INTO "kb_items" VALUES (488,'Exposure of Data Element to Wrong Session','Description:

The product does not sufficiently enforce boundaries between the states of different sessions, causing data to be provided to, or used by, the wrong session.

Data can bleed from one session to another through member variables of singleton objects, such as Servlets, and objects from a shared pool. In the case of Servlets, developers sometimes do not understand that, unless a Servlet implements the SingleThreadModel interface, the Servlet is a singleton; there is only one instance of the Servlet, and that single instance is used and reused to handle multiple requests that are processed simultaneously by different threads. A common result is that developers use Servlet member fields in such a way that one user may inadvertently see another user''''s data. In other words, storing user data in Servlet member fields introduces a data access race condition.

Mitigation:


PHASE:Architecture and Design:
Protect the application''''s sessions from information leakage. Make sure that a session''''s data is not used or visible by other sessions.

PHASE:Testing:
Use a static analysis tool to scan the code for information leakage vulnerabilities (e.g. Singleton Member Field).

PHASE:Architecture and Design:
In a multithreading environment, storing user data in Servlet member fields introduces a data access race condition. Do not use member fields to store information in the Servlet.

',1);
INSERT INTO "kb_items" VALUES (489,'Active Debug Code','Description:

The application is deployed to unauthorized actors with debugging code still enabled or active, which can create unintended entry points or expose sensitive information.

A common development practice is to add back door code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the application. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the application.

Mitigation:


PHASE:Build and Compilation Distribution:
Remove debug code before deploying the application.

',1);
INSERT INTO "kb_items" VALUES (491,'Public cloneable Method Without Final Object Hijack','Description:

A class has a cloneable() method that is not declared final, which allows an object to be created without calling the constructor. This can cause the object to be in an unexpected state.



Mitigation:


PHASE:Implementation:
Make the cloneable() method final.

',1);
INSERT INTO "kb_items" VALUES (492,'Use of Inner Class Containing Sensitive Data','Description:

Inner classes are translated into classes that are accessible at package scope and may expose code that the programmer intended to keep private to attackers.

Inner classes quietly introduce several security concerns because of the way they are translated into Java bytecode. In Java source code, it appears that an inner class can be declared to be accessible only by the enclosing class, but Java bytecode has no concept of an inner class, so the compiler must transform an inner class declaration into a peer class with package level access to the original outer class. More insidiously, since an inner class can access private fields in its enclosing class, once an inner class becomes a peer class in bytecode, the compiler converts private fields accessed by the inner class into protected fields.

Mitigation:


PHASE:Implementation:
Using sealed classes protects objectoriented encapsulation paradigms and therefore protects code from being extended in unforeseen ways.

PHASE:Implementation:
Inner Classes do not provide security. Warning: Never reduce the security of the object from an outer class, going to an inner class. If an outer class is final or private, ensure that its inner class is private as well.

',1);
INSERT INTO "kb_items" VALUES (493,'Critical Public Variable Without Final Modifier','Description:

The product has a critical public variable that is not final, which allows the variable to be modified to contain unexpected values.

If a field is nonfinal and public, it can be changed once the value is set by any function that has access to the class which contains the field. This could lead to a vulnerability if other parts of the program make assumptions about the contents of that field.

Mitigation:


PHASE:Implementation:
Declare all public fields as final when possible, especially if it is used to maintain internal state of an Applet or of classes used by an Applet. If a field must be public, then perform all appropriate sanity checks before accessing the field from your code.

',1);
INSERT INTO "kb_items" VALUES (494,'Download of Code Without Integrity Check','Description:

The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.

An attacker can execute malicious code by compromising the host server, performing DNS spoofing, or modifying the code in transit.

Mitigation:


PHASE:Implementation:
Perform proper forward and reverse DNS lookups to detect DNS spoofing.

PHASE:Architecture and Design Operation:
Encrypt the code with a reliable encryption scheme before transmitting. This will only be a partial solution, since it will not detect DNS spoofing and it will not prevent your code from being modified on the hosting site.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Speficially, it may be helpful to use tools or frameworks to perform integrity checking on the transmitted code. When providing the code that is to be downloaded, such as for automatic updates of the software, then use cryptographic signatures for the code and modify the download clients to verify the signatures. Ensure that the implementation does not contain CWE295, CWE320, CWE347, and related weaknesses. Use code signing technologies such as Authenticode. See references [REF454] [REF455] [REF456].

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (495,'Private Data Structure Returned From A Public Method','Description:

The product has a method that is declared public, but returns a reference to a private data structure, which could then be modified in unexpected ways.



Mitigation:


PHASE:Implementation:
Declare the method private.

PHASE:Implementation:
Clone the member data and keep an unmodified version of the data private to the object.

PHASE:Implementation:
Use public setter methods that govern how a private member can be modified.

',1);
INSERT INTO "kb_items" VALUES (496,'Public Data Assigned to Private Array Typed Field','Description:

Assigning public data to a private array is equivalent to giving public access to the array.



Mitigation:


PHASE:Implementation:
Do not allow objects to modify private members of a class.

',1);
INSERT INTO "kb_items" VALUES (497,'Exposure of Sensitive System Information to an Unauthorized Control Sphere','Description:

The application does not properly prevent sensitive systemlevel information from being accessed by unauthorized actors who do not have the same level of access to the underlying system as the application does.

Networkbased software, such as web applications, often runs on top of an operating system or similar environment. When the application communicates with outside parties, details about the underlying system are expected to remain hidden, such as path names for data files, other OS users, installed packages, the application environment, etc. This system information may be provided by the application itself, or buried within diagnostic or debugging messages. Debugging information helps an adversary learn about the system and form an attack plan. An information exposure occurs when system data or debugging information leaves the program through an output stream or logging function that makes it accessible to unauthorized parties. Using other weaknesses, an attacker could cause errors to occur; the response to these errors can reveal detailed system information, along with other impacts. An attacker can use messages that reveal technologies, operating systems, and product versions to tune the attack against known vulnerabilities in these technologies. An application may use diagnostic methods that provide significant implementation details such as stack traces as part of its error handling mechanism.

Mitigation:


PHASE:Architecture and Design Implementation:
Production applications should never use methods that generate internal details such as stack traces and error messages unless that information is directly committed to a log that is not viewable by the end user. All error message text should be HTML entity encoded before being written to the log file to protect against potential crosssite scripting attacks against the viewer of the logs

',1);
INSERT INTO "kb_items" VALUES (498,'Cloneable Class Containing Sensitive Information','Description:

The code contains a class with sensitive data, but the class is cloneable. The data can then be accessed by cloning the class.

Cloneable classes are effectively open classes, since data cannot be hidden in them. Classes that do not explicitly deny cloning can be cloned by any other class without running the constructor.

Mitigation:


PHASE:Implementation:
If you do make your classes clonable, ensure that your clone method is final and throw super.clone().

',1);
INSERT INTO "kb_items" VALUES (499,'Serializable Class Containing Sensitive Data','Description:

The code contains a class with sensitive data, but the class does not explicitly deny serialization. The data can be accessed by serializing the class through another class.

Serializable classes are effectively open classes since data cannot be hidden in them. Classes that do not explicitly deny serialization can be serialized by any other class, which can then in turn use the data stored inside it.

Mitigation:


PHASE:Implementation:
In Java, explicitly define final writeObject() to prevent serialization. This is the recommended solution. Define the writeObject() function to throw an exception explicitly denying serialization.

PHASE:Implementation:
Make sure to prevent serialization of your objects.

',1);
INSERT INTO "kb_items" VALUES (500,'Public Static Field Not Marked Final','Description:

An object contains a public static field that is not marked final, which might allow it to be modified in unexpected ways.

Public static variables can be read without an accessor and changed without a mutator by any classes in the application.

Mitigation:


PHASE:Architecture and Design:
Clearly identify the scope for all critical data elements, including whether they should be regarded as static.

PHASE:Implementation:
Make any static fields private and constant. A constant field is denoted by the keyword ''''const'''' in C/C++ and '''' final'''' in Java

',1);
INSERT INTO "kb_items" VALUES (501,'Trust Boundary Violation','Description:

The product mixes trusted and untrusted data in the same data structure or structured message.

A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary  to move from untrusted to trusted. A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. By combining trusted and untrusted data in the same data structure, it becomes easier for programmers to mistakenly trust unvalidated data.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (502,'Deserialization of Untrusted Data','Description:

The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid.

It is often convenient to serialize objects for communication or to save them for later use. However, deserialized data or code can often be modified without using the provided accessor functions if it does not use cryptography to protect itself. Furthermore, any cryptography would still be clientside security  which is a dangerous security assumption. Data that is untrusted can not be trusted to be wellformed. When developers place no restrictions on gadget chains, or series of instances and method invocations that can selfexecute during the deserialization process (i.e., before the object is returned to the caller), it is sometimes possible for attackers to leverage them to perform unauthorized actions, like generating a shell.

Mitigation:


PHASE:Architecture and Design Implementation:
If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hashbased message authentication code (HMAC) could be used to ensure that data has not been modified.

PHASE:Implementation:
When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.

PHASE:Implementation:
Explicitly define a final object() to prevent deserialization.

PHASE:Architecture and Design Implementation:
Make fields transient to protect them from deserialization. An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environmentbased, or sensitive variables from being carried over and used improperly.

PHASE:Implementation:
Avoid having unnecessary types or gadgets available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Whitelist acceptable classes. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.

',1);
INSERT INTO "kb_items" VALUES (506,'Embedded Malicious Code','Description:

The application contains code that appears to be malicious in nature.

Malicious flaws have acquired colorful names, including Trojan horse, trapdoor, timebomb, and logicbomb. A developer might insert malicious code with the intent to subvert the security of an application or its host system at some time in the future. It generally refers to a program that performs a useful service but exploits rights of the program''''s user in a way the user does not intend.

Mitigation:


PHASE:Testing:
Remove the malicious code and start an effort to ensure that no more malicious code exists. This may require a detailed review of all code, as it is possible to hide a serious attack in only one or two lines of code. These lines may be located almost anywhere in an application and may have been intentionally obfuscated by the attacker.

',1);
INSERT INTO "kb_items" VALUES (507,'Trojan Horse','Description:

The software appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.



Mitigation:


PHASE:Operation:
Most antivirus software scans for Trojan Horses.

PHASE:Installation:
Verify the integrity of the software that is being installed.

',1);
INSERT INTO "kb_items" VALUES (508,'Non Replicating Malicious Code','Description:

Nonreplicating malicious code only resides on the target system or software that is attacked; it does not attempt to spread to other systems.



Mitigation:


PHASE:Operation:
Antivirus software can help mitigate known malicious code.

PHASE:Installation:
Verify the integrity of the software that is being installed.

',1);
INSERT INTO "kb_items" VALUES (509,'Replicating Malicious Code Virus or Worm','Description:

Replicating malicious code, including viruses and worms, will attempt to attack other systems once it has successfully compromised the target system or software.



Mitigation:


PHASE:Operation:
Antivirus software scans for viruses or worms.

PHASE:Installation:
Always verify the integrity of the software that is being installed.

',1);
INSERT INTO "kb_items" VALUES (510,'Trapdoor','Description:

A trapdoor is a hidden piece of code that responds to a special input, allowing its user access to resources without passing through the normal security enforcement mechanism.



Mitigation:


PHASE:Installation:
Always verify the integrity of the software that is being installed.

PHASE:Testing:
Identify and closely inspect the conditions for entering privileged areas of the code, especially those related to authentication, process invocation, and network communications.

',1);
INSERT INTO "kb_items" VALUES (511,'Logic Time Bomb','Description:

The software contains code that is designed to disrupt the legitimate operation of the software (or its environment) when a certain time passes, or when a certain logical condition is met.

When the time bomb or logic bomb is detonated, it may perform a denial of service such as crashing the system, deleting critical data, or degrading system response time. This bomb might be placed within either a replicating or nonreplicating Trojan horse.

Mitigation:


PHASE:Installation:
Always verify the integrity of the software that is being installed.

PHASE:Testing:
Conduct a code coverage analysis using live testing, then closely inspect any code that is not covered.

',1);
INSERT INTO "kb_items" VALUES (512,'Spyware','Description:

The software collects personally identifiable information about a human user or the user''''s activities, but the software accesses this information using other resources besides itself, and it does not require that user''''s explicit approval or direct input into the software.

Spyware is a commonly used term with many definitions and interpretations. In general, it is meant to software that collects information or installs functionality that human users might not allow if they were fully aware of the actions being taken by the software. For example, a user might expect that tax software would collect a social security number and include it when filing a tax return, but that same user would not expect gaming software to obtain the social security number from that tax software''''s data.

Mitigation:


PHASE:Operation:
Use spyware detection and removal software.

PHASE:Installation:
Always verify the integrity of the software that is being installed.

',1);
INSERT INTO "kb_items" VALUES (514,'Covert Channel','Description:

A covert channel is a path that can be used to transfer information in a way not intended by the system''''s designers.

Typically the system has not given authorization for the transmission and has no knowledge of its occurrence.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (515,'Covert Storage Channel','Description:

A covert storage channel transfers information through the setting of bits by one program and the reading of those bits by another. What distinguishes this case from that of ordinary operation is that the bits are used to convey encoded information.

Covert storage channels occur when outofband data is stored in messages for the purpose of memory reuse. Covert channels are frequently classified as either storage or timing channels. Examples would include using a file intended to hold only audit information to convey user passwordsusing the name of a file or perhaps status bits associated with it that can be read by all users to signal the contents of the file. Steganography, concealing information in such a manner that no one but the intended recipient knows of the existence of the message, is a good example of a covert storage channel.

Mitigation:


PHASE:Implementation:
Ensure that all reserved fields are set to zero before messages are sent and that no unnecessary information is included.

',1);
INSERT INTO "kb_items" VALUES (520,'.NET Misconfiguration: Use of Impersonation','Description:

Allowing a .NET application to run at potentially escalated levels of access to the underlying operating and file systems can be dangerous and result in various forms of attacks.

.NET server applications can optionally execute using the identity of the user authenticated to the client. The intention of this functionality is to bypass authentication and access control checks within the .NET application code. Authentication is done by the underlying web server (Microsoft Internet Information Service IIS), which passes the authenticated token, or unauthenticated anonymous token, to the .NET application. Using the token to impersonate the client, the application then relies on the settings within the NTFS directories and files to control access. Impersonation enables the application, on the server running the .NET application, to both execute code and access resources in the context of the authenticated and authorized user.

Mitigation:


PHASE:Operation:
Run the application with limited privilege to the underlying operating and file system.

',1);
INSERT INTO "kb_items" VALUES (521,'Weak Password Requirements','Description:

The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.

Authentication mechanisms often rely on a memorized secret (also known as a password) to provide an assertion of identity for a user of a system. It is therefore important that this password be of sufficient complexity and impractical for an adversary to guess. The specific requirements around how complex a password needs to be depends on the type of system being protected. Selecting the correct password requirements and enforcing them through implementation are critical to the overall success of the authentication mechanism.

Mitigation:


PHASE:Architecture and Design:
A product''''s design should require adherance to an appropriate password policy. Specific password requirements depend strongly on contextual factors, but it is recommended to contain the following attributes: Enforcement of a minimum and maximum length Restrictions against password reuse Restrictions against using common passwords Restrictions against using contextual string in the password (e.g., user id, app name) Depending on the threat model, the password policy may include several additional attributes. Complex passwords requiring mixed character sets (alpha, numeric, special, mixed case) Increasing the range of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication. Unfortunately, a complex password may be difficult to memorize, encouraging a user to select a short password or to incorrectly manage the password (write it down). Another disadvantage of this approach is that it often does not result in a significant increases in overal password complexity due to people''''s predictable usage of various symbols. Large Minimum Length (encouraging passphrases instead of passwords) Increasing the number of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication. A disadvantage of this approach is that selecting a good passphrase is not easy and poor passwords can still be generated. Some prompting may be needed to encourage long unpredictable passwords. Randomly Chosen Secrets Generating a password for the user can help make sure that length and complexity requirements are met, and can result in secure passwords being used. A disadvantage of this approach is that the resulting password or passpharse may be too difficult to memorize, encouraging them to be written down. Password Expiration Requiring a periodic password change can reduce the time window that an adversary has to crack a password, while also limiting the damage caused by password exposures at other locations. Password expiration may be a good mitigating technique when long complex passwords are not desired. See NIST 80063B https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.80063b.pdf Sections: 5.1.1, 10.2.1, and Appendix A for further information on password requirements.

PHASE:Architecture and Design:
Consider a second authentication factor beyond the password, which prevents the password from being a single point of failure. See CWE308 for further information.

PHASE:Implementation:
Consider implementing a password complexity meter to inform users when a chosen password meets the required attributes.

',1);
INSERT INTO "kb_items" VALUES (522,'Insufficiently Protected Credentials','Description:

The product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.



Mitigation:


PHASE:Architecture and Design:
Use an appropriate security mechanism to protect the credentials.

PHASE:Architecture and Design:
Make appropriate use of cryptography to protect the credentials.

PHASE:Implementation:
Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).

',1);
INSERT INTO "kb_items" VALUES (523,'Unprotected Transport of Credentials','Description:

Login pages do not use adequate measures to protect the user name and password while they are in transit from the client to the server.



Mitigation:


PHASE:Operation System Configuration:
Enforce SSL use for the login page or any page used to transmit user credentials or other sensitive information. Even if the entire site does not use SSL, it MUST use SSL for login. Additionally, to help prevent phishing attacks, make sure that SSL serves the login page. SSL allows the user to verify the identity of the server to which they are connecting. If the SSL serves login page, the user can be certain they are talking to the proper end system. A phishing attack would typically redirect a user to a site that does not have a valid trusted server certificate issued from an authorized supplier.

',1);
INSERT INTO "kb_items" VALUES (524,'Use of Cache Containing Sensitive Information','Description:

The code uses a cache that contains sensitive information, but the cache can be read by an actor outside of the intended control sphere.

Applications may use caches to improve efficiency when communicating with remote entities or performing intensive calculations. A cache maintains a pool of objects, threads, connections, pages, ficial data, passwords, or other resources to minimize the time it takes to initialize and access these resources. If the cache is accessible to unauthorized actors, attackers can read the cache and obtain this sensitive information.

Mitigation:


PHASE:Architecture and Design:
Protect information stored in cache.

PHASE:Architecture and Design:
Do not store unnecessarily sensitive information in the cache.

PHASE:Architecture and Design:
Consider using encryption in the cache.

',1);
INSERT INTO "kb_items" VALUES (525,'Use of Web Browser Cache Containing Sensitive Information','Description:

The web application does not use an appropriate caching policy that specifies the extent to which each web page and associated form fields should be cached.



Mitigation:


PHASE:Architecture and Design:
Protect information stored in cache.

PHASE:Architecture and Design Implementation:
Use a restrictive caching policy for forms and web pages that potentially contain sensitive information.

PHASE:Architecture and Design:
Do not store unnecessarily sensitive information in the cache.

PHASE:Architecture and Design:
Consider using encryption in the cache.

',1);
INSERT INTO "kb_items" VALUES (526,'Exposure of Sensitive Information Through Environmental Variables','Description:

Environmental variables may contain sensitive information about a remote server.



Mitigation:


PHASE:Architecture and Design:
Protect information stored in environment variable from being exposed to the user.

',1);
INSERT INTO "kb_items" VALUES (527,'Exposure of Version Control Repository to an Unauthorized Control Sphere','Description:

The product stores a CVS, git, or other repository in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.

Version control repositories such as CVS or git store versionspecific metadata and other details within subdirectories. If these subdirectories are stored on a web server or added to an archive, then these could be used by an attacker. This information may include usernames, filenames, path root, IP addresses, and detailed diff data about how files have been changed  which could reveal source code snippets that were never intended to be made public.

Mitigation:


PHASE:Operation Distribution System Configuration:
Recommendations include removing any CVS directories and repositories from the production server, disabling the use of remote CVS repositories, and ensuring that the latest CVS patches and version updates have been performed.

',1);
INSERT INTO "kb_items" VALUES (528,'Exposure of Core Dump File to an Unauthorized Control Sphere','Description:

The product generates a core dump file in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.



Mitigation:


PHASE:System Configuration:
Protect the core dump files from unauthorized access.

',1);
INSERT INTO "kb_items" VALUES (529,'Exposure of Access Control List Files to an Unauthorized Control Sphere','Description:

The product stores access control list files in a directory or other container that is accessible to actors outside of the intended control sphere.

Exposure of these access control list files may give the attacker information about the configuration of the site or system. This information may then be used to bypass the intended security policy or identify trusted systems from which an attack can be launched.

Mitigation:


PHASE:System Configuration:
Protect access control list files.

',1);
INSERT INTO "kb_items" VALUES (530,'Exposure of Backup File to an Unauthorized Control Sphere','Description:

A backup file is stored in a directory or archive that is made accessible to unauthorized actors.

Often, older backup files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.

Mitigation:


PHASE:Policy:
Recommendations include implementing a security policy within your organization that prohibits backing up web application source code in the webroot.

',1);
INSERT INTO "kb_items" VALUES (531,'Inclusion of Sensitive Information in Test Code','Description:

Accessible test applications can pose a variety of security risks. Since developers or administrators rarely consider that someone besides themselves would even know about the existence of these applications, it is common for them to contain sensitive information or functions.



Mitigation:


PHASE:Distribution Installation:
Remove test code before deploying the application into production.

',1);
INSERT INTO "kb_items" VALUES (532,'Insertion of Sensitive Information into Log File','Description:

Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.

While logging all information may be helpful during development stages, it is important that logging levels be set appropriately before a product ships so that sensitive user data and system information are not accidentally exposed to potential attackers. Different log files may be produced and stored for: Server log files (e.g. server.log). This can give information on whatever application left the file. Usually this can give full path names and system information, and sometimes usernames and passwords. log files that are used for debugging

Mitigation:


PHASE:Architecture and Design Implementation:
Consider seriously the sensitivity of the information written into log files. Do not write secrets into the log files.

PHASE:Distribution:
Remove debug log files before deploying the application into production.

PHASE:Operation:
Protect log files against unauthorized read/write.

PHASE:Implementation:
Adjust configurations appropriately when software is transitioned from a debug state to production.

',1);
INSERT INTO "kb_items" VALUES (535,'Exposure of Information Through Shell Error Message','Description:

A command shell error message indicates that there exists an unhandled exception in the web application code. In many cases, an attacker can leverage the conditions that cause these errors in order to gain unauthorized access to the system.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (536,'Servlet Runtime Error Message Containing Sensitive Information','Description:

A servlet error message indicates that there exists an unhandled exception in your web application code and may provide useful information to an attacker.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (537,'Java Runtime Error Message Containing Sensitive Information','Description:

In many cases, an attacker can leverage the conditions that cause unhandled exception errors in order to gain unauthorized access to the system.



Mitigation:


PHASE:Implementation:
Do not expose sensitive error information to the user.

',1);
INSERT INTO "kb_items" VALUES (538,'Insertion of Sensitive Information into Externally Accessible File or Directory','Description:

The product places sensitive information into files or directories that are accessible to actors who are allowed to have access to the files, but not to the sensitive information.



Mitigation:


PHASE:Architecture and Design Operation System Configuration:
Do not expose file and directory information to the user.

',1);
INSERT INTO "kb_items" VALUES (539,'Use of Persistent Cookies Containing Sensitive Information','Description:

The web application uses persistent cookies, but the cookies contain sensitive information.

Cookies are small bits of data that are sent by the web application but stored locally in the browser. This lets the application use the cookie to pass information between pages and store variable information. The web application controls what information is stored in a cookie and how it is used. Typical types of information stored in cookies are session identifiers, personalization and customization information, and in rare cases even usernames to enable automated logins. There are two different types of cookies: session cookies and persistent cookies. Session cookies just live in the browser''''s memory and are not stored anywhere, but persistent cookies are stored on the browser''''s hard drive. This can cause security and privacy issues depending on the information stored in the cookie and how it is accessed.

Mitigation:


PHASE:Architecture and Design:
Do not store sensitive information in persistent cookies.

',1);
INSERT INTO "kb_items" VALUES (540,'Inclusion of Sensitive Information in Source Code','Description:

Source code on a web server or repository often contains sensitive information and should generally not be accessible to users.

There are situations where it is critical to remove source code from an area or server. For example, obtaining Perl source code on a system allows an attacker to understand the logic of the script and extract extremely useful information such as code bugs or logins and passwords.

Mitigation:


PHASE:Architecture and Design System Configuration:
Recommendations include removing this script from the web server and moving it to a location not accessible from the Internet.

',1);
INSERT INTO "kb_items" VALUES (541,'Inclusion of Sensitive Information in an Include File','Description:

If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.



Mitigation:


PHASE:Architecture and Design:
Do not store sensitive information in include files.

PHASE:Architecture and Design System Configuration:
Protect include files from being exposed.

',1);
INSERT INTO "kb_items" VALUES (543,'Use of Singleton Pattern Without Synchronization in a Multithreaded Context','Description:

The software uses the singleton pattern when creating a resource within a multithreaded environment.

The use of a singleton pattern may not be threadsafe.

Mitigation:


PHASE:Architecture and Design:
Use the ThreadSpecific Storage Pattern. See References.

PHASE:Implementation:
Do not use member fields to store information in the Servlet. In multithreading environments, storing user data in Servlet member fields introduces a data access race condition.

PHASE:Implementation:
Avoid using the doublechecked locking pattern in language versions that cannot guarantee thread safety. This pattern may be used to avoid the overhead of a synchronized call, but in certain versions of Java (for example), this has been shown to be unsafe because it still introduces a race condition (CWE209).:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (544,'Missing Standardized Error Handling Mechanism','Description:

The software does not use a standardized method for handling errors throughout the code, which might introduce inconsistent error handling and resultant weaknesses.

If the application handles error messages individually, on a onebyone basis, this is likely to result in inconsistent error handling. The causes of errors may be lost. Also, detailed information about the causes of an error may be unintentionally returned to the user.

Mitigation:


PHASE:Architecture and Design:
define a strategy for handling errors of different severities, such as fatal errors versus basic log events. Use or create builtin language features, or an external package, that provides an easytouse API and define coding standards for the detection and handling of errors.

',1);
INSERT INTO "kb_items" VALUES (546,'Suspicious Comment','Description:

The code contains comments that suggest the presence of bugs, incomplete functionality, or weaknesses.

Many suspicious comments, such as BUG, HACK, FIXME, LATER, LATER2, TODO, in the code indicate missing security functionality and checking. Others indicate code problems that programmers should fix, such as hardcoded variables, error handling, not using stored procedures, and performance issues.

Mitigation:


PHASE:Documentation:
Remove comments that suggest the presence of bugs, incomplete functionality, or weaknesses, before deploying the application.

',1);
INSERT INTO "kb_items" VALUES (548,'Exposure of Information Through Directory Listing','Description:

A directory listing is inappropriately exposed, yielding potentially sensitive information to attackers.

A directory listing provides an attacker with the complete index of all the resources located inside of the directory. The specific risks and consequences vary depending on which files are listed and accessible.

Mitigation:


PHASE:Architecture and Design System Configuration:
Recommendations include restricting access to important directories or files by adopting a need to know requirement for both the document and server root, and turning off features such as Automatic Directory Listings that could expose private files and provide information that could be utilized by an attacker when formulating or conducting an attack.

',1);
INSERT INTO "kb_items" VALUES (549,'Missing Password Field Masking','Description:

The software does not mask passwords during entry, increasing the potential for attackers to observe and capture passwords.



Mitigation:


PHASE:Implementation Requirements:
Recommendations include requiring all password fields in your web application be masked to prevent other users from seeing this information.

',1);
INSERT INTO "kb_items" VALUES (550,'Server generated Error Message Containing Sensitive Information','Description:

Certain conditions, such as network failure, will cause a server error message to be displayed.

While error messages in and of themselves are not dangerous, per se, it is what an attacker can glean from them that might cause eventual problems.

Mitigation:


PHASE:Architecture and Design System Configuration:
Recommendations include designing and adding consistent error handling mechanisms which are capable of handling any user input to your web application, providing meaningful detail to endusers, and preventing error messages that might provide information useful to an attacker from being displayed.

',1);
INSERT INTO "kb_items" VALUES (551,'Incorrect Behavior Order: Authorization Before Parsing and Canonicalization','Description:

If a web server does not fully parse requested URLs before it examines them for authorization, it may be possible for an attacker to bypass authorization protection.

For instance, the character strings /./ and / both mean current directory. If /SomeDirectory is a protected directory and an attacker requests /./SomeDirectory, the attacker may be able to gain access to the resource if /./ is not converted to / before the authorization check is performed.

Mitigation:


PHASE:Architecture and Design:
URL Inputs should be decoded and canonicalized to the application''''s current internal representation before being validated and processed for authorization. Make sure that your application does not decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked.

',1);
INSERT INTO "kb_items" VALUES (552,'Files or Directories Accessible to External Parties','Description:

The product makes files or directories accessible to unauthorized actors, even though they should not be.

Web servers, FTP servers, and similar servers may store a set of files underneath a root directory that is accessible to the server''''s users. Applications may store sensitive files underneath this root without also using access control to limit which users may request those files, if any. Alternately, an application might package multiple files or directories into an archive file (e.g., ZIP or tar), but the application might not exclude sensitive files that are underneath those directories.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (553,'Command Shell in Externally Accessible Directory','Description:

A possible shell file exists in /cgibin/ or other accessible directories. This is extremely dangerous and can be used by an attacker to execute commands on the web server.



Mitigation:


PHASE:Installation System Configuration:
Remove any Shells accessible under the web root folder and children directories.

',1);
INSERT INTO "kb_items" VALUES (554,'ASP.NET Misconfiguration: Not Using Input Validation Framework','Description:

The ASP.NET application does not use an input validation framework.



Mitigation:


PHASE:Architecture and Design:
Use the ASP.NET validation framework to check all program input before it is processed by the application. Example uses of the validation framework include checking to ensure that: Phone number fields contain only valid characters in phone numbers Boolean values are only T or F Freeform strings are of a reasonable length and composition

',1);
INSERT INTO "kb_items" VALUES (555,'J2EE Misconfiguration: Plaintext Password in Configuration File','Description:

The J2EE application stores a plaintext password in a configuration file.

Storing a plaintext password in a configuration file allows anyone who can read the file to access the passwordprotected resource, making it an easy target for attackers.

Mitigation:


PHASE:Architecture and Design:
Do not hardwire passwords into your software.

PHASE:Architecture and Design:
Use industry standard libraries to encrypt passwords before storage in configuration files.

',1);
INSERT INTO "kb_items" VALUES (556,'ASP.NET Misconfiguration: Use of Identity Impersonation','Description:

Configuring an ASP.NET application to run with impersonated credentials may give the application unnecessary privileges.

The use of impersonated credentials allows an ASP.NET application to run with either the privileges of the client on whose behalf it is executing or with arbitrary privileges granted in its configuration.

Mitigation:


PHASE:Architecture and Design:
Use the least privilege principle.

',1);
INSERT INTO "kb_items" VALUES (558,'Use of getlogin in Multithreaded Application','Description:

The application uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.

The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.

Mitigation:


PHASE:Architecture and Design:
Using names for security purposes is not advised. Names are easy to forge and can have overlapping user IDs, potentially causing confusion or impersonation.

PHASE:Implementation:
Use getlogin_r() instead, which is reentrant, meaning that other processes are locked out from changing the username.

',1);
INSERT INTO "kb_items" VALUES (560,'Use of umask with chmod style Argument','Description:

The product calls umask() with an incorrect argument that is specified as if it is an argument to chmod().



Mitigation:


PHASE:Implementation:
Use umask() with the correct argument.

PHASE:Testing:
If you suspect misuse of umask(), you can use grep to spot call instances of umask().

',1);
INSERT INTO "kb_items" VALUES (561,'Dead Code','Description:

The software contains dead code, which can never be executed.

Dead code is source code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed.

Mitigation:


PHASE:Implementation:
Remove dead code before deploying the application.

PHASE:Testing:
Use a static analysis tool to spot dead code.

',1);
INSERT INTO "kb_items" VALUES (562,'Return of Stack Variable Address','Description:

A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.

Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to reuse this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function''''s stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.

Mitigation:


PHASE:Testing:
Use static analysis tools to spot return of the address of a stack variable.

',1);
INSERT INTO "kb_items" VALUES (563,'Assignment to Variable without Use','Description:

The variable''''s value is assigned but never used, making it a dead store.

After the assignment, the variable is either assigned another value or goes out of scope. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug.

Mitigation:


PHASE:Implementation:
Remove unused variables from the code.

',1);
INSERT INTO "kb_items" VALUES (564,'SQL Injection: Hibernate','Description:

Using Hibernate to execute a dynamic SQL statement built with usercontrolled input can allow an attacker to modify the statement''''s meaning or to execute arbitrary SQL commands.



Mitigation:


PHASE:Requirements:
A nonSQL style database which is not subject to this flaw may be chosen.

PHASE:Architecture and Design:
Follow the principle of least privilege when creating user accounts to a SQL database. Users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others'''' data.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Implementation:
Implement SQL strings using prepared statements that bind variables. Prepared statements that do not bind variables can be vulnerable to attack.

PHASE:Implementation:
Use vigorous whitelist style checking on any user input that may be used in a SQL command. Rather than escape metacharacters, it is safest to disallow them entirely. Reason: Later use of data that have been entered in the database may neglect to escape metacharacters before use. Narrowly define the set of safe characters based on the expected value of the parameter in the request.

',1);
INSERT INTO "kb_items" VALUES (565,'Reliance on Cookies without Validation and Integrity Checking','Description:

The application relies on the existence or values of cookies when performing securitycritical operations, but it does not properly ensure that the setting is valid for the associated user.

Attackers can easily modify cookies, within the browser or by implementing the clientside code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and crosssite scripting, or otherwise modify inputs in unexpected ways.

Mitigation:


PHASE:Architecture and Design:
Avoid using cookie data for a securityrelated decision.

PHASE:Implementation:
Perform thorough input validation (i.e.: server side validation) on the cookie data if you''''re going to use it for a security related decision.

PHASE:Architecture and Design:
Add integrity checks to detect tampering.

PHASE:Architecture and Design:
Protect critical cookies from replay attacks, since crosssite scripting or other attacks may allow attackers to steal a stronglyencrypted cookie that also passes integrity checks. This mitigation applies to cookies that should only be valid during a single transaction or session. By enforcing timeouts, you may limit the scope of an attack. As part of your integrity check, use an unpredictable, serverside value that is not exposed to the client.

',1);
INSERT INTO "kb_items" VALUES (566,'Authorization Bypass Through User Controlled SQL Primary Key','Description:

The software uses a database table that includes records that should not be accessible to an actor, but it executes a SQL statement with a primary key that can be controlled by that actor.

When a user can set a primary key to any value, then the user can modify the key to point to unauthorized records. Database access control errors occur when: Data enters a program from an untrusted source. The data is used to specify the value of a primary key in a SQL query. The untrusted source does not have the permissions to be able to access all rows in the associated table.

Mitigation:


PHASE:Implementation:
Assume all input is malicious. Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data. Use an accept known good validation strategy.

PHASE:Implementation:
Use a parameterized query AND make sure that the accepted values conform to the business rules. Construct your SQL statement accordingly.

',1);
INSERT INTO "kb_items" VALUES (567,'Unsynchronized Access to Shared Data in a Multithreaded Context','Description:

The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes.

Within servlets, shared static variables are not protected from concurrent access, but servlets are multithreaded. This is a typical programming mistake in J2EE applications, since the multithreading is handled by the framework. When a shared variable can be influenced by an attacker, one thread could wind up modifying the variable to contain data that is not valid for a different thread that is also using the data within the variable. Note that this weakness is not unique to servlets.

Mitigation:


PHASE:Implementation:
Remove the use of static variables used between servlets. If this cannot be avoided, use synchronized access for these variables.

',1);
INSERT INTO "kb_items" VALUES (570,'Expression is Always False','Description:

The software contains an expression that will always evaluate to false.



Mitigation:


PHASE:Testing:
Use Static Analysis tools to spot such conditions.

',1);
INSERT INTO "kb_items" VALUES (571,'Expression is Always True','Description:

The software contains an expression that will always evaluate to true.



Mitigation:


PHASE:Testing:
Use Static Analysis tools to spot such conditions.

',1);
INSERT INTO "kb_items" VALUES (572,'Call to Thread run instead of start','Description:

The program calls a thread''''s run() method instead of calling start(), which causes the code to run in the thread of the caller instead of the callee.

In most cases a direct call to a Thread object''''s run() method is a bug. The programmer intended to begin a new thread of control, but accidentally called run() instead of start(), so the run() method will execute in the caller''''s thread of control.

Mitigation:


PHASE:Implementation:
Use the start() method instead of the run() method.

',1);
INSERT INTO "kb_items" VALUES (573,'Improper Following of Specification by Caller','Description:

The software does not follow or incorrectly follows the specifications as required by the implementation language, environment, framework, protocol, or platform.

When leveraging external functionality, such as an API, it is important that the caller does so in accordance with the requirements of the external functionality or else unintended behaviors may result, possibly leaving the system vulnerable to any number of exploits.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (574,'EJB Bad Practices: Use of Synchronization Primitives','Description:

The program violates the Enterprise JavaBeans (EJB) specification by using thread synchronization primitives.

The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances. The specification justifies this requirement in the following way: This rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean''''s instances, others may distribute the instances across multiple JVMs.

Mitigation:


PHASE:Implementation:
Do not use Synchronization Primitives when writing EJBs.

',1);
INSERT INTO "kb_items" VALUES (575,'EJB Bad Practices: Use of AWT Swing','Description:

The program violates the Enterprise JavaBeans (EJB) specification by using AWT/Swing.

The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input information from a keyboard. The specification justifies this requirement in the following way: Most servers do not allow direct interaction between an application program and a keyboard/display attached to the server system.

Mitigation:


PHASE:Architecture and Design:
Do not use AWT/Swing when writing EJBs.

',1);
INSERT INTO "kb_items" VALUES (576,'EJB Bad Practices: Use of Java I O','Description:

The program violates the Enterprise JavaBeans (EJB) specification by using the java.io package.

The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: An enterprise bean must not use the java.io package to attempt to access files and directories in the file system. The specification justifies this requirement in the following way: The file system APIs are not wellsuited for business components to access data. Business components should use a resource manager API, such as JDBC, to store data.

Mitigation:


PHASE:Implementation:
Do not use Java I/O when writing EJBs.

',1);
INSERT INTO "kb_items" VALUES (577,'EJB Bad Practices: Use of Sockets','Description:

The program violates the Enterprise JavaBeans (EJB) specification by using sockets.

The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: An enterprise bean must not attempt to listen on a socket, accept connections on a socket, or use a socket for multicast. The specification justifies this requirement in the following way: The EJB architecture allows an enterprise bean instance to be a network socket client, but it does not allow it to be a network server. Allowing the instance to become a network server would conflict with the basic function of the enterprise bean to serve the EJB clients.

Mitigation:


PHASE:Architecture and Design Implementation:
Do not use Sockets when writing EJBs.

',1);
INSERT INTO "kb_items" VALUES (578,'EJB Bad Practices: Use of Class Loader','Description:

The program violates the Enterprise JavaBeans (EJB) specification by using the class loader.

The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: The enterprise bean must not attempt to create a class loader; obtain the current class loader; set the context class loader; set security manager; create a new security manager; stop the JVM; or change the input, output, and error streams. The specification justifies this requirement in the following way: These functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security and decrease the container''''s ability to properly manage the runtime environment.

Mitigation:


PHASE:Architecture and Design Implementation:
Do not use the Class Loader when writing EJBs.

',1);
INSERT INTO "kb_items" VALUES (579,'J2EE Bad Practices: Non serializable Object Stored in Session','Description:

The application stores a nonserializable object as an HttpSession attribute, which can hurt reliability.

A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application. This is only possible if all session data is serializable, allowing the session to be duplicated between the JVMs.

Mitigation:


PHASE:Implementation:
In order for session replication to work, the values the application stores as attributes in the session must implement the Serializable interface.

',1);
INSERT INTO "kb_items" VALUES (581,'Object Model Violation: Just One of Equals and Hashcode Defined','Description:

The software does not maintain equal hashcodes for equal objects.

Java objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes. In other words, if a.equals(b) == true then a.hashCode() == b.hashCode().

Mitigation:


PHASE:Implementation:
Both Equals() and Hashcode() should be defined.

',1);
INSERT INTO "kb_items" VALUES (583,'finalize Method Declared Public','Description:

The program violates secure coding principles for mobile code by declaring a finalize() method public.

A program should never call finalize explicitly, except to call super.finalize() inside an implementation of finalize(). In mobile code situations, the otherwise error prone practice of manual garbage collection can become a security threat if an attacker can maliciously invoke a finalize() method because it is declared with public access.

Mitigation:


PHASE:Implementation:
If you are using finalize() as it was designed, there is no reason to declare finalize() with anything other than protected access.

',1);
INSERT INTO "kb_items" VALUES (584,'Return Inside Finally Block','Description:

The code has a return statement inside a finally block, which will cause any thrown exception in the try block to be discarded.



Mitigation:


PHASE:Implementation:
Do not use a return statement inside the finally block. The finally block should have cleanup code.

',1);
INSERT INTO "kb_items" VALUES (585,'Empty Synchronized Block','Description:

The software contains an empty synchronized block.

An empty synchronized block does not actually accomplish any synchronization and may indicate a troubled section of code. An empty synchronized block can occur because code no longer needed within the synchronized block is commented out without removing the synchronized block.

Mitigation:


PHASE:Implementation:
When you come across an empty synchronized statement, or a synchronized statement in which the code has been commented out, try to determine what the original intentions were and whether or not the synchronized block is still necessary.

',1);
INSERT INTO "kb_items" VALUES (586,'Explicit Call to Finalize','Description:

The software makes an explicit call to the finalize() method from outside the finalizer.

While the Java Language Specification allows an object''''s finalize() method to be called from outside the finalizer, doing so is usually a bad idea. For example, calling finalize() explicitly means that finalize() will be called more than once: the first time will be the explicit call and the last time will be the call that is made after the object is garbage collected.

Mitigation:


PHASE:Implementation Testing:
Do not make explicit calls to finalize(). Use static analysis tools to spot such instances.

',1);
INSERT INTO "kb_items" VALUES (587,'Assignment of a Fixed Address to a Pointer','Description:

The software sets a pointer to a specific address other than NULL or 0.

Using a fixed address is not portable because that address will probably not be valid in all environments or platforms.

Mitigation:


PHASE:Implementation:
Never set a pointer to a fixed address.

',1);
INSERT INTO "kb_items" VALUES (588,'Attempt to Access Child of a Non structure Pointer','Description:

Casting a nonstructure type to a structure type and accessing a field can lead to memory access errors or data corruption.



Mitigation:


PHASE:Requirements:
The choice could be made to use a language that is not susceptible to these issues.

PHASE:Implementation:
Review of type casting operations can identify locations where incompatible types are cast.

',1);
INSERT INTO "kb_items" VALUES (589,'Call to Non ubiquitous API','Description:

The software uses an API function that does not exist on all versions of the target platform. This could cause portability problems or inconsistencies that allow denial of service or other consequences.

Some functions that offer security features supported by the OS are not available on all versions of the OS in common use. Likewise, functions are often deprecated or made obsolete for security reasons and should not be used.

Mitigation:


PHASE:Implementation:
Always test your code on any platform on which it is targeted to run on.

PHASE:Testing:
Test your code on the newest and oldest platform on which it is targeted to run on.

PHASE:Testing:
Develop a system to test for API functions that are not portable.

',1);
INSERT INTO "kb_items" VALUES (590,'Free of Memory not on the Heap','Description:

The application calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc().

When free() is called on an invalid pointer, the program''''s memory management data structures may become corrupted. This corruption can cause the program to crash or, in some circumstances, an attacker may be able to cause free() to operate on controllable memory locations to modify critical program variables or execute code.

Mitigation:


PHASE:Implementation:
Only free pointers that you have called malloc on previously. This is the recommended solution. Keep track of which pointers point at the beginning of valid chunks and free them only once.

PHASE:Implementation:
Before freeing a pointer, the programmer should make sure that the pointer was previously allocated on the heap and that the memory belongs to the programmer. Freeing an unallocated pointer will cause undefined behavior in the program.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers.

PHASE:Architecture and Design:
Use a language that provides abstractions for memory allocation and deallocation.

PHASE:Testing:
Use a tool that dynamically detects memory management problems, such as valgrind.

',1);
INSERT INTO "kb_items" VALUES (591,'Sensitive Data Storage in Improperly Locked Memory','Description:

The application stores sensitive data in memory that is not locked, or that has been incorrectly locked, which might cause the memory to be written to swap files on disk by the virtual memory manager. This can make the data more accessible to external actors.

On Windows systems the VirtualLock function can lock a page of memory to ensure that it will remain present in memory and not be swapped to disk. However, on older versions of Windows, such as 95, 98, or Me, the VirtualLock() function is only a stub and provides no protection. On POSIX systems the mlock() call ensures that a page will stay resident in memory but does not guarantee that the page will not appear in the swap. Therefore, it is unsuitable for use as a protection mechanism for sensitive data. Some platforms, in particular Linux, do make the guarantee that the page will not be swapped, but this is nonstandard and is not portable. Calls to mlock() also require supervisor privilege. Return values for both of these calls must be checked to ensure that the lock operation was actually successful.

Mitigation:


PHASE:Architecture and Design:
Identify data that needs to be protected from swapping and choose platformappropriate protection mechanisms.

PHASE:Implementation:
Check return values to ensure locking operations are successful.

',1);
INSERT INTO "kb_items" VALUES (593,'Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created','Description:

The software modifies the SSL context after connection creation has begun.

If the program modifies the SSL_CTX object after creating SSL objects from it, there is the possibility that older SSL objects created from the original context could all be affected by that change.

Mitigation:


PHASE:Architecture and Design:
Use a language or a library that provides a cryptography framework at a higher level of abstraction.

PHASE:Implementation:
Most SSL_CTX functions have SSL counterparts that act on SSLtype objects.

PHASE:Implementation:
Applications should set up an SSL_CTX completely, before creating SSL objects from it.

',1);
INSERT INTO "kb_items" VALUES (594,'J2EE Framework: Saving Unserializable Objects to Disk','Description:

When the J2EE container attempts to write unserializable objects to disk there is no guarantee that the process will complete successfully.

In heavy load conditions, most J2EE application frameworks flush objects to disk to manage memory requirements of incoming requests. For example, session scoped objects, and even application scoped objects, are written to disk when required. While these application frameworks do the real work of writing objects to disk, they do not enforce that those objects be serializable, thus leaving the web application vulnerable to crashes induced by serialization failure. An attacker may be able to mount a denial of service attack by sending enough requests to the server to force the web application to save objects to disk.

Mitigation:


PHASE:Architecture and Design Implementation:
All objects that become part of session and application scope must implement the java.io.Serializable interface to ensure serializability of containing objects.

',1);
INSERT INTO "kb_items" VALUES (595,'Comparison of Object References Instead of Object Contents','Description:

The program compares object references instead of the contents of the objects themselves, preventing it from detecting equivalent objects.

For example, in Java, comparing objects using == usually produces deceptive results, since the == operator compares object references rather than values; often, this means that using == for strings is actually comparing the strings'''' references, not their values.

Mitigation:


PHASE:Implementation:
In Java, use the equals() method to compare objects instead of the == operator. If using ==, it is important for performance reasons that your objects are created by a static factory, not by a constructor.

',1);
INSERT INTO "kb_items" VALUES (597,'Use of Wrong Operator in String Comparison','Description:

The product uses the wrong operator when comparing a string, such as using == when the equals() method should be used instead.

In Java, using == or != to compare two strings for equality actually compares two objects for equality, not their values. Chances are good that the two references will never be equal. While this weakness often only affects program correctness, if the equality is used for a security decision, it could be leveraged to affect program security.

Mitigation:


PHASE:Implementation:
Use equals() to compare strings.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (598,'Use of GET Request Method With Sensitive Query Strings','Description:

The web application uses the HTTP GET method to process a request and includes sensitive information in the query string of that requests.

The query string can be saved in the browser''''s history, passed through Referers to other web sites, stored in web logs, or otherwise recorded in other sources. If the query string contains sensitive information such as session identifiers, then attackers can use this information to launch further attacks.

Mitigation:


PHASE:Implementation:
When sensitive information is sent, use the POST method (e.g. registration form).

',1);
INSERT INTO "kb_items" VALUES (599,'Missing Validation of OpenSSL Certificate','Description:

The software uses OpenSSL and trusts or uses a certificate without using the SSL_get_verify_result() function to ensure that the certificate satisfies all necessary security requirements.

This could allow an attacker to use an invalid certificate to claim to be a trusted host, use expired certificates, or conduct other attacks that could be detected if the certificate is properly validated.

Mitigation:


PHASE:Architecture and Design:
Ensure that proper authentication is included in the system design.

PHASE:Implementation:
Understand and properly implement all checks necessary to ensure the identity of entities involved in encrypted communications.

',1);
INSERT INTO "kb_items" VALUES (600,'Uncaught Exception in Servlet ','Description:

The Servlet does not catch all exceptions, which may reveal sensitive debugging information.

When a Servlet throws an exception, the default error response the Servlet container sends back to the user typically includes debugging information. This information is of great value to an attacker. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.

Mitigation:


PHASE:Implementation:
Implement Exception blocks to handle all types of Exceptions.

',1);
INSERT INTO "kb_items" VALUES (601,'URL Redirection to Untrusted Site Open Redirect','Description:

A web application accepts a usercontrolled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.

An http parameter may contain a URL value and could cause the web application to redirect the request to the specified URL. By modifying the URL value to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials. Because the server name in the modified link is identical to the original site, phishing attempts have a more trustworthy appearance.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. Use a list of approved URLs or domains to be used for redirection.

PHASE:Architecture and Design:
Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE79) when generating the disclaimer page.

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to /login.asp and ID 2 could map to http://www.example.com/. Features such as the ESAPI AccessReferenceMap [REF45] provide this capability.

PHASE:Architecture and Design:
Ensure that no externallysupplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF483]. Be sure that the nonce is not predictable (CWE330).

PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, email, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.

PHASE:Operation:STRATEGY:Firewall:
Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate

',1);
INSERT INTO "kb_items" VALUES (602,'Client Side Enforcement of Server Side Security','Description:

The software is composed of a server that relies on the client to implement a mechanism that is intended to protect the server.

When the server relies on protection mechanisms placed on the client side, an attacker can modify the clientside behavior to bypass the protection mechanisms resulting in potentially unexpected interactions between the client and server. The consequences will vary, depending on what the mechanisms are trying to protect.

Mitigation:


PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server. Even though clientside checks provide minimal benefits with respect to serverside security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, clientside errorchecking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in serverside processing time for accidental input errors, although this is typically a small savings.

PHASE:Architecture and Design:
If some degree of trust is required between the two entities, then use integrity checking and strong authentication to ensure that the inputs are coming from a trusted source. Design the product so that this trust is managed in a centralized fashion, especially if there are complex or numerous communication channels, in order to reduce the risks that the implementer will mistakenly omit a check in a single code path.

PHASE:Testing:
Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software''''s operation may slow down, but it should not become unstable, crash, or generate incorrect results.

PHASE:Testing:
Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.

',1);
INSERT INTO "kb_items" VALUES (603,'Use of Client Side Authentication','Description:

A client/server product performs authentication within client code but not in server code, allowing serverside authentication to be bypassed via a modified client that omits the authentication check.

Clientside authentication is extremely weak and may be breached easily. Any attacker may read the source code and reverseengineer the authentication mechanism to access parts of the application which would otherwise be protected.

Mitigation:


PHASE:Architecture and Design:
Do not rely on client side data. Always perform server side authentication.

',1);
INSERT INTO "kb_items" VALUES (605,'Multiple Binds to the Same Port','Description:

When multiple sockets are allowed to bind to the same port, other services on that port may be stolen or spoofed.

On most systems, a combination of setting the SO_REUSEADDR socket option, and a call to bind() allows any process to bind to a port to which a previous process has bound with INADDR_ANY. This allows a user to bind to the specific address of a server bound to INADDR_ANY on an unprivileged port, and steal its UDP packets/TCP connection.

Mitigation:


PHASE:Policy:
Restrict server socket address to known local addresses.

',1);
INSERT INTO "kb_items" VALUES (606,'Unchecked Input for Loop Condition','Description:

The product does not properly check inputs that are used for loop conditions, potentially leading to a denial of service because of excessive looping.



Mitigation:


PHASE:Implementation:
Do not use usercontrolled data for loop conditions.

PHASE:Implementation:
Perform input validation.

',1);
INSERT INTO "kb_items" VALUES (607,'Public Static Final Field References Mutable Object','Description:

A public or protected static final field references a mutable object, which allows the object to be changed by malicious code, or accidentally from another package.



Mitigation:


PHASE:Implementation:
Protect mutable objects by making them private. Restrict access to the getter and setter as well.

',1);
INSERT INTO "kb_items" VALUES (608,'Struts: Non private Field in ActionForm Class','Description:

An ActionForm class contains a field that has not been declared private, which can be accessed without using a setter or getter.



Mitigation:


PHASE:Implementation:
Make all fields private. Use getter to get the value of the field. Setter should be used only by the framework; setting an action form field from other actions is bad practice and should be avoided.

',1);
INSERT INTO "kb_items" VALUES (609,'Double Checked Locking','Description:

The program uses doublechecked locking to access a resource without the overhead of explicit synchronization, but the locking is insufficient.

Doublechecked locking refers to the situation where a programmer checks to see if a resource has been initialized, grabs a lock, checks again to see if the resource has been initialized, and then performs the initialization if it has not occurred yet. This should not be done, as is not guaranteed to work in all languages and on all architectures. In summary, other threads may not be operating inside the synchronous block and are not guaranteed to see the operations execute in the same order as they would appear inside the synchronous block.

Mitigation:


PHASE:Implementation:
While doublechecked locking can be achieved in some languages, it is inherently flawed in Java before 1.5, and cannot be achieved without compromising platform independence. Before Java 1.5, only use of the synchronized keyword is known to work. Beginning in Java 1.5, use of the volatile keyword allows doublechecked locking to work successfully, although there is some debate as to whether it achieves sufficient performance gains. See references.

',1);
INSERT INTO "kb_items" VALUES (610,'Externally Controlled Reference to a Resource in Another Sphere','Description:

The product uses an externally controlled name or reference that resolves to a resource that is outside of the intended control sphere.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (611,'Improper Restriction of XML External Entity Reference','Description:

The software processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.

XML documents optionally contain a Document Type Definition (DTD), which, among other features, enables the definition of XML entities. It is possible to define an entity by providing a substitution string in the form of a URI. The XML parser can access the contents of this URI and embed these contents back into the XML document for further processing. By submitting an XML file that defines an external entity with a file:// URI, an attacker can cause the processing application to read the contents of a local file. For example, a URI such as file:///c:/winnt/win.ini designates (in Windows) the file C:Winntwin.ini, or file:///etc/passwd designates the password file in Unixbased systems. Using URIs with other schemes such as http://, the attacker can force the application to make outgoing requests to servers that the attacker cannot reach directly, which can be used to bypass firewall restrictions or hide the source of attacks such as port scanning. Once the content of the URI is read, it is fed back into the application that is processing the XML. This application may echo back the data (e.g. in an error message), thereby exposing the file contents.

Mitigation:


PHASE:Implementation System Configuration:
Many XML parsers and validators can be configured to disable external entity expansion.

',1);
INSERT INTO "kb_items" VALUES (612,'Improper Authorization of Index Containing Sensitive Information','Description:

The product creates a search index of private or sensitive documents, but it does not properly limit index access to actors who are authorized to see the original information.

Web sites and other document repositories may apply an indexing routine against a group of private documents to facilitate search. If the index''''s results are available to parties who do not have access to the documents being indexed, then attackers could obtain portions of the documents by conducting targeted searches and reading the results. The risk is especially dangerous if search results include surrounding text that was not part of the search query. This issue can appear in search engines that are not configured (or implemented) to ignore critical files that should remain hidden; even without permissions to download these files directly, the remote user could read them.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (613,'Insufficient Session Expiration','Description:

According to WASC, Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.



Mitigation:


PHASE:Implementation:
Set sessions/credentials expiration date.

',1);
INSERT INTO "kb_items" VALUES (614,'Sensitive Cookie in HTTPS Session Without Secure Attribute','Description:

The Secure attribute for sensitive cookies in HTTPS sessions is not set, which could cause the user agent to send those cookies in plaintext over an HTTP session.



Mitigation:


PHASE:Implementation:
Always set the secure attribute when the cookie should sent via HTTPS only.

',1);
INSERT INTO "kb_items" VALUES (615,'Inclusion of Sensitive Information in Source Code Comments','Description:

While adding general comments is very useful, some programmers tend to leave important data, such as: filenames related to the web application, old links or links which were not meant to be browsed by users, old code fragments, etc.

An attacker who finds these comments can map the application''''s structure and files, expose hidden parts of the site, and study the fragments of code to reverse engineer the application, which may help develop further attacks against the site.

Mitigation:


PHASE:Distribution:
Remove comments which have sensitive information about the design/implementation of the application. Some of the comments may be exposed to the user and affect the security posture of the application.

',1);
INSERT INTO "kb_items" VALUES (616,'Incomplete Identification of Uploaded File Variables PHP','Description:

The PHP application uses an old method for processing uploaded files by referencing the four global variables that are set for each file (e.g. $varname, $varname_size, $varname_name, $varname_type). These variables could be overwritten by attackers, causing the application to process unauthorized files.

These global variables could be overwritten by POST requests, cookies, or other methods of populating or overwriting these variables. This could be used to read or process arbitrary files by providing values such as /etc/passwd.

Mitigation:


PHASE:Architecture and Design:
Use PHP 4 or later.

PHASE:Architecture and Design:
If you must support older PHP versions, write your own version of is_uploaded_file() and run it against $HTTP_POST_FILES[''''userfile'''']))

PHASE:Implementation:
For later PHP versions, reference uploaded files using the $HTTP_POST_FILES or $_FILES variables, and use is_uploaded_file() or move_uploaded_file() to ensure that you are dealing with an uploaded file.

',1);
INSERT INTO "kb_items" VALUES (617,'Reachable Assertion','Description:

The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.

While assertion is good for catching logic errors and reducing the chances of reaching more serious vulnerability conditions, it can still lead to a denial of service. For example, if a server handles multiple simultaneous connections, and an assert() occurs in one single connection that causes all other connections to be dropped, this is a reachable assertion that leads to a denial of service.

Mitigation:


PHASE:Implementation:
Make sensitive open/close operation non reachable by directly usercontrolled data (e.g. open/close resources)

PHASE:Implementation:STRATEGY:Input Validation:
Perform input validation on user data.

',1);
INSERT INTO "kb_items" VALUES (618,'Exposed Unsafe ActiveX Method','Description:

An ActiveX control is intended for use in a web browser, but it exposes dangerous methods that perform actions that are outside of the browser''''s security model (e.g. the zone or domain).

ActiveX controls can exercise far greater control over the operating system than typical Java or javascript. Exposed methods can be subject to various vulnerabilities, depending on the implemented behaviors of those methods, and whether input validation is performed on the provided arguments. If there is no integrity checking or origin validation, this method could be invoked by attackers.

Mitigation:


PHASE:Implementation:
If you must expose a method, make sure to perform input validation on all arguments, and protect against all possible vulnerabilities.

PHASE:Architecture and Design:
Use code signing, although this does not protect against any weaknesses that are already in the control.

PHASE:Architecture and Design System Configuration:
Where possible, avoid marking the control as safe for scripting.

',1);
INSERT INTO "kb_items" VALUES (619,'Dangling Database Cursor Cursor Injection','Description:

If a database cursor is not closed properly, then it could become accessible to other users while retaining the same privileges that were originally assigned, leaving the cursor dangling.

For example, an improper dangling cursor could arise from unhandled exceptions. The impact of the issue depends on the cursor''''s role, but SQL injection attacks are commonly possible.

Mitigation:


PHASE:Implementation:
Close cursors immediately after access to them is complete. Ensure that you close cursors if exceptions occur.

',1);
INSERT INTO "kb_items" VALUES (620,'Unverified Password Change','Description:

When setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.

This could be used by an attacker to change passwords for another user, thus gaining the privileges associated with that user.

Mitigation:


PHASE:Architecture and Design:
When prompting for a password change, force the user to provide the original password in addition to the new password.

PHASE:Architecture and Design:
Do not use forgotten password functionality. But if you must, ensure that you are only providing information to the actual user, e.g. by using an email address or challenge question that the legitimate user already provided in the past; do not allow the current user to change this identity information until the correct password has been provided.

',1);
INSERT INTO "kb_items" VALUES (621,'Variable Extraction Error','Description:

The product uses external input to determine the names of variables into which information is extracted, without verifying that the names of the specified variables are valid. This could cause the program to overwrite unintended variables.

For example, in PHP, extraction can be used to provide functionality similar to register_globals, a dangerous functionality that is frequently disabled in production systems. Calling extract() or import_request_variables() without the proper arguments could allow arbitrary global variables to be overwritten, including superglobals. Similar functionality is possible in other interpreted languages, including custom languages.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
Use whitelists of variable names that can be extracted.

PHASE:Implementation:
Consider refactoring your code to avoid extraction routines altogether.

PHASE:Implementation:
In PHP, call extract() with options such as EXTR_SKIP and EXTR_PREFIX_ALL; call import_request_variables() with a prefix argument. Note that these capabilities are not present in all PHP versions.

',1);
INSERT INTO "kb_items" VALUES (622,'Improper Validation of Function Hook Arguments','Description:

A product adds hooks to useraccessible API functions, but does not properly validate the arguments. This could lead to resultant vulnerabilities.

Such hooks can be used in defensive software that runs with privileges, such as antivirus or firewall, which hooks kernel calls. When the arguments are not validated, they could be used to bypass the protection scheme or attack the product itself.

Mitigation:


PHASE:Architecture and Design:
Ensure that all arguments are verified, as defined by the API you are protecting.

PHASE:Architecture and Design:
Drop privileges before invoking such functions, if possible.

',1);
INSERT INTO "kb_items" VALUES (623,'Unsafe ActiveX Control Marked Safe For Scripting','Description:

An ActiveX control is intended for restricted use, but it has been marked as safeforscripting.

This might allow attackers to use dangerous functionality via a web page that accesses the control, which can lead to different resultant vulnerabilities, depending on the control''''s behavior.

Mitigation:


PHASE:Architecture and Design:
During development, do not mark it as safe for scripting.

PHASE:System Configuration:
After distribution, you can set the kill bit for the control so that it is not accessible from Internet Explorer.

',1);
INSERT INTO "kb_items" VALUES (624,'Executable Regular Expression Error','Description:

The product uses a regular expression that either (1) contains an executable component with usercontrolled inputs, or (2) allows a user to enable execution by inserting pattern modifiers.

Case (2) is possible in the PHP preg_replace() function, and possibly in other languages when a usercontrolled input is inserted into a string that is later parsed as a regular expression.

Mitigation:


PHASE:Implementation:
The regular expression feature in some languages allows inputs to be quoted or escaped before insertion, such as Q and E in Perl.

',1);
INSERT INTO "kb_items" VALUES (625,'Permissive Regular Expression','Description:

The product uses a regular expression that does not sufficiently restrict the set of allowed values.

This effectively causes the regexp to accept substrings that match the pattern, which produces a partial comparison to the target. In some cases, this can lead to other weaknesses. Common errors include: not identifying the beginning and end of the target string using wildcards instead of acceptable character ranges others

Mitigation:


PHASE:Implementation:
When applicable, ensure that the regular expression marks beginning and ending string patterns, such as /^string$/ for Perl.

',1);
INSERT INTO "kb_items" VALUES (626,'Null Byte Interaction Error Poison Null Byte','Description:

The product does not properly handle null bytes or NUL characters when passing data between different representations or components.

A null byte (NUL character) can have different meanings across representations or languages. For example, it is a string terminator in standard C libraries, but Perl and PHP strings do not treat it as a terminator. When two representations are crossed  such as when Perl or PHP invokes underlying C functionality  this can produce an interaction error with unexpected results. Similar issues have been reported for ASP. Other interpreters written in C might also be affected. The poison null byte is frequently useful in path traversal attacks by terminating hardcoded extensions that are added to a filename. It can play a role in regular expression processing in PHP.

Mitigation:


PHASE:Implementation:
Remove null bytes from all incoming strings.

',1);
INSERT INTO "kb_items" VALUES (627,'Dynamic Variable Evaluation','Description:

In a language where the user can influence the name of a variable at runtime, if the variable names are not controlled, an attacker can read or write to arbitrary variables, or access arbitrary functions.

The resultant vulnerabilities depend on the behavior of the application, both at the crossover point and in any control/data flow that is reachable by the related variables or functions.

Mitigation:


PHASE:Implementation:STRATEGY:Refactoring:
Refactor the code to avoid dynamic variable evaluation whenever possible.

PHASE:Implementation:STRATEGY:Input Validation:
Use only whitelists of acceptable variable or function names.

PHASE:Implementation:
For function names, ensure that you are only calling functions that accept the proper number of arguments, to avoid unexpected null arguments.

',1);
INSERT INTO "kb_items" VALUES (628,'Function Call with Incorrectly Specified Arguments','Description:

The product calls a function, procedure, or routine with arguments that are not correctly specified, leading to alwaysincorrect behavior and resultant weaknesses.

There are multiple ways in which this weakness can be introduced, including: the wrong variable or reference; an incorrect number of arguments; incorrect order of arguments; wrong type of arguments; or wrong value.

Mitigation:


PHASE:Build and Compilation:
Once found, these issues are easy to fix. Use code inspection tools and relevant compiler features to identify potential violations. Pay special attention to code that is not likely to be exercised heavily during QA.

PHASE:Architecture and Design:
Make sure your API''''s are stable before you use them in production code.

',1);
INSERT INTO "kb_items" VALUES (636,'Not Failing Securely Failing Open','Description:

When the product encounters an error condition or failure, its design requires it to fall back to a state that is less secure than other options that are available, such as selecting the weakest encryption algorithm or using the most permissive access control restrictions.

By entering a less secure state, the product inherits the weaknesses associated with that state, making it easier to compromise. At the least, it causes administrators to have a false sense of security. This weakness typically occurs as a result of wanting to fail functional to minimize administration and support costs, instead of failing safe.

Mitigation:


PHASE:Architecture and Design:
Subdivide and allocate resources and components so that a failure in one part does not affect the entire product.

',1);
INSERT INTO "kb_items" VALUES (637,'Unnecessary Complexity in Protection Mechanism Not Using Economy of Mechanism','Description:

The software uses a more complex mechanism than necessary, which could lead to resultant weaknesses when the mechanism is not correctly understood, modeled, configured, implemented, or used.

Security mechanisms should be as simple as possible. Complex security mechanisms may engender partial implementations and compatibility problems, with resulting mismatches in assumptions and implemented security. A corollary of this principle is that data specifications should be as simple as possible, because complex data specifications result in complex validation code. Complex tasks and systems may also need to be guarded by complex security checks, so simple systems should be preferred.

Mitigation:


PHASE:Architecture and Design:
Avoid complex security mechanisms when simpler ones would meet requirements. Avoid complex data models, and unnecessarily complex operations. Adopt architectures that provide guarantees, simplify understanding through elegance and abstraction, and that can be implemented similarly. Modularize, isolate and do not trust complex code, and apply other secure programming principles on these modules (e.g., least privilege) to mitigate vulnerabilities.

',1);
INSERT INTO "kb_items" VALUES (638,'Not Using Complete Mediation','Description:

The software does not perform access checks on a resource every time the resource is accessed by an entity, which can create resultant weaknesses if that entity''''s rights or privileges change over time.



Mitigation:


PHASE:Architecture and Design:
Invalidate cached privileges, file handles or descriptors, or other access credentials whenever identities, processes, policies, roles, capabilities or permissions change. Perform complete authentication checks before accepting, caching and reusing data, dynamic content and code (scripts). Avoid caching access control decisions as much as possible.

PHASE:Architecture and Design:
Identify all possible code paths that might access sensitive resources. If possible, create and use a single interface that performs the access checks, and develop code standards that require use of this interface.

',1);
INSERT INTO "kb_items" VALUES (639,'Authorization Bypass Through User Controlled Key','Description:

The system''''s authorization functionality does not prevent one user from gaining access to another user''''s data or record by modifying the key value identifying the data.

Retrieval of a user record occurs in the system based on some key value that is under user control. The key would typically identify a userrelated record stored in the system and would be used to lookup that record for presentation to the user. It is likely that an attacker would have to be an authenticated user in the system. However, the authorization process would not properly check the data access operation to ensure that the authenticated user performing the operation has sufficient entitlements to perform the requested data access, hence bypassing any other authorization checks present in the system. For example, attackers can look at places where user specific data is retrieved (e.g. search screens) and determine whether the key for the item being looked up is controllable externally. The key may be a hidden field in the HTML form field, might be passed as a URL parameter or as an unencrypted cookie variable, then in each of these cases it will be possible to tamper with the key value. One manifestation of this weakness is when a system uses sequential or otherwise easilyguessable session IDs that would allow one user to easily switch to another user''''s session and read/modify their data.

Mitigation:


PHASE:Architecture and Design:
For each and every data access, ensure that the user has sufficient privilege to access the record that is being requested.

PHASE:Architecture and Design Implementation:
Make sure that the key that is used in the lookup of a specific user''''s record is not controllable externally by the user or that any tampering can be detected.

PHASE:Architecture and Design:
Use encryption in order to make it more difficult to guess other legitimate values of the key or associate a digital signature with the key so that the server can verify that there has been no tampering.

',1);
INSERT INTO "kb_items" VALUES (640,'Weak Password Recovery Mechanism for Forgotten Password','Description:

The software contains a mechanism for users to recover or change their passwords without knowing the original password, but the mechanism is weak.

It is common for an application to have a mechanism that provides a means for a user to gain access to their account in the event they forget their password. Very often the password recovery mechanism is weak, which has the effect of making it more likely that it would be possible for a person other than the legitimate system user to gain access to that user''''s account. Weak password recovery schemes completely undermine a strong password authentication scheme. This weakness may be that the security question is too easy to guess or find an answer to (e.g. because the question is too common, or the answers can be found using social media). Or there might be an implementation weakness in the password recovery mechanism code that may for instance trick the system into emailing the new password to an email account other than that of the user. There might be no throttling done on the rate of password resets so that a legitimate user can be denied service by an attacker if an attacker tries to recover their password in a rapid succession. The system may send the original password to the user rather than generating a new temporary password. In summary, password recovery functionality, if not carefully designed and implemented can often become the system''''s weakest link that can be misused in a way that would allow an attacker to gain unauthorized access to the system.

Mitigation:


PHASE:Architecture and Design:
Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated.

PHASE:Architecture and Design:
Do not use standard weak security questions and use several security questions.

PHASE:Architecture and Design:
Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.

PHASE:Architecture and Design:
Require that the user properly answers the security question prior to resetting their password and sending the new password to the email address of record.

PHASE:Architecture and Design:
Never allow the user to control what email address the new password will be sent to in the password recovery mechanism.

PHASE:Architecture and Design:
Assign a new temporary password rather than revealing the original password.

',1);
INSERT INTO "kb_items" VALUES (641,'Improper Restriction of Names for Files and Other Resources','Description:

The application constructs the name of a file or other resource using input from an upstream component, but it does not restrict or incorrectly restricts the resulting name.

This may produce resultant weaknesses. For instance, if the names of these resources contain scripting characters, it is possible that a script may get executed in the client''''s browser if the application ever displays the name of the resource on a dynamically generated web page. Alternately, if the resources are consumed by some application parser, a specially crafted name can exploit some vulnerability internal to the parser, potentially resulting in execution of arbitrary code on the server machine. The problems will vary based on the context of usage of such malformed resource names and whether vulnerabilities are present in or assumptions are made by the targeted technology that would make code execution possible.

Mitigation:


PHASE:Architecture and Design:
Do not allow users to control names of resources used on the server side.

PHASE:Architecture and Design:
Perform whitelist input validation at entry points and also before consuming the resources. Reject bad file names rather than trying to cleanse them.

PHASE:Architecture and Design:
Make sure that technologies consuming the resources are not vulnerable (e.g. buffer overflow, format string, etc.) in a way that would allow code execution if the name of the resource is malformed.

',1);
INSERT INTO "kb_items" VALUES (642,'External Control of Critical State Data','Description:

The software stores securitycritical state information about its users, or the software itself, in a location that is accessible to unauthorized actors.

If an attacker can modify the state information without detection, then it could be used to perform unauthorized actions or access unexpected resources, since the application programmer does not expect that the state can be changed. State information can be stored in various locations such as a cookie, in a hidden web form field, input parameter or argument, an environment variable, a database record, within a settings file, etc. All of these locations have the potential to be modified by an attacker. When this state information is used to control security or determine resource usage, then it may create a vulnerability. For example, an application may perform authentication, then save the state in an authenticated=true cookie. An attacker may simply create this cookie in order to bypass the authentication.

Mitigation:


PHASE:Architecture and Design:
Understand all the potential locations that are accessible to attackers. For example, some programmers assume that cookies and hidden form fields cannot be modified by an attacker, or they may not consider that environment variables can be modified before a privileged program is invoked.

PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:
Store state information and sensitive data on the server side only. Ensure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions. If information must be stored on the client, do not do so without encryption and integrity checking, or otherwise having a mechanism on the server side to catch tampering. Use a message authentication code (MAC) algorithm, such as Hash Message Authentication Code (HMAC) [REF529]. Apply this against the state or sensitive data that you has to be exposed, which can guarantee the integrity of the data  i.e., that the data has not been modified. Ensure that a strong hash function is used (CWE328).

PHASE:Architecture and Design:
Store state information on the server side only. Ensure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. With a stateless protocol such as HTTP, use some frameworks can maintain the state for you. Examples include ASP.NET View State and the OWASP ESAPI Session Management feature. Be careful of language features that provide state support, since these might be provided as a convenience to the programmer and may not be considering security.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

PHASE:Testing:
Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software''''s operation may slow down, but it should not become unstable, crash, or generate incorrect results.

PHASE:Testing:
Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.

',1);
INSERT INTO "kb_items" VALUES (643,'Improper Neutralization of Data within XPath Expressions XPath Injection','Description:

The software uses external input to dynamically construct an XPath expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.

The net effect is that the attacker will have control over the information selected from the XML database and may use that ability to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).

Mitigation:


PHASE:Implementation:
Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.

PHASE:Implementation:
Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.

',1);
INSERT INTO "kb_items" VALUES (644,'Improper Neutralization of HTTP Headers for Scripting Syntax','Description:

The application does not neutralize or incorrectly neutralizes web scripting syntax in HTTP headers that can be used by web browser components that can process raw headers, such as Flash.

An attacker may be able to conduct crosssite scripting and other attacks against users who have these components enabled. If an application does not neutralize user controlled data being placed in the header of an HTTP response coming from the server, the header may contain a script that will get executed in the client''''s browser context, potentially resulting in a cross site scripting vulnerability or possibly an HTTP response splitting attack. It is important to carefully control data that is being placed both in HTTP response header and in the HTTP response body to ensure that no scripting syntax is present, taking various encodings into account.

Mitigation:


PHASE:Architecture and Design:
Perform output validation in order to filter/escape/encode unsafe data that is being passed from the server in an HTTP response header.

PHASE:Architecture and Design:
Disable script execution functionality in the clients'''' browser.

',1);
INSERT INTO "kb_items" VALUES (645,'Overly Restrictive Account Lockout Mechanism','Description:

The software contains an account lockout protection mechanism, but the mechanism is too restrictive and can be triggered too easily, which allows attackers to deny service to legitimate users by causing their accounts to be locked out.

Account lockout is a security feature often present in applications as a countermeasure to the brute force attack on the password based authentication mechanism of the system. After a certain number of failed login attempts, the users'''' account may be disabled for a certain period of time or until it is unlocked by an administrator. Other security events may also possibly trigger account lockout. However, an attacker may use this very security feature to deny service to legitimate system users. It is therefore important to ensure that the account lockout security mechanism is not overly restrictive.

Mitigation:


PHASE:Architecture and Design:
Implement more intelligent password throttling mechanisms such as those which take IP address into account, in addition to the login name.

PHASE:Architecture and Design:
Implement a lockout timeout that grows as the number of incorrect login attempts goes up, eventually resulting in a complete lockout.

PHASE:Architecture and Design:
Consider alternatives to account lockout that would still be effective against password brute force attacks, such as presenting the user machine with a puzzle to solve (makes it do some computation).

',1);
INSERT INTO "kb_items" VALUES (646,'Reliance on File Name or Extension of Externally Supplied File','Description:

The software allows a file to be uploaded, but it relies on the file name or extension of the file to determine the appropriate behaviors. This could be used by attackers to cause the file to be misclassified and processed in a dangerous fashion.

An application might use the file name or extension of of a usersupplied file to determine the proper course of action, such as selecting the correct process to which control should be passed, deciding what data should be made available, or what resources should be allocated. If the attacker can cause the code to misclassify the supplied file, then the wrong action could occur. For example, an attacker could supply a file that ends in a .php.gif extension that appears to be a GIF image, but would be processed as PHP code. In extreme cases, code execution is possible, but the attacker could also cause exhaustion of resources, denial of service, exposure of debug or system data (including application source code), or being bound to a particular server side process. This weakness may be due to a vulnerability in any of the technologies used by the web and application servers, due to misconfiguration, or resultant from another flaw in the application itself.

Mitigation:


PHASE:Architecture and Design:
Make decisions on the server side based on file content and not on file name or extension.

',1);
INSERT INTO "kb_items" VALUES (647,'Use of Non Canonical URL Paths for Authorization Decisions','Description:

The software defines policy namespaces and makes authorization decisions based on the assumption that a URL is canonical. This can allow a noncanonical URL to bypass the authorization.

If an application defines policy namespaces and makes authorization decisions based on the URL, but it does not require or convert to a canonical URL before making the authorization decision, then it opens the application to attack. For example, if the application only wants to allow access to http://www.example.com/mypage, then the attacker might be able to bypass this restriction using equivalent URLs such as: http://WWW.EXAMPLE.COM/mypage http://www.example.com/%6Dypage (alternate encoding) http://192.168.1.1/mypage (IP address) http://www.example.com/mypage/ (trailing /) http://www.example.com:80/mypage Therefore it is important to specify access control policy that is based on the path information in some canonical form with all alternate encodings rejected (which can be accomplished by a default deny rule).

Mitigation:


PHASE:Architecture and Design:
Make access control policy based on path information in canonical form. Use very restrictive regular expressions to validate that the path is in the expected form.

PHASE:Architecture and Design:
Reject all alternate path encodings that are not in the expected canonical form.

',1);
INSERT INTO "kb_items" VALUES (648,'Incorrect Use of Privileged APIs','Description:

The application does not conform to the API requirements for a function call that requires extra privileges. This could allow attackers to gain privileges by causing the function to be called incorrectly.

When an application contains certain functions that perform operations requiring an elevated level of privilege, the caller of a privileged API must be careful to: ensure that assumptions made by the APIs are valid, such as validity of arguments account for known weaknesses in the design/implementation of the API call the API from a safe context If the caller of the API does not follow these requirements, then it may allow a malicious user or process to elevate their privilege, hijack the process, or steal sensitive data. For instance, it is important to know if privileged APIs do not shed their privileges before returning to the caller or if the privileged function might make certain assumptions about the data, context or state information passed to it by the caller. It is important to always know when and how privileged APIs can be called in order to ensure that their elevated level of privilege cannot be exploited.

Mitigation:


PHASE:Implementation:
Before calling privileged APIs, always ensure that the assumptions made by the privileged code hold true prior to making the call.

PHASE:Architecture and Design:
Know architecture and implementation weaknesses of the privileged APIs and make sure to account for these weaknesses before calling the privileged APIs to ensure that they can be called safely.

PHASE:Implementation:
If privileged APIs make certain assumptions about data, context or state validity that are passed by the caller, the calling code must ensure that these assumptions have been validated prior to making the call.

PHASE:Implementation:
If privileged APIs do not shed their privilege prior to returning to the calling code, then calling code needs to shed these privileges immediately and safely right after the call to the privileged APIs. In particular, the calling code needs to ensure that a privileged thread of execution will never be returned to the user or made available to usercontrolled processes.

PHASE:Implementation:
Only call privileged APIs from safe, consistent and expected state.

PHASE:Implementation:
Ensure that a failure or an error will not leave a system in a state where privileges are not properly shed and privilege escalation is possible (i.e. fail securely with regards to handling of privileges).

',1);
INSERT INTO "kb_items" VALUES (649,'Reliance on Obfuscation or Encryption of Security Relevant Inputs without Integrity Checking','Description:

The software uses obfuscation or encryption of inputs that should not be mutable by an external actor, but the software does not use integrity checks to detect if those inputs have been modified.

When an application relies on obfuscation or incorrectly applied / weak encryption to protect clientcontrollable tokens or parameters, that may have an effect on the user state, system state, or some decision made on the server. Without protecting the tokens/parameters for integrity, the application is vulnerable to an attack where an adversary blindly traverses the space of possible values of the said token/parameter in order to attempt to gain an advantage. The goal of the attacker is to find another admissible value that will somehow elevate their privileges in the system, disclose information or change the behavior of the system in some way beneficial to the attacker. If the application does not protect these critical tokens/parameters for integrity, it will not be able to determine that these values have been tampered with. Measures that are used to protect data for confidentiality should not be relied upon to provide the integrity service.

Mitigation:


PHASE:Architecture and Design:
Protect important client controllable tokens/parameters for integrity using PKI methods (i.e. digital signatures) or other means, and checks for integrity on the server side.

PHASE:Architecture and Design:
Repeated requests from a particular user that include invalid values of tokens/parameters (those that should not be changed manually by users) should result in the user account lockout.

PHASE:Architecture and Design:
Client side tokens/parameters should not be such that it would be easy/predictable to guess another valid state.

PHASE:Architecture and Design:
Obfuscation should not be relied upon. If encryption is used, it needs to be properly applied (i.e. proven algorithm and implementation, use padding, use random initialization vector, user proper encryption mode). Even with proper encryption where the ciphertext does not leak information about the plaintext or reveal its structure, compromising integrity is possible (although less likely) without the provision of the integrity service.

',1);
INSERT INTO "kb_items" VALUES (650,'Trusting HTTP Permission Methods on the Server Side','Description:

The server contains a protection mechanism that assumes that any URI that is accessed using HTTP GET will not cause a state change to the associated resource. This might allow attackers to bypass intended access restrictions and conduct resource modification and deletion attacks, since some applications allow GET to modify state.

The HTTP GET method and some other methods are designed to retrieve resources and not to alter the state of the application or resources on the server side. Furthermore, the HTTP specification requires that GET requests (and other requests) should not have side effects. Believing that it will be enough to prevent unintended resource alterations, an application may disallow the HTTP requests to perform DELETE, PUT and POST operations on the resource representation. However, there is nothing in the HTTP protocol itself that actually prevents the HTTP GET method from performing more than just query of the data. Developers can easily code programs that accept a HTTP GET request that do in fact create, update or delete data on the server. For instance, it is a common practice with REST based Web Services to have HTTP GET requests modifying resources on the server side. However, whenever that happens, the access control needs to be properly enforced in the application. No assumptions should be made that only HTTP DELETE, PUT, POST, and other methods have the power to alter the representation of the resource being accessed in the request.

Mitigation:


PHASE:System Configuration:
Configure ACLs on the server side to ensure that proper level of access control is defined for each accessible resource representation.

',1);
INSERT INTO "kb_items" VALUES (651,'Exposure of WSDL File Containing Sensitive Information','Description:

The Web services architecture may require exposing a Web Service Definition Language (WSDL) file that contains information on the publicly accessible services and how callers of these services should interact with them (e.g. what parameters they expect and what types they return).

An information exposure may occur if any of the following apply: The WSDL file is accessible to a wider audience than intended. The WSDL file contains information on the methods/services that should not be publicly accessible or information about deprecated methods. This problem is made more likely due to the WSDL often being automatically generated from the code. Information in the WSDL file helps guess names/locations of methods/resources that should not be publicly accessible.

Mitigation:


PHASE:Architecture and Design:
Limit access to the WSDL file as much as possible. If services are provided only to a limited number of entities, it may be better to provide WSDL privately to each of these entities than to publish WSDL publicly.

PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Make sure that WSDL does not describe methods that should not be publicly accessible. Make sure to protect service methods that should not be publicly accessible with access controls.

PHASE:Architecture and Design:
Do not use method names in WSDL that might help an adversary guess names of private methods/resources used by the service.

',1);
INSERT INTO "kb_items" VALUES (652,'Improper Neutralization of Data within XQuery Expressions XQuery Injection','Description:

The software uses external input to dynamically construct an XQuery expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.

The net effect is that the attacker will have control over the information selected from the XML database and may use that ability to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).

Mitigation:


PHASE:Implementation:
Use parameterized queries. This will help ensure separation between data plane and control plane.

PHASE:Implementation:
Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.

',1);
INSERT INTO "kb_items" VALUES (653,'Insufficient Compartmentalization','Description:

The product does not sufficiently compartmentalize functionality or processes that require different privilege levels, rights, or permissions.

When a weakness occurs in functionality that is accessible by lowerprivileged users, then without strong boundaries, an attack might extend the scope of the damage to higherprivileged users.

Mitigation:


PHASE:Architecture and Design:
Break up privileges between different modules, objects or entities. Minimize the interfaces between modules and require strong access control between them.

',1);
INSERT INTO "kb_items" VALUES (654,'Reliance on a Single Factor in a Security Decision','Description:

A protection mechanism relies exclusively, or to a large extent, on the evaluation of a single condition or the integrity of a single object or entity in order to make a decision about granting access to restricted resources or functionality.



Mitigation:


PHASE:Architecture and Design:
Use multiple simultaneous checks before granting access to critical operations or granting critical privileges. A weaker but helpful mitigation is to use several successive checks (multiple layers of security).

PHASE:Architecture and Design:
Use redundant access rules on different choke points (e.g., firewalls).

',1);
INSERT INTO "kb_items" VALUES (655,'Insufficient Psychological Acceptability','Description:

The software has a protection mechanism that is too difficult or inconvenient to use, encouraging nonmalicious users to disable or bypass the mechanism, whether by accident or on purpose.



Mitigation:


PHASE:Testing:
Where possible, perform human factors and usability studies to identify where your product''''s security mechanisms are difficult to use, and why.

PHASE:Architecture and Design:
Make the security mechanism as seamless as possible, while also providing the user with sufficient details when a security decision produces unexpected results.

',1);
INSERT INTO "kb_items" VALUES (656,'Reliance on Security Through Obscurity','Description:

The software uses a protection mechanism whose strength depends heavily on its obscurity, such that knowledge of its algorithms or key data is sufficient to defeat the mechanism.

This reliance on security through obscurity can produce resultant weaknesses if an attacker is able to reverse engineer the inner workings of the mechanism. Note that obscurity can be one small part of defense in depth, since it can create more work for an attacker; however, it is a significant risk if used as the primary means of protection.

Mitigation:


PHASE:Architecture and Design:
Always consider whether knowledge of your code or design is sufficient to break it. Reverse engineering is a highly successful discipline, and ficially feasible for motivated adversaries. Blackbox techniques are established for binary analysis of executables that use obfuscation, runtime analysis of proprietary protocols, inferring file formats, and others.

PHASE:Architecture and Design:
When available, use publiclyvetted algorithms and procedures, as these are more likely to undergo more extensive security analysis and testing. This is especially the case with encryption and authentication.

',1);
INSERT INTO "kb_items" VALUES (657,'Violation of Secure Design Principles','Description:

The product violates wellestablished principles for secure design.

This can introduce resultant weaknesses or make it easier for developers to introduce related weaknesses during implementation. Because code is centered around design, it can be resourceintensive to fix design problems.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (662,'Improper Synchronization','Description:

The software utilizes multiple threads or processes to allow temporary access to a shared resource that can only be exclusive to one process at a time, but it does not properly synchronize these actions, which might cause simultaneous accesses of this resource by multiple threads or processes.

Synchronization refers to a variety of behaviors and mechanisms that allow two or more independentlyoperating processes or threads to ensure that they operate on shared resources in predictable ways that do not interfere with each other. Some shared resource operations cannot be executed atomically; that is, multiple steps must be guaranteed to execute sequentially, without any interference by other processes. Synchronization mechanisms vary widely, but they may include locking, mutexes, and semaphores. When a multistep operation on a shared resource cannot be guaranteed to execute independent of interference, then the resulting behavior can be unpredictable. Improper synchronization could lead to data or memory corruption, denial of service, etc.

Mitigation:


PHASE:Implementation:
Use industry standard APIs to synchronize your code.

',1);
INSERT INTO "kb_items" VALUES (663,'Use of a Non reentrant Function in a Concurrent Context','Description:

The software calls a nonreentrant function in a concurrent context in which a competing code sequence (e.g. thread or signal handler) may have an opportunity to call the same function or otherwise influence its state.



Mitigation:


PHASE:Implementation:
Use reentrant functions if available.

PHASE:Implementation:
Add synchronization to your nonreentrant function.

PHASE:Implementation:
In Java, use the ReentrantLock Class.

',1);
INSERT INTO "kb_items" VALUES (664,'Improper Control of a Resource Through its Lifetime','Description:

The software does not maintain or incorrectly maintains control over a resource throughout its lifetime of creation, use, and release.

Resources often have explicit instructions on how to be created, used and destroyed. When software does not follow these instructions, it can lead to unexpected behaviors and potentially exploitable states. Even without explicit instructions, various principles are expected to be adhered to, such as Do not use an object until after its creation is complete, or do not use an object after it has been slated for destruction.

Mitigation:


PHASE:Testing:
Use Static analysis tools to check for unreleased resources.

',1);
INSERT INTO "kb_items" VALUES (665,'Improper Initialization','Description:

The software does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used.

This can have security implications when the associated resource is expected to have certain properties or values, such as a variable that determines whether a user has been authenticated or not.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, in Java, if the programmer does not explicitly initialize a variable, then the code could produce a compiletime error (if the variable is local) or automatically initialize the variable to the default value for the variable''''s type. In Perl, if explicit initialization is not performed, then a default value of undef is assigned, which is interpreted as 0, false, or an equivalent value depending on the context in which the variable is accessed.

PHASE:Architecture and Design:
Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.

PHASE:Implementation:
Explicitly initialize all your variables and other data stores, either during declaration or just before the first usage.

PHASE:Implementation:
Pay close attention to complex conditionals that affect initialization, since some conditions might not perform the initialization.

PHASE:Implementation:
Avoid race conditions (CWE362) during initialization routines.

PHASE:Build and Compilation:
Run or compile your software with settings that generate warnings about uninitialized variables or data.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

',1);
INSERT INTO "kb_items" VALUES (666,'Operation on Resource in Wrong Phase of Lifetime','Description:

The software performs an operation on a resource at the wrong phase of the resource''''s lifecycle, which can lead to unexpected behaviors.

When a developer wants to initialize, use or release a resource, it is important to follow the specifications outlined for how to operate on that resource and to ensure that the resource is in the expected state. In this case, the software wants to perform a normally valid operation, initialization, use or release, on a resource when it is in the incorrect phase of its lifetime.

Mitigation:


PHASE:Architecture and Design:
Follow the resource''''s lifecycle from creation to release.

',1);
INSERT INTO "kb_items" VALUES (667,'Improper Locking','Description:

The software does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.

Locking is a type of synchronization behavior that ensures that multiple independentlyoperating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely  or if no locking is done at all  then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.

Mitigation:


PHASE:Implementation:STRATEGY:Libraries or Frameworks:
Use industry standard APIs to implement locking mechanism.

',1);
INSERT INTO "kb_items" VALUES (668,'Exposure of Resource to Wrong Sphere','Description:

The product exposes a resource to the wrong control sphere, providing unintended actors with inappropriate access to the resource.

Resources such as files and directories may be inadvertently exposed through mechanisms such as insecure permissions, or when a program accidentally operates on the wrong object. For example, a program may intend that private files can only be provided to a specific user. This effectively defines a control sphere that is intended to prevent attackers from accessing these private files. If the file permissions are insecure, then parties other than the user will be able to access those files. A separate control sphere might effectively require that the user can only access the private files, but not any other files on the system. If the program does not ensure that the user is only requesting private files, then the user might be able to access other files on the system. In either case, the end result is that a resource has been exposed to the wrong party.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (669,'Incorrect Resource Transfer Between Spheres','Description:

The product does not properly transfer a resource/behavior to another sphere, or improperly imports a resource/behavior from another sphere, in a manner that provides unintended control over that resource.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (670,'Always Incorrect Control Flow Implementation','Description:

The code contains a control flow path that does not reflect the algorithm that the path is intended to implement, leading to incorrect behavior any time this path is navigated.

This weakness captures cases in which a particular code segment is always incorrect with respect to the algorithm that it is implementing. For example, if a C programmer intends to include multiple statements in a single block but does not include the enclosing braces (CWE483), then the logic is always incorrect. This issue is in contrast to most weaknesses in which the code usually behaves correctly, except when it is externally manipulated in malicious ways.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (671,'Lack of Administrator Control over Security','Description:

The product uses security features in a way that prevents the product''''s administrator from tailoring security settings to reflect the environment in which the product is being used. This introduces resultant weaknesses or prevents it from operating at a level of security that is desired by the administrator.

If the product''''s administrator does not have the ability to manage securityrelated decisions at all times, then protecting the product from outside threats  including the product''''s developer  can become impossible. For example, a hardcoded account name and password cannot be changed by the administrator, thus exposing that product to attacks that the administrator can not prevent.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (672,'Operation on a Resource after Expiration or Release','Description:

The software uses, accesses, or otherwise operates on a resource after that resource has been expired, released, or revoked.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (673,'External Influence of Sphere Definition','Description:

The product does not prevent the definition of control spheres from external actors.

Typically, a product defines its control sphere within the code itself, or through configuration by the product''''s administrator. In some cases, an external party can change the definition of the control sphere. This is typically a resultant weakness.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (674,'Uncontrolled Recursion','Description:

The product does not properly control the amount of recursion that takes place, which consumes excessive resources, such as allocated memory or the program stack.



Mitigation:


PHASE:Implementation:
Limit the number of recursive calls to a reasonable number.

',1);
INSERT INTO "kb_items" VALUES (675,'Duplicate Operations on Resource','Description:

The product performs the same operation on a resource two or more times, when the operation should only be applied once.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (676,'Use of Potentially Dangerous Function','Description:

The program invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely.



Mitigation:


PHASE:Build and Compilation Implementation:
Identify a list of prohibited API functions and prohibit developers from using these functions, providing safer alternatives. In some cases, automatic code analysis tools or the compiler can be instructed to spot use of prohibited functions, such as the banned.h include file from Microsoft''''s SDL. [REF554] [REF7]

',1);
INSERT INTO "kb_items" VALUES (680,'Integer Overflow to Buffer Overflow','Description:

The product performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (681,'Incorrect Conversion between Numeric Types','Description:

When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.



Mitigation:


PHASE:Implementation:
Avoid making conversion between numeric types. Always check for the allowed ranges.

',1);
INSERT INTO "kb_items" VALUES (682,'Incorrect Calculation','Description:

The software performs a calculation that generates incorrect or unintended results that are later used in securitycritical decisions or resource management.

When software performs a securitycritical calculation incorrectly, it might lead to incorrect resource allocations, incorrect privilege assignments, or failed comparisons among other things. Many of the direct results of an incorrect calculation can lead to even larger problems such as failed protection mechanisms or even arbitrary code execution.

Mitigation:


PHASE:Implementation:
Understand your programming language''''s underlying representation and how it interacts with numeric calculation. Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, notanumber calculations, and how your language handles numbers that are too large or too small for its underlying representation.

PHASE:Implementation:STRATEGY:Input Validation:
Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.

PHASE:Implementation:
Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity.

PHASE:Architecture and Design:STRATEGY:Language Selection:
Use languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).

PHASE:Implementation:STRATEGY:Compilation or Build Hardening:
Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.

PHASE:Testing:
Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.

PHASE:Testing:
Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software''''s operation may slow down, but it should not become unstable, crash, or generate incorrect results.

',1);
INSERT INTO "kb_items" VALUES (683,'Function Call With Incorrect Order of Arguments','Description:

The software calls a function, procedure, or routine, but the caller specifies the arguments in an incorrect order, leading to resultant weaknesses.

While this weakness might be caught by the compiler in some languages, it can occur more frequently in cases in which the called function accepts variable numbers or types of arguments, such as format strings in C. It also can occur in languages or environments that do not enforce strong typing.

Mitigation:


PHASE:Implementation:
Use the function, procedure, or routine as specified.

PHASE:Testing:
Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the software. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type.

',1);
INSERT INTO "kb_items" VALUES (684,'Incorrect Provision of Specified Functionality','Description:

The code does not function according to its published specifications, potentially leading to incorrect usage.

When providing functionality to an external party, it is important that the software behaves in accordance with the details specified. When requirements of nuances are not documented, the functionality may produce unintended behaviors for the caller, possibly leading to an exploitable state.

Mitigation:


PHASE:Implementation:
Ensure that your code strictly conforms to specifications.

',1);
INSERT INTO "kb_items" VALUES (685,'Function Call With Incorrect Number of Arguments','Description:

The software calls a function, procedure, or routine, but the caller specifies too many arguments, or too few arguments, which may lead to undefined behavior and resultant weaknesses.



Mitigation:


PHASE:Testing:
Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the software. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type.

',1);
INSERT INTO "kb_items" VALUES (686,'Function Call With Incorrect Argument Type','Description:

The software calls a function, procedure, or routine, but the caller specifies an argument that is the wrong data type, which may lead to resultant weaknesses.

This weakness is most likely to occur in loosely typed languages, or in strongly typed languages in which the types of variable arguments cannot be enforced at compilation time, or where there is implicit casting.

Mitigation:


PHASE:Testing:
Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the software. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type.

',1);
INSERT INTO "kb_items" VALUES (687,'Function Call With Incorrectly Specified Argument Value','Description:

The software calls a function, procedure, or routine, but the caller specifies an argument that contains the wrong value, which may lead to resultant weaknesses.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (688,'Function Call With Incorrect Variable or Reference as Argument','Description:

The software calls a function, procedure, or routine, but the caller specifies the wrong variable or reference as one of the arguments, which may lead to undefined behavior and resultant weaknesses.



Mitigation:


PHASE:Testing:
Because this function call often produces incorrect behavior it will usually be detected during testing or normal operation of the software. During testing exercise all possible control paths will typically expose this weakness except in rare cases when the incorrect function call accidentally produces the correct results or if the provided argument type is very similar to the expected argument type.

',1);
INSERT INTO "kb_items" VALUES (689,'Permission Race Condition During Resource Copy','Description:

The product, while copying or cloning a resource, does not set the resource''''s permissions or access control until the copy is complete, leaving the resource exposed to other spheres while the copy is taking place.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (690,'Unchecked Return Value to NULL Pointer Dereference','Description:

The product does not check for an error after calling a function that can return with a NULL pointer if the function fails, which leads to a resultant NULL pointer dereference.

While unchecked return value weaknesses are not limited to returns of NULL pointers (see the examples in CWE252), functions often return NULL to indicate an error status. When this error condition is not checked, a NULL pointer dereference can occur.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (691,'Insufficient Control Flow Management','Description:

The code does not sufficiently manage its control flow during execution, creating conditions in which the control flow can be modified in unexpected ways.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (692,'Incomplete Blacklist to Cross Site Scripting','Description:

The product uses a blacklistbased protection mechanism to defend against XSS attacks, but the blacklist is incomplete, allowing XSS variants to succeed.

While XSS might seem simple to prevent, web browsers vary so widely in how they parse web pages, that a blacklist cannot keep track of all the variations. The XSS Cheat Sheet [REF564] contains a large number of attacks that are intended to bypass incomplete blacklists.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (693,'Protection Mechanism Failure','Description:

The product does not use or incorrectly uses a protection mechanism that provides sufficient defense against directed attacks against the product.

This weakness covers three distinct situations. A missing protection mechanism occurs when the application does not define any mechanism against a certain class of attack. An insufficient protection mechanism might provide some defenses  for example, against the most common attacks  but it does not protect against everything that is intended. Finally, an ignored mechanism occurs when a mechanism is available and in active use within the product, but the developer has not applied it in some code path.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (694,'Use of Multiple Resources with Duplicate Identifier','Description:

The software uses multiple resources that can have the same identifier, in a context in which unique identifiers are required.

If the software assumes that each resource has a unique identifier, the software could operate on the wrong resource if attackers can cause multiple resources to be associated with the same identifier.

Mitigation:


PHASE:Architecture and Design:
Where possible, use unique identifiers. If nonunique identifiers are detected, then do not operate any resource with a nonunique identifier and report the error appropriately.

',1);
INSERT INTO "kb_items" VALUES (695,'Use of Low Level Functionality','Description:

The software uses lowlevel functionality that is explicitly prohibited by the framework or specification under which the software is supposed to operate.

The use of lowlevel functionality can violate the specification in unexpected ways that effectively disable builtin protection mechanisms, introduce exploitable inconsistencies, or otherwise expose the functionality to attack.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (696,'Incorrect Behavior Order','Description:

The software performs multiple related behaviors, but the behaviors are performed in the wrong order in ways which may produce resultant weaknesses.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (697,'Incorrect Comparison','Description:

The software compares two entities in a securityrelevant context, but the comparison is incorrect, which may lead to resultant weaknesses.

This weakness class covers several possibilities: the comparison checks one factor incorrectly; the comparison should consider multiple factors, but it does not check some of those factors at all; the comparison checks the wrong factor.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (698,'Execution After Redirect EAR','Description:

The web application sends a redirect to another location, but instead of exiting, it executes additional code.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (703,'Improper Check or Handling of Exceptional Conditions','Description:

The software does not properly anticipate or handle exceptional conditions that rarely occur during normal operation of the software.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (704,'Incorrect Type Conversion or Cast','Description:

The software does not correctly convert an object, resource, or structure from one type to a different type.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (705,'Incorrect Control Flow Scoping','Description:

The software does not properly return control flow to the proper location after it has completed a task or detected an unusual condition.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (706,'Use of Incorrectly Resolved Name or Reference','Description:

The software uses a name or reference to access a resource, but the name/reference resolves to a resource that is outside of the intended control sphere.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (707,'Improper Neutralization','Description:

The product does not ensure or incorrectly ensures that structured messages or data are wellformed and that certain security properties at met before being read from an upstream component or sent to a downstream component.

If a message is malformed it may cause the message to be incorrectly interpreted. Neutralization is a general term that can refer to one or more of the following: filtering, canonicalization, encoding/decoding, escaping/unescaping, quoting/unquoting, or validation. It describes a process that is independent of the specific protection mechanism that performs the neutralization. This weakness typically applies in cases where the product prepares a control message that another process must act on, such as a command or query, and malicious input that was intended as data, can enter the control plane instead. However, this weakness also applies to more general cases where there are not always control implications.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (708,'Incorrect Ownership Assignment','Description:

The software assigns an owner to a resource, but the owner is outside of the intended control sphere.

This may allow the resource to be manipulated by actors outside of the intended control sphere.

Mitigation:


PHASE:Policy:
Periodically review the privileges and their owners.

PHASE:Testing:
Use automated tools to check for privilege settings.

',1);
INSERT INTO "kb_items" VALUES (710,'Improper Adherence to Coding Standards','Description:

The software does not follow certain coding rules for development, which can lead to resultant weaknesses or increase the severity of the associated vulnerabilities.



Mitigation:


PHASE:Implementation:
Document and closely follow coding standards.

PHASE:Testing Implementation:
Where possible, use automated tools to enforce the standards.

',1);
INSERT INTO "kb_items" VALUES (732,'Incorrect Permission Assignment for Critical Resource','Description:

The product specifies permissions for a securitycritical resource in a way that allows that resource to be read or modified by unintended actors.

When a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.

Mitigation:


PHASE:Implementation:
When using a critical resource such as a configuration file, check to see if the resource has insecure permissions (such as being modifiable by any regular user) [REF62], and generate an error or even exit the software if there is a possibility that the resource could have been modified by an unauthorized party.

PHASE:Architecture and Design:
Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully defining distinct user groups, privileges, and/or roles. Map these against data, functionality, and the related resources. Then set the permissions accordingly. This will allow you to maintain more finegrained control over your resources. [REF207]:EFFECTIVENESS:Moderate

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

PHASE:Implementation Installation:
During program startup, explicitly set the default permissions or umask to the most restrictive setting possible. Also set the appropriate permissions during program installation. This will prevent you from inheriting insecure permissions from any user who installs or runs the program.:EFFECTIVENESS:High

PHASE:System Configuration:
For all configuration files, executables, and libraries, make sure that they are only readable and writable by the software''''s administrator.:EFFECTIVENESS:High

PHASE:Documentation:
Do not suggest insecure configuration changes in documentation, especially if those configurations can extend to resources and other programs that are outside the scope of the application.

PHASE:Installation:
Do not assume that a system administrator will manually change the configuration to the settings that are recommended in the software''''s manual.

PHASE:Operation System Configuration:STRATEGY:Environment Hardening:
Ensure that the software runs properly under the Federal Desktop Core Configuration (FDCC) [REF199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.

',1);
INSERT INTO "kb_items" VALUES (733,'Compiler Optimization Removal or Modification of Security critical Code','Description:

The developer builds a securitycritical protection mechanism into the software, but the compiler optimizes the program such that the mechanism is removed or modified.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (749,'Exposed Dangerous Method or Function','Description:

The software provides an Applications Programming Interface (API) or similar interface for interaction with external actors, but the interface includes a dangerous method or function that is not properly restricted.

This weakness can lead to a wide variety of resultant weaknesses, depending on the behavior of the exposed method. It can apply to any number of technologies and approaches, such as ActiveX controls, Java functions, IOCTLs, and so on. The exposure can occur in a few different ways: 1) The function/method was never intended to be exposed to outside actors. 2) The function/method was only intended to be accessible to a limited set of actors, such as Internetbased access from a single web site.

Mitigation:


PHASE:Architecture and Design:
If you must expose a method, make sure to perform input validation on all arguments, limit access to authorized parties, and protect against all possible vulnerabilities.

PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Identify all exposed functionality. Explicitly list all functionality that must be exposed to some user or set of users. Identify which functionality may be: accessible to all users restricted to a small set of privileged users prevented from being directly accessible at all Ensure that the implemented code follows these expectations. This includes setting the appropriate access modifiers where applicable (public, private, protected, etc.) or not marking ActiveX controls safeforscripting.

',1);
INSERT INTO "kb_items" VALUES (754,'Improper Check for Unusual or Exceptional Conditions','Description:

The software does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the software.

The programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer''''s assumptions, possibly introducing instability, incorrect behavior, or a vulnerability. Note that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Choose languages with features such as exception handling that force the programmer to anticipate unusual conditions that may generate exceptions. Custom exceptions may need to be developed to handle unusual businesslogic conditions. Be careful not to pass sensitive exceptions back to the user (CWE209, CWE248).

PHASE:Implementation:
Check the results of all functions that return a value and verify that the value is expected.:EFFECTIVENESS:High

PHASE:Implementation:
If using exception handling, catch and throw specific exceptions instead of overlygeneral exceptions (CWE396, CWE397). Catch and handle exceptions as locally as possible so that exceptions do not propagate too far up the call stack (CWE705). Avoid unchecked or uncaught exceptions where feasible (CWE248).:EFFECTIVENESS:High

PHASE:Implementation:
Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages  but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. Exposing additional information to a potential attacker in the context of an exceptional condition can help the attacker determine what attack vectors are most likely to succeed beyond DoS.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Architecture and Design Implementation:
If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.

PHASE:Architecture and Design:
Use system limits, which should help to prevent resource exhaustion. However, the software should still handle low resource conditions since they may still occur.

',1);
INSERT INTO "kb_items" VALUES (755,'Improper Handling of Exceptional Conditions','Description:

The software does not handle or incorrectly handles an exceptional condition.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (756,'Missing Custom Error Page','Description:

The software does not return custom error pages to the user, possibly exposing sensitive information.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (757,'Selection of Less Secure Algorithm During Negotiation Algorithm Downgrade','Description:

A protocol or its implementation supports interaction between multiple actors and allows those actors to negotiate which algorithm should be used as a protection mechanism such as encryption or authentication, but it does not select the strongest algorithm that is available to both parties.

When a security mechanism can be forced to downgrade to use a less secure algorithm, this can make it easier for attackers to compromise the software by exploiting weaker algorithm. The victim might not be aware that the less secure algorithm is being used. For example, if an attacker can force a communications channel to use cleartext instead of stronglyencrypted data, then the attacker could read the channel by sniffing, instead of going through extra effort of trying to decrypt the data using brute force techniques.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (759,'Use of a One Way Hash without a Salt','Description:

The software uses a oneway cryptographic hash against an input that should not be reversible, such as a password, but the software does not also use a salt as part of the input.

This makes it easier for attackers to precompute the hash value using dictionary attack techniques such as rainbow tables. It should be noted that, despite common perceptions, the use of a good salt with a hash does not sufficiently increase the effort for an attacker who is targeting an individual password, or who has a large amount of computing resources available, such as with cloudbased services or specialized, inexpensive hardware. Offline password cracking can still be effective if the hash function is not expensive to compute; many cryptographic functions are designed to be efficient and can be vulnerable to attacks using massive computing resources, even if the hash is cryptographically strong. The use of a salt only slightly increases the computing requirements for an attacker compared to other strategies such as adaptive hash functions. See CWE916 for more details.

Mitigation:

PHASE:Architecture and Design: Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (stretching) or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionallyfast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.

PHASE:Architecture and Design:
Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (stretching) or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionallyfast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.

Some hash functions that have one or more of these desired properties include Argon2id, bcrypt [REF291], PBKDF2 [REF293], and scrypt [REF292]. Many prefer Argon2id; it is the winner of the 2015 Password Hashing Competition (PHC), and the Argon2id hybrid algorithm has strong countermeasures against softwarebased attacks, direct hardware attacks (including GPUbased attacks), and sidechannel attacks. Bcrypt counters softwarebased attacks; it is weaker against hardwarebased attacks compared to Argon2id, but it is stronger against hardwarebased attacks than PBDKF2. PBKDF2 counters softwarebased attacks, but it is the most vulnerable of these widelyused algorithms to hardwarebased attacks such as from specialized circuits or GPUs (because it can be implemented with a small circuit and little RAM). The scrypt algorithm is expected to be strong against hardware attacks, but has not received as much review as Argon2id.

All of these algorithms are stronger than using salts with hash functions with very little computing overhead. Note that using these functions can have an impact on performance, so they require special consideration to avoid denialofservice attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment''''s needs.:EFFECTIVENESS:High

All of these algorithms are stronger than using salts with hash functions with very little computing overhead. Note that using these functions can have an impact on performance, so they require special consideration to avoid denialofservice attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment''''s needs.:EFFECTIVENESS:High

PHASE:Architecture and Design: If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.:EFFECTIVENESS:Limited

PHASE:Implementation Architecture and Design: When using industryapproved techniques, use them correctly. Don''''t cut corners by skipping resourceintensive steps (CWE325). These steps are often essential for preventing common attacks.',1);
INSERT INTO "kb_items" VALUES (760,'Use of a One Way Hash with a Predictable Salt','Description:

The software uses a oneway cryptographic hash against an input that should not be reversible, such as a password, but the software uses a predictable salt as part of the input.

This makes it easier for attackers to precompute the hash value using dictionary attack techniques such as rainbow tables, effectively disabling the protection that an unpredictable salt would provide. It should be noted that, despite common perceptions, the use of a good salt with a hash does not sufficiently increase the effort for an attacker who is targeting an individual password, or who has a large amount of computing resources available, such as with cloudbased services or specialized, inexpensive hardware. Offline password cracking can still be effective if the hash function is not expensive to compute; many cryptographic functions are designed to be efficient and can be vulnerable to attacks using massive computing resources, even if the hash is cryptographically strong. The use of a salt only slightly increases the computing requirements for an attacker compared to other strategies such as adaptive hash functions. See CWE916 for more details.

Mitigation:


PHASE:Architecture and Design:
Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (stretching) or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionallyfast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use. Some hash functions that have one or more of these desired properties include bcrypt [REF291], scrypt [REF292], and PBKDF2 [REF293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead. Note that using these functions can have an impact on performance, so they require special consideration to avoid denialofservice attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment''''s needs.:EFFECTIVENESS:High

PHASE:Implementation:
If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (761,'Free of Pointer not at Start of Buffer','Description:

The application calls free() on a pointer to a memory resource that was allocated on the heap, but the pointer is not at the start of the buffer.

This can cause the application to crash, or in some cases, modify critical program variables or execute code. This weakness often occurs when the memory is allocated explicitly on the heap with one of the malloc() family functions and free() is called, but pointer arithmetic has caused the pointer to be in the interior or end of the buffer.

Mitigation:


PHASE:Implementation:
When utilizing pointer arithmetic to traverse a buffer, use a separate variable to track progress through memory and preserve the originally allocated address for later freeing.

PHASE:Implementation:
When programming in C++, consider using smart pointers provided by the boost library to help correctly and consistently manage memory.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers.

PHASE:Architecture and Design:
Use a language that provides abstractions for memory allocation and deallocation.

PHASE:Testing:
Use a tool that dynamically detects memory management problems, such as valgrind.

',1);
INSERT INTO "kb_items" VALUES (762,'Mismatched Memory Management Routines','Description:

The application attempts to return a memory resource to the system, but it calls a release function that is not compatible with the function that was originally used to allocate that resource.

This weakness can be generally described as mismatching memory management routines, such as: The memory was allocated on the stack (automatically), but it was deallocated using the memory management routine free() (CWE590), which is intended for explicitly allocated heap memory. The memory was allocated explicitly using one set of memory management functions, and deallocated using a different set. For example, memory might be allocated with malloc() in C++ instead of the new operator, and then deallocated with the delete operator. When the memory management functions are mismatched, the consequences may be as severe as code execution, memory corruption, or program crash. Consequences and ease of exploit will vary depending on the implementation of the routines and the object being managed.

Mitigation:


PHASE:Implementation:
Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free().

PHASE:Implementation:STRATEGY:Libraries or Frameworks:
Choose a language or tool that provides automatic memory management, or makes manual memory management less errorprone. For example, glibc in Linux provides protection against free of invalid pointers. When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF391]. To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std

auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std

shared_ptr and std

unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers.

PHASE:Architecture and Design:
Use a language that provides abstractions for memory allocation and deallocation.

PHASE:Testing:
Use a tool that dynamically detects memory management problems, such as valgrind.

',1);
INSERT INTO "kb_items" VALUES (763,'Release of Invalid Pointer or Reference','Description:

The application attempts to return a memory resource to the system, but calls the wrong release function or calls the appropriate release function incorrectly.

This weakness can take several forms, such as: The memory was allocated, explicitly or implicitly, via one memory management method and deallocated using a different, noncompatible function (CWE762). The function calls or memory management routines chosen are appropriate, however they are used incorrectly, such as in CWE761.

Mitigation:


PHASE:Implementation:
Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free().

PHASE:Implementation:
When programming in C++, consider using smart pointers provided by the boost library to help correctly and consistently manage memory.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers.

PHASE:Architecture and Design:
Use a language that provides abstractions for memory allocation and deallocation.

PHASE:Testing:
Use a tool that dynamically detects memory management problems, such as valgrind.

',1);
INSERT INTO "kb_items" VALUES (764,'Multiple Locks of a Critical Resource','Description:

The software locks a critical resource more times than intended, leading to an unexpected state in the system.

When software is operating in a concurrent environment and repeatedly locks a critical resource, the consequences will vary based on the type of lock, the lock''''s implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra locking calls will reduce the size of the total available pool, possibly leading to degraded performance or a denial of service. If this can be triggered by an attacker, it will be similar to an unrestricted lock (CWE412). In the context of a binary lock, it is likely that any duplicate locking attempts will never succeed since the lock is already held and progress may not be possible.

Mitigation:


PHASE:Implementation:
When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the software acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.

',1);
INSERT INTO "kb_items" VALUES (765,'Multiple Unlocks of a Critical Resource','Description:

The software unlocks a critical resource more times than intended, leading to an unexpected state in the system.

When software is operating in a concurrent environment and repeatedly unlocks a critical resource, the consequences will vary based on the type of lock, the lock''''s implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra calls to unlock will increase the count for the number of available resources, likely resulting in a crash or unpredictable behavior when the system nears capacity.

Mitigation:


PHASE:Implementation:
When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the software acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.

',1);
INSERT INTO "kb_items" VALUES (766,'Critical Data Element Declared Public','Description:

The software declares a critical variable, field, or member to be public when intended security policy requires it to be private.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:


PHASE:Implementation:
Data should be private, static, and final whenever possible. This will assure that your code is protected by instantiating early, preventing access, and preventing tampering.

',1);
INSERT INTO "kb_items" VALUES (767,'Access to Critical Private Variable via Public Method','Description:

The software defines a public method that reads or modifies a private variable.

If an attacker modifies the variable to contain unexpected values, this could violate assumptions from other parts of the code. Additionally, if an attacker can read the private variable, it may expose sensitive information or make it easier to launch further attacks.

Mitigation:


PHASE:Implementation:
Use class accessor and mutator methods appropriately. Perform validation when accepting data from a public method that is intended to modify a critical private variable. Also be sure that appropriate access controls are being applied when a public method interfaces with critical data.

',1);
INSERT INTO "kb_items" VALUES (768,'Incorrect Short Circuit Evaluation','Description:

The software contains a conditional statement with multiple logical expressions in which one of the nonleading expressions may produce side effects. This may lead to an unexpected state in the program after the execution of the conditional, because shortcircuiting logic may prevent the side effects from occurring.

Usage of short circuit evaluation, though welldefined in the C standard, may alter control flow in a way that introduces logic errors that are difficult to detect, possibly causing errors later during the software''''s execution. If an attacker can discover such an inconsistency, it may be exploitable to gain arbitrary control over a system. If the first condition of an or statement is assumed to be true under normal circumstances, or if the first condition of an and statement is assumed to be false, then any subsequent conditional may contain its own logic errors that are not detected during code review or testing. Finally, the usage of short circuit evaluation may decrease the maintainability of the code.

Mitigation:


PHASE:Implementation:
Minimizing the number of statements in a conditional that produce side effects will help to prevent the likelihood of short circuit evaluation to alter control flow in an unexpected way.

',1);
INSERT INTO "kb_items" VALUES (770,'Allocation of Resources Without Limits or Throttling','Description:

The software allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.



Mitigation:


PHASE:Requirements:
Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.

PHASE:Architecture and Design:
Limit the amount of resources that are accessible to unprivileged users. Set peruser limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE410.

PHASE:Architecture and Design:
Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Architecture and Design:
Mitigation of resource exhaustion attacks requires that the target system either: recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question. The second solution can be difficult to effectively institute  and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.

PHASE:Architecture and Design:
Ensure that protocols have specific limits of scale placed on them.

PHASE:Architecture and Design Implementation:
If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery. Ensure that all failures in resource allocation place the system into a safe posture.

PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:
Use resourcelimiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for lessprivileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE703).

',1);
INSERT INTO "kb_items" VALUES (771,'Missing Reference to Active Allocated Resource','Description:

The software does not properly maintain a reference to a resource that has been allocated, which prevents the resource from being reclaimed.

This does not necessarily apply in languages or frameworks that automatically perform garbage collection, since the removal of all references may act as a signal that the resource is ready to be reclaimed.

Mitigation:


PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:
Use resourcelimiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for lessprivileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE703).

',1);
INSERT INTO "kb_items" VALUES (772,'Missing Release of Resource after Effective Lifetime','Description:

The software does not release a resource after its effective lifetime has ended, i.e., after the resource is no longer needed.

When a resource is not released after use, it can allow attackers to cause a denial of service by causing the allocation of resources without triggering their release. Frequentlyaffected resources include memory, CPU, disk space, power or battery, etc.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, languages such as Java, Ruby, and Lisp perform automatic garbage collection that releases memory for objects that have been deallocated.

PHASE:Implementation:
It is good practice to be responsible for freeing all resources you allocate and to be consistent with how and where you free resources in a function. If you allocate resources that you intend to free upon completion of the function, you must be sure to free the resources at all exit points for that function including error conditions.

PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:
Use resourcelimiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for lessprivileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE703).

',1);
INSERT INTO "kb_items" VALUES (773,'Missing Reference to Active File Descriptor or Handle','Description:

The software does not properly maintain references to a file descriptor or handle, which prevents that file descriptor/handle from being reclaimed.

This can cause the software to consume all available file descriptors or handles, which can prevent other processes from performing critical file processing operations.

Mitigation:


PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:
Use resourcelimiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for lessprivileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE703).

',1);
INSERT INTO "kb_items" VALUES (774,'Allocation of File Descriptors or Handles Without Limits or Throttling','Description:

The software allocates file descriptors or handles on behalf of an actor without imposing any restrictions on how many descriptors can be allocated, in violation of the intended security policy for that actor.

This can cause the software to consume all available file descriptors or handles, which can prevent other processes from performing critical file processing operations.

Mitigation:


PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:
Use resourcelimiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for lessprivileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE703).

',1);
INSERT INTO "kb_items" VALUES (775,'Missing Release of File Descriptor or Handle after Effective Lifetime','Description:

The software does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.

When a file descriptor or handle is not released after use (typically by explicitly closing it), attackers can cause a denial of service by consuming all available file descriptors/handles, or otherwise preventing other system processes from obtaining their own file descriptors/handles.

Mitigation:


PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:
Use resourcelimiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for lessprivileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE703).

',1);
INSERT INTO "kb_items" VALUES (776,'Improper Restriction of Recursive Entity References in DTDs XML Entity Expansion','Description:

The software uses XML documents and allows their structure to be defined with a Document Type Definition (DTD), but it does not properly control the number of recursive definitions of entities.

If the DTD contains a large number of nested or recursive entities, this can lead to explosive growth of data when parsed, causing a denial of service.

Mitigation:


PHASE:Operation:
If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

PHASE:Implementation:
Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.

',1);
INSERT INTO "kb_items" VALUES (777,'Regular Expression without Anchors','Description:

The software uses a regular expression to perform neutralization, but the regular expression is not anchored and may allow malicious or malformed data to slip through.

When performing tasks such as whitelist validation, data is examined and possibly modified to ensure that it is wellformed and adheres to a list of safe values. If the regular expression is not anchored, malicious or malformed data may be included before or after any string matching the regular expression. The type of malicious data that is allowed will depend on the context of the application and which anchors are omitted from the regular expression.

Mitigation:


PHASE:Implementation:
Be sure to understand both what will be matched and what will not be matched by a regular expression. Anchoring the ends of the expression will allow the programmer to define a whitelist strictly limited to what is matched by the text in the regular expression. If you are using a package that only matches one line by default, ensure that you can match multiline inputs if necessary.

',1);
INSERT INTO "kb_items" VALUES (778,'Insufficient Logging','Description:

When a securitycritical event occurs, the software either does not record the event or omits important details about the event when logging it.

When securitycritical events are not logged properly, such as a failed login attempt, this can make malicious behavior more difficult to detect and may hinder forensic analysis after an attack succeeds.

Mitigation:


PHASE:Architecture and Design:
Use a centralized logging mechanism that supports multiple levels of detail. Ensure that all securityrelated successes and failures can be logged.

PHASE:Operation:
Be sure to set the level of logging appropriately in a production environment. Sufficient data should be logged to enable system administrators to detect attacks, diagnose errors, and recover from attacks. At the same time, logging too much data (CWE779) can cause the same problems.

',1);
INSERT INTO "kb_items" VALUES (779,'Logging of Excessive Data','Description:

The software logs too much information, making log files hard to process and possibly hindering recovery efforts or forensic analysis after an attack.

While logging is a good practice in general, and very high levels of logging are appropriate for debugging stages of development, too much logging in a production environment might hinder a system administrator''''s ability to detect anomalous conditions. This can provide cover for an attacker while attempting to penetrate a system, clutter the audit trail for forensic analysis, or make it more difficult to debug problems in a production environment.

Mitigation:


PHASE:Architecture and Design:
Suppress large numbers of duplicate log messages and replace them with periodic summaries. For example, syslog may include an entry that states last message repeated X times when recording repeated events.

PHASE:Architecture and Design:
Support a maximum size for the log file that can be controlled by the administrator. If the maximum size is reached, the admin should be notified. Also, consider reducing functionality of the software. This may result in a denialofservice to legitimate software users, but it will prevent the software from adversely impacting the entire system.

PHASE:Implementation:
Adjust configurations appropriately when software is transitioned from a debug state to production.

',1);
INSERT INTO "kb_items" VALUES (780,'Use of RSA Algorithm without OAEP','Description:

The software uses the RSA algorithm but does not incorporate Optimal Asymmetric Encryption Padding (OAEP), which might weaken the encryption.

Padding schemes are often used with cryptographic algorithms to make the plaintext less predictable and complicate attack efforts. The OAEP scheme is often used with RSA to nullify the impact of predictable common text.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (781,'Improper Address Validation in IOCTL with METHOD NEITHER I O Control Code','Description:

The software defines an IOCTL that uses METHOD_NEITHER for I/O, but it does not validate or incorrectly validates the addresses that are provided.

When an IOCTL uses the METHOD_NEITHER option for I/O control, it is the responsibility of the IOCTL to validate the addresses that have been supplied to it. If validation is missing or incorrect, attackers can supply arbitrary memory addresses, leading to code execution or a denial of service.

Mitigation:


PHASE:Implementation:
If METHOD_NEITHER is required for the IOCTL, then ensure that all userspace addresses are properly validated before they are first accessed. The ProbeForRead and ProbeForWrite routines are available for this task. Also properly protect and manage the usersupplied buffers, since the I/O Manager does not do this when METHOD_NEITHER is being used. See References.

PHASE:Architecture and Design:
If possible, avoid using METHOD_NEITHER in the IOCTL and select methods that effectively control the buffer size, such as METHOD_BUFFERED, METHOD_IN_DIRECT, or METHOD_OUT_DIRECT.

PHASE:Architecture and Design Implementation:
If the IOCTL is part of a driver that is only intended to be accessed by trusted users, then use proper access control for the associated device or device namespace. See References.

',1);
INSERT INTO "kb_items" VALUES (782,'Exposed IOCTL with Insufficient Access Control','Description:

The software implements an IOCTL with functionality that should be restricted, but it does not properly enforce access control for the IOCTL.

When an IOCTL contains privileged functionality and is exposed unnecessarily, attackers may be able to access this functionality by invoking the IOCTL. Even if the functionality is benign, if the programmer has assumed that the IOCTL would only be accessed by a trusted process, there may be little or no validation of the incoming data, exposing weaknesses that would never be reachable if the attacker cannot call the IOCTL directly. The implementations of IOCTLs will differ between operating system types and versions, so the methods of attack and prevention may vary widely.

Mitigation:


PHASE:Architecture and Design:
In Windows environments, use proper access control for the associated device or device namespace. See References.

',1);
INSERT INTO "kb_items" VALUES (783,'Operator Precedence Logic Error','Description:

The program uses an expression in which operator precedence causes incorrect logic to be used.

While often just a bug, operator precedence logic errors can have serious consequences if they are used in securitycritical code, such as making an authentication decision.

Mitigation:


PHASE:Implementation:
Regularly wrap subexpressions in parentheses, especially in securitycritical code.

',1);
INSERT INTO "kb_items" VALUES (784,'Reliance on Cookies without Validation and Integrity Checking in a Security Decision','Description:

The application uses a protection mechanism that relies on the existence or values of a cookie, but it does not properly ensure that the cookie is valid for the associated user.

Attackers can easily modify cookies, within the browser or by implementing the clientside code outside of the browser. Attackers can bypass protection mechanisms such as authorization and authentication by modifying the cookie to contain an expected value.

Mitigation:


PHASE:Architecture and Design:
Avoid using cookie data for a securityrelated decision.

PHASE:Implementation:
Perform thorough input validation (i.e.: server side validation) on the cookie data if you''''re going to use it for a security related decision.

PHASE:Architecture and Design:
Add integrity checks to detect tampering.

PHASE:Architecture and Design:
Protect critical cookies from replay attacks, since crosssite scripting or other attacks may allow attackers to steal a stronglyencrypted cookie that also passes integrity checks. This mitigation applies to cookies that should only be valid during a single transaction or session. By enforcing timeouts, you may limit the scope of an attack. As part of your integrity check, use an unpredictable, serverside value that is not exposed to the client.

',1);
INSERT INTO "kb_items" VALUES (785,'Use of Path Manipulation Function without Maximum sized Buffer','Description:

The software invokes a function for normalizing paths or file names, but it provides an output buffer that is smaller than the maximum possible size, such as PATH_MAX.

Passing an inadequatelysized output buffer to a path manipulation function can result in a buffer overflow. Such functions include realpath(), readlink(), PathAppend(), and others.

Mitigation:


PHASE:Implementation:
Always specify output buffers large enough to handle the maximumsize possible result from path manipulation functions.

',1);
INSERT INTO "kb_items" VALUES (786,'Access of Memory Location Before Start of Buffer','Description:

The software reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.

This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (787,'Out of bounds Write','Description:

The software writes data past the end, or before the beginning, of the intended buffer.

Typically, this can result in corruption of data, a crash, or code execution. The software may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent write operation then produces undefined or unexpected results.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language''''s interface to native code may still be subject to overflows, even if the language itself is theoretically safe.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF57], and the Strsafe.h library from Microsoft [REF56]. These libraries provide safer versions of overflowprone stringhandling functions.

PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:
Consider adhering to the following rules when allocating and managing an application''''s memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULLterminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.

PHASE:Operation:STRATEGY:Environment Hardening:
Run or compile the software using features or extensions that randomly arrange the positions of a program''''s executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF58] [REF60] and PositionIndependent Executables (PIE) [REF64].:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF60] [REF61].:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:
Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate

',1);
INSERT INTO "kb_items" VALUES (788,'Access of Memory Location After End of Buffer','Description:

The software reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.

This typically occurs when a pointer or its index is decremented to a position before the buffer; when pointer arithmetic results in a position before the buffer; or when a negative index is used, which generates a position before the buffer.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (789,'Uncontrolled Memory Allocation','Description:

The product allocates memory based on an untrusted size value, but it does not validate or incorrectly validates the size, allowing arbitrary amounts of memory to be allocated.



Mitigation:


PHASE:Implementation Architecture and Design:
Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

PHASE:Operation:
Run your program using systemprovided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.

',1);
INSERT INTO "kb_items" VALUES (790,'Improper Filtering of Special Elements','Description:

The software receives data from an upstream component, but does not filter or incorrectly filters special elements before sending it to a downstream component.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (791,'Incomplete Filtering of Special Elements','Description:

The software receives data from an upstream component, but does not completely filter special elements before sending it to a downstream component.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (792,'Incomplete Filtering of One or More Instances of Special Elements','Description:

The software receives data from an upstream component, but does not completely filter one or more instances of special elements before sending it to a downstream component.

Incomplete filtering of this nature involves either: only filtering a single instance of a special element when more exist, or not filtering all instances or all elements where multiple special elements exist.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (793,'Only Filtering One Instance of a Special Element','Description:

The software receives data from an upstream component, but only filters a single instance of a special element before sending it to a downstream component.

Incomplete filtering of this nature may be locationdependent, as in only the first or last element is filtered.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (794,'Incomplete Filtering of Multiple Instances of Special Elements','Description:

The software receives data from an upstream component, but does not filter all instances of a special element before sending it to a downstream component.

Incomplete filtering of this nature may be applied to: sequential elements (special elements that appear next to each other) or nonsequential elements (special elements that appear multiple times in different locations).

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (795,'Only Filtering Special Elements at a Specified Location','Description:

The software receives data from an upstream component, but only accounts for special elements at a specified location, thereby missing remaining special elements that may exist before sending it to a downstream component.

A filter might only account for instances of special elements when they occur: relative to a marker (e.g. at the beginning/end of string; the second argument), or at an absolute position (e.g. byte number 10). This may leave special elements in the data that did not match the filter position, but still may be dangerous.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (796,'Only Filtering Special Elements Relative to a Marker','Description:

The software receives data from an upstream component, but only accounts for special elements positioned relative to a marker (e.g. at the beginning/end of a string; the second argument), thereby missing remaining special elements that may exist before sending it to a downstream component.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (797,'Only Filtering Special Elements at an Absolute Position','Description:

The software receives data from an upstream component, but only accounts for special elements at an absolute position (e.g. byte number 10), thereby missing remaining special elements that may exist before sending it to a downstream component.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (798,'Use of Hard coded Credentials','Description:

The software contains hardcoded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.

Hardcoded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the software administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the software contains an authentication mechanism that checks the input credentials against a hardcoded set of credentials. Outbound: the software connects to another system or component, and it contains hardcoded credentials for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hardcoded into the product and associated with that account. This hardcoded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the software. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the software will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to frontend systems that authenticate with a backend service. The backend service may require a fixed password which can be easily discovered. The programmer may simply hardcode those backend credentials into the frontend software. Any user of that program may be able to extract the password. Clientside systems with hardcoded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.

Mitigation:


PHASE:Architecture and Design:
For outbound authentication: store passwords, keys, and other credentials outside of the code in a stronglyprotected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF7]. In Windows environments, the Encrypted File System (EFS) may provide some protection.

PHASE:Architecture and Design:
For inbound authentication: Rather than hardcode a default username and password, key, or other authentication credentials for first time logins, utilize a first login mode that requires the user to enter a unique strong password or key.

PHASE:Architecture and Design:
If the software must contain hardcoded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hardcoded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.

PHASE:Architecture and Design:
For inbound authentication using passwords: apply strong oneway hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash. Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a bruteforce attack, possibly limiting the effectiveness of the rainbow table method.

PHASE:Architecture and Design:
For frontend to backend connections: Three solutions are possible, although none are complete. The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals. Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access. Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replaystyle attacks.

',1);
INSERT INTO "kb_items" VALUES (799,'Improper Control of Interaction Frequency','Description:

The software does not properly limit the number or frequency of interactions that it has with an actor, such as the number of incoming requests.

This can allow the actor to perform actions more frequently than expected. The actor could be a human or an automated process such as a virus or bot. This could be used to cause a denial of service, compromise program logic (such as limiting humans to a single vote), or other consequences. For example, an authentication routine might not limit the number of times an attacker can guess a password. Or, a web site might conduct a poll but only expect humans to vote a maximum of once a day.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (804,'Guessable CAPTCHA','Description:

The software uses a CAPTCHA challenge, but the challenge can be guessed or automatically recognized by a nonhuman actor.

An automated attacker could bypass the intended protection of the CAPTCHA challenge and perform actions at a higher frequency than humanly possible, such as launching spam attacks. There can be several different causes of a guessable CAPTCHA: An audio or visual image that does not have sufficient distortion from the unobfuscated source image. A question is generated that with a format that can be automatically recognized, such as a math question. A question for which the number of possible answers is limited, such as birth years or favorite sports teams. A generalknowledge or trivia question for which the answer can be accessed using a data base, such as country capitals or popular actors. Other data associated with the CAPTCHA may provide hints about its contents, such as an image whose filename contains the word that is used in the CAPTCHA.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (805,'Buffer Access with Incorrect Length Value','Description:

The software uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.

When the length value exceeds the size of the destination, a buffer overflow could occur.

Mitigation:


PHASE:Requirements:STRATEGY:Language Selection:
Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language''''s interface to native code may still be subject to overflows, even if the language itself is theoretically safe.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF57], and the Strsafe.h library from Microsoft [REF56]. These libraries provide safer versions of overflowprone stringhandling functions.

PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:
Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth

PHASE:Implementation:
Consider adhering to the following rules when allocating and managing an application''''s memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULLterminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Operation:STRATEGY:Environment Hardening:
Run or compile the software using features or extensions that randomly arrange the positions of a program''''s executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF58] [REF60] and PositionIndependent Executables (PIE) [REF64].:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF59] [REF57].:EFFECTIVENESS:Defense in Depth

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (806,'Buffer Access Using Size of Source Buffer','Description:

The software uses the size of a source buffer when reading from or writing to a destination buffer, which may cause it to access memory that is outside of the bounds of the buffer.

When the size of the destination is smaller than the size of the source, a buffer overflow could occur.

Mitigation:


PHASE:Architecture and Design:
Use an abstraction library to abstract away risky APIs. Examples include the Safe C String Library (SafeStr) by Viega, and the Strsafe.h library from Microsoft. This is not a complete solution, since many buffer overflows are not related to strings.

PHASE:Build and Compilation:
Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. This is not necessarily a complete solution, since these canarybased mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application.

PHASE:Implementation:
Programmers should adhere to the following rules when allocating and managing their applications memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULLterminate the string. Check buffer boundaries if calling this function in a loop and make sure you are not in danger of writing past the allocated space. Truncate all input strings to a reasonable length before passing them to the copy and concatenation functions

PHASE:Operation:STRATEGY:Environment Hardening:
Run or compile the software using features or extensions that randomly arrange the positions of a program''''s executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF58] [REF60] and PositionIndependent Executables (PIE) [REF64].:EFFECTIVENESS:Defense in Depth

PHASE:Operation:STRATEGY:Environment Hardening:
Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF60] [REF61].:EFFECTIVENESS:Defense in Depth

PHASE:Build and Compilation Operation:
Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.

',1);
INSERT INTO "kb_items" VALUES (807,'Reliance on Untrusted Inputs in a Security Decision','Description:

The application uses a protection mechanism that relies on the existence or values of an input, but the input can be modified by an untrusted actor in a way that bypasses the protection mechanism.

Developers may assume that inputs such as cookies, environment variables, and hidden form fields cannot be modified. However, an attacker could change these inputs using customized clients or other attacks. This change might not be detected. When security decisions such as authentication and authorization are made based on the values of these inputs, attackers can bypass the security of the software. Without sufficient encryption, integrity checking, or other mechanism, any input that originates from an outsider cannot be trusted.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:
Store state information and sensitive data on the server side only. Ensure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions. If information must be stored on the client, do not do so without encryption and integrity checking, or otherwise having a mechanism on the server side to catch tampering. Use a message authentication code (MAC) algorithm, such as Hash Message Authentication Code (HMAC) [REF529]. Apply this against the state or sensitive data that you has to be exposed, which can guarantee the integrity of the data  i.e., that the data has not been modified. Ensure that a strong hash function is used (CWE328).

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. With a stateless protocol such as HTTP, use a framework that maintains the state for you. Examples include ASP.NET View State [REF756] and the OWASP ESAPI Session Management feature [REF45]. Be careful of language features that provide state support, since these might be provided as a convenience to the programmer and may not be considering security.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Operation Implementation:STRATEGY:Environment Hardening:
When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE95, CWE621, and similar issues.

PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, email, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Identify all inputs that are used for security decisions and determine if you can modify the design so that you do not have to rely on submitted inputs at all. For example, you may be able to keep critical information about the user''''s session on the server side instead of recording it within external data.

',1);
INSERT INTO "kb_items" VALUES (820,'Missing Synchronization','Description:

The software utilizes a shared resource in a concurrent manner but does not attempt to synchronize access to the resource.

If access to a shared resource is not synchronized, then the resource may not be in a state that is expected by the software. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (821,'Incorrect Synchronization','Description:

The software utilizes a shared resource in a concurrent manner, but it does not correctly synchronize access to the resource.

If access to a shared resource is not correctly synchronized, then the resource may not be in a state that is expected by the software. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (822,'Untrusted Pointer Dereference','Description:

The program obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.

An attacker can supply a pointer for memory locations that the program is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical program state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a program variable to an unexpected value (since the value will be read from an unexpected memory location). There are several variants of this weakness, including but not necessarily limited to: The untrusted value is directly invoked as a function call. In OS kernels or drivers where there is a boundary between userland and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE781 for one such example). Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a nonnetworked environment, and the code is then ported to or otherwise exposed to a networked environment.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (823,'Use of Out of range Pointer Offset','Description:

The program performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.

While a pointer can contain a reference to any arbitrary memory location, a program typically only intends to use the pointer to access limited portions of memory, such as contiguous memory used to access an individual array. Programs may use offsets in order to access fields or subelements stored within structured data. The offset might be outofrange if it comes from an untrusted source, is the result of an incorrect calculation, or occurs because of another error. If an attacker can control or influence the offset so that it points outside of the intended boundaries of the structure, then the attacker may be able to read or write to memory locations that are used elsewhere in the program. As a result, the attack might change the state of the software as accessed through program variables, cause a crash or instable behavior, and possibly lead to code execution.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (824,'Access of Uninitialized Pointer','Description:

The program accesses or uses a pointer that has not been initialized.

If the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the program to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks. Depending on memory layout, associated memory management behaviors, and program operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more finegrained control of the memory location to be accessed.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (825,'Expired Pointer Dereference','Description:

The program dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.

When a program releases memory, but it maintains a pointer to that memory, then the memory might be reallocated at a later time. If the original pointer is accessed to read or write data, then this could cause the program to read or modify data that is in use by a different function or process. Depending on how the newlyallocated memory is used, this could lead to a denial of service, information exposure, or code execution.

Mitigation:


PHASE:Architecture and Design:
Choose a language that provides automatic memory management.

PHASE:Implementation:
When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.

',1);
INSERT INTO "kb_items" VALUES (826,'Premature Release of Resource During Expected Lifetime','Description:

The program releases a resource that is still intended to be used by the program itself or another actor.

This weakness focuses on errors in which the program should not release a resource, but performs the release anyway. This is different than a weakness in which the program releases a resource at the appropriate time, but it maintains a reference to the resource, which it later accesses. For this weakness, the resource should still be valid upon the subsequent access. When a program releases a resource that is still being used, it is possible that operations will still be taken on this resource, which may have been repurposed in the meantime, leading to issues similar to CWE825. Consequences may include denial of service, information exposure, or code execution.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (827,'Improper Control of Document Type Definition','Description:

The software does not restrict a reference to a Document Type Definition (DTD) to the intended control sphere. This might allow attackers to reference arbitrary DTDs, possibly causing the software to expose files, consume excessive system resources, or execute arbitrary http requests on behalf of the attacker.

As DTDs are processed, they might try to read or include files on the machine performing the parsing. If an attacker is able to control the DTD, then the attacker might be able to specify sensitive resources or requests or provide malicious content. For example, the SOAP specification prohibits SOAP messages from containing DTDs.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (828,'Signal Handler with Functionality that is not Asynchronous Safe','Description:

The software defines a signal handler that contains code sequences that are not asynchronoussafe, i.e., the functionality is not reentrant, or it can be interrupted.

This can lead to an unexpected system state with a variety of potential consequences depending on context, including denial of service and code execution. Signal handlers are typically intended to interrupt normal functionality of a program, or even other signals, in order to notify the process of an event. When a signal handler uses global or static variables, or invokes functions that ultimately depend on such state or its associated metadata, then it could corrupt system state that is being used by normal functionality. This could subject the program to race conditions or other weaknesses that allow an attacker to cause the program state to be corrupted. While denial of service is frequently the consequence, in some cases this weakness could be leveraged for code execution. There are several different scenarios that introduce this issue: Invocation of nonreentrant functions from within the handler. One example is malloc(), which modifies internal global variables as it manages memory. Very few functions are actually reentrant. Code sequences (not necessarily function calls) contain nonatomic use of global variables, or associated metadata or structures, that can be accessed by other functionality of the program, including other signal handlers. Frequently, the same function is registered to handle multiple signals. The signal handler function is intended to run at most one time, but instead it can be invoked multiple times. This could happen by repeated delivery of the same signal, or by delivery of different signals that have the same handler function (CWE831). Note that in some environments or contexts, it might be possible for the signal handler to be interrupted itself. If both a signal handler and the normal behavior of the software have to operate on the same set of state variables, and a signal is received in the middle of the normal execution''''s modifications of those variables, the variables may be in an incorrect or corrupt state during signal handler execution, and possibly still incorrect or corrupt upon return.

Mitigation:


PHASE:Implementation Architecture and Design:
Eliminate the usage of nonreentrant functionality inside of signal handlers. This includes replacing all nonreentrant library calls with reentrant calls. Note: This will not always be possible and may require large portions of the software to be rewritten or even redesigned. Sometimes reentrantsafe library alternatives will not be available. Sometimes nonreentrant interaction between the state of the system and the signal handler will be required by design.:EFFECTIVENESS:High

PHASE:Implementation:
Where nonreentrant functionality must be leveraged within a signal handler, be sure to block or mask signals appropriately. This includes blocking other signals within the signal handler itself that may also leverage the functionality. It also includes blocking all signals reliant upon the functionality when it is being accessed or modified by the normal behaviors of the software.

',1);
INSERT INTO "kb_items" VALUES (829,'Inclusion of Functionality from Untrusted Control Sphere','Description:

The software imports, requires, or includes executable functionality (such as a library) from a source that is outside of the intended control sphere.

When including thirdparty functionality, such as a web widget, library, or other source of functionality, the software must effectively trust that functionality. Without sufficient protection mechanisms, the functionality could be malicious in nature (either by coming from an untrusted source, being spoofed, or being modified in transit from a trusted source). The functionality might also contain its own weaknesses, or grant access to additional functionality and state information that should be kept private to the base system, such as system state information, sensitive application data, or the DOM of a web application. This might lead to many different consequences depending on the included functionality, but some examples include injection of malware, information exposure by granting excessive privileges or permissions to the untrusted functionality, DOMbased XSS vulnerabilities, stealing user''''s cookies, or open redirect to malware (CWE601).

Mitigation:


PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:
When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF45] provide this capability.

PHASE:Architecture and Design:
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE602. Attackers can bypass the clientside checks by modifying values after the checks have been performed, or by changing the client to remove the clientside checks entirely. Then, these modified values would be submitted to the server.

PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:
Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OSlevel examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE243 and other weaknesses related to jails.:EFFECTIVENESS:Limited

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in daytoday operations.

PHASE:Implementation:STRATEGY:Input Validation:
Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code''''s environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE23, and exclude directory separators such as / to avoid CWE36. Use a list of allowable file extensions, which will help to avoid CWE434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.

PHASE:Architecture and Design Operation:STRATEGY:Attack Surface Reduction:
Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server''''s access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.

PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:
Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, email, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.

PHASE:Operation:STRATEGY:Firewall:
Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate

',1);
INSERT INTO "kb_items" VALUES (830,'Inclusion of Web Functionality from an Untrusted Source','Description:

The software includes web functionality (such as a web widget) from another domain, which causes it to operate within the domain of the software, potentially granting total access and control of the software to the untrusted source.

Including third party functionality in a webbased environment is risky, especially if the source of the functionality is untrusted. Even if the third party is a trusted source, the software may still be exposed to attacks and malicious behavior if that trusted source is compromised, or if the code is modified in transmission from the third party to the software. This weakness is common in mashup development on the web, which may include source functionality from other domains. For example, Javascriptbased web widgets may be inserted by using ''''<SCRIPT SRC=http://other.domain.here>'''' tags, which causes the code to run in the domain of the software, not the remote site from which the widget was loaded. As a result, the included code has access to the local DOM, including cookies and other data that the developer might not want the remote site to be able to access. Such dependencies may be desirable, or even required, but sometimes programmers are not aware that a dependency exists.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (831,'Signal Handler Function Associated with Multiple Signals','Description:

The software defines a function that is used as a handler for more than one signal.

While sometimes intentional and safe, when the same function is used to handle multiple signals, a race condition could occur if the function uses any state outside of its local declaration, such as global variables or nonreentrant functions, or has any side effects. An attacker could send one signal that invokes the handler function; in many OSes, this will typically prevent the same signal from invoking the handler again, at least until the handler function has completed execution. However, the attacker could then send a different signal that is associated with the same handler function. This could interrupt the original handler function while it is still executing. If there is shared state, then the state could be corrupted. This can lead to a variety of potential consequences depending on context, including denial of service and code execution. Another rarelyexplored possibility arises when the signal handler is only designed to be executed once (if at all). By sending multiple signals, an attacker could invoke the function more than once. This may generate extra, unintended side effects. A race condition might not even be necessary; the attacker could send one signal, wait until it is handled, then send the other signal.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (832,'Unlock of a Resource that is not Locked','Description:

The software attempts to unlock a resource that is not locked.

Depending on the locking functionality, an unlock of a nonlocked resource might cause memory corruption or other modification to the resource (or its associated metadata that is used for tracking locks).

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (833,'Deadlock','Description:

The software contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (834,'Excessive Iteration','Description:

The software performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.

If the iteration can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. In many cases, a loop does not need to be infinite in order to cause enough resource consumption to adversely affect the software or its host system; it depends on the amount of resources consumed per iteration.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (835,'Loop with Unreachable Exit Condition Infinite Loop','Description:

The program contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.

If the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (836,'Use of Password Hash Instead of Password for Authentication','Description:

The software records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.

Some authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password. As a result, the serverside comparison against a clientside hash does not provide any more security than the use of passwords without hashing.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (838,'Inappropriate Encoding for Output Context','Description:

The software uses or specifies an encoding when generating output to a downstream component, but the specified encoding is not the same as the encoding that is expected by the downstream component.

This weakness can cause the downstream component to use a decoding method that produces different data than what the software intended to send. When the wrong encoding is used  even if closely related  the downstream component could decode the data incorrectly. This can have security consequences when the provided boundaries between control and data are inadvertently broken, because the resulting data could introduce control characters or special elements that were not sent by the software. The resulting data could then be used to bypass protection mechanisms such as input validation, and enable injection attacks. While using output encoding is essential for ensuring that communications between components are accurate, the use of the wrong encoding  even if closely related  could cause the downstream component to misinterpret the output. For example, HTML entity encoding is used for elements in the HTML body of a web page. However, a programmer might use entity encoding when generating output for that is used within an attribute of an HTML tag, which could contain functional Javascript that is not affected by the HTML encoding. While web applications have received the most attention for this problem, this weakness could potentially apply to any type of software that uses a communications stream that could support multiple encodings.

Mitigation:


PHASE:Implementation:STRATEGY:Output Encoding:
Use contextaware encoding. That is, understand which encoding is being used by the downstream component, and ensure that this encoding is used. If an encoding can be specified, do so, instead of assuming that the default encoding is the same as the default being assumed by the downstream component.

PHASE:Architecture and Design:STRATEGY:Output Encoding:
Where possible, use communications protocols or data formats that provide strict boundaries between control and data. If this is not feasible, ensure that the protocols or formats allow the communicating components to explicitly state which encoding/decoding method is being used. Some template frameworks provide builtin support.

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error. Note that some template mechanisms provide builtin support for the appropriate encoding.

',1);
INSERT INTO "kb_items" VALUES (839,'Numeric Range Comparison Without Minimum Check','Description:

The program checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.

Some programs use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption. The use of a negative number in a positiveonly context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for 3 items could cause the application to calculate a negative price and credit the attacker''''s account.

Mitigation:


PHASE:Implementation:STRATEGY:Enforcement by Conversion:
If the number to be used is always expected to be positive, change the variable type from signed to unsigned or size_t.

PHASE:Implementation:STRATEGY:Input Validation:
If the number to be used could have a negative value based on the specification (thus requiring a signed value), but the number should only be positive to preserve code correctness, then include a check to ensure that the value is positive.

',1);
INSERT INTO "kb_items" VALUES (841,'Improper Enforcement of Behavioral Workflow','Description:

The software supports a session in which more than one behavior must be performed by an actor, but it does not properly ensure that the actor performs the behaviors in the required sequence.

By performing actions in an unexpected order, or by omitting steps, an attacker could manipulate the business logic of the software or cause it to enter an invalid state. In some cases, this can also expose resultant weaknesses. For example, a filesharing protocol might require that an actor perform separate steps to provide a username, then a password, before being able to transfer files. If the filesharing server accepts a password command followed by a transfer command, without any username being provided, the software might still perform the transfer. Note that this is different than CWE696, which focuses on when the software performs actions in the wrong sequence; this entry is closely related, but it is focused on ensuring that the actor performs actions in the correct sequence. Workflowrelated behaviors include: Steps are performed in the expected order. Required steps are not omitted. Steps are not interrupted. Steps are performed in a timely fashion.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (842,'Placement of User into Incorrect Group','Description:

The software or the administrator places a user into an incorrect group.

If the incorrect group has more access or privileges than the intended group, the user might be able to bypass intended security policy to access unexpected resources or perform unexpected actions. The accesscontrol system might not be able to detect malicious usage of this group membership.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (843,'Access of Resource Using Incompatible Type Type Confusion','Description:

The program allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.

When the program accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to outofbounds memory access. While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways. This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (862,'Missing Authorization','Description:

The software does not perform an authorization check when an actor attempts to access a resource or perform an action.

Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user''''s privileges and any permissions or other accesscontrol specifications that apply to the resource. When access control checks are not applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.

Mitigation:


PHASE:Architecture and Design:
Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use rolebased access control (RBAC) [REF229] to enforce the roles at the appropriate boundaries. Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.

PHASE:Architecture and Design:
Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient''''s doctor [REF7].

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF233] and the OWASP ESAPI Access Control feature [REF45].

PHASE:Architecture and Design:
For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page. One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.

PHASE:System Configuration Installation:
Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a default deny policy when defining these ACLs.

',1);
INSERT INTO "kb_items" VALUES (863,'Incorrect Authorization','Description:

The software performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.

Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user''''s privileges and any permissions or other accesscontrol specifications that apply to the resource. When access control checks are incorrectly applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.

Mitigation:


PHASE:Architecture and Design:
Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use rolebased access control (RBAC) [REF229] to enforce the roles at the appropriate boundaries. Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.

PHASE:Architecture and Design:
Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient''''s doctor [REF7].

PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:
Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF233] and the OWASP ESAPI Access Control feature [REF45].

PHASE:Architecture and Design:
For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page. One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.

PHASE:System Configuration Installation:
Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a default deny policy when defining these ACLs.

',1);
INSERT INTO "kb_items" VALUES (908,'Use of Uninitialized Resource','Description:

The software uses or accesses a resource that has not been initialized.

When a resource has not been properly initialized, the software may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the software.

Mitigation:


PHASE:Implementation:
Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all required steps.

PHASE:Implementation:
Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization.

PHASE:Implementation:
Avoid race conditions (CWE362) during initialization routines.

PHASE:Build and Compilation:
Run or compile the software with settings that generate warnings about uninitialized variables or data.

',1);
INSERT INTO "kb_items" VALUES (909,'Missing Initialization of Resource','Description:

The software does not initialize a critical resource.

Many resources require initialization before they can be properly used. If a resource is not initialized, it could contain unpredictable or expired data, or it could be initialized to defaults that are invalid. This can have security implications when the resource is expected to have certain properties or values.

Mitigation:


PHASE:Implementation:
Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all specified steps.

PHASE:Implementation:
Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization.

PHASE:Implementation:
Avoid race conditions (CWE362) during initialization routines.

PHASE:Build and Compilation:
Run or compile your software with settings that generate warnings about uninitialized variables or data.

',1);
INSERT INTO "kb_items" VALUES (910,'Use of Expired File Descriptor','Description:

The software uses or accesses a file descriptor after it has been closed.

After a file descriptor for a particular file or device has been released, it can be reused. The code might not write to the original file, since the reused file descriptor might reference a different file or device.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (911,'Improper Update of Reference Count','Description:

The software uses a reference count to manage a resource, but it does not update or incorrectly updates the reference count.

Reference counts can be used when tracking how many objects contain a reference to a particular resource, such as in memory management or garbage collection. When the reference count reaches zero, the resource can be deallocated or reused because there are no more objects that use it. If the reference count accidentally reaches zero, then the resource might be released too soon, even though it is still in use. If all objects no longer use the resource, but the reference count is not zero, then the resource might not ever be released.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (912,'Hidden Functionality','Description:

The software contains functionality that is not documented, not part of the specification, and not accessible through an interface or command sequence that is obvious to the software''''s users or administrators.

Hidden functionality can take many forms, such as intentionally malicious code, Easter Eggs that contain extraneous functionality such as games, developerfriendly shortcuts that reduce maintece or support costs such as hardcoded accounts, etc. From a security perspective, even when the functionality is not intentionally malicious or damaging, it can increase the software''''s attack surface and expose additional weaknesses beyond what is already exposed by the intended functionality. Even if it is not easily accessible, the hidden functionality could be useful for attacks that modify the control flow of the application.

Mitigation:


PHASE:Installation:
Always verify the integrity of the software that is being installed.

PHASE:Testing:
Conduct a code coverage analysis using live testing, then closely inspect any code that is not covered.

',1);
INSERT INTO "kb_items" VALUES (913,'Improper Control of Dynamically Managed Code Resources','Description:

The software does not properly restrict reading from or writing to dynamicallymanaged code resources such as variables, objects, classes, attributes, functions, or executable instructions or statements.

Many languages offer powerful features that allow the programmer to dynamically create or modify existing code, or resources used by code such as variables and objects. While these features can offer significant flexibility and reduce development time, they can be extremely dangerous if attackers can directly influence these code resources in unexpected ways.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
For any externallyinfluenced input, check the input against a white list of acceptable values.

PHASE:Implementation Architecture and Design:STRATEGY:Refactoring:
Refactor the code so that it does not need to be dynamically managed.

',1);
INSERT INTO "kb_items" VALUES (914,'Improper Control of Dynamically Identified Variables','Description:

The software does not properly restrict reading from or writing to dynamicallyidentified variables.

Many languages offer powerful features that allow the programmer to access arbitrary variables that are specified by an input string. While these features can offer significant flexibility and reduce development time, they can be extremely dangerous if attackers can modify unintended variables that have security implications.

Mitigation:


PHASE:Implementation:STRATEGY:Input Validation:
For any externallyinfluenced input, check the input against a white list of internal program variables that are allowed to be modified.

PHASE:Implementation Architecture and Design:STRATEGY:Refactoring:
Refactor the code so that internal program variables do not need to be dynamically identified.

',1);
INSERT INTO "kb_items" VALUES (915,'Improperly Controlled Modification of Dynamically Determined Object Attributes','Description:

The software receives input from an upstream component that specifies multiple attributes, properties, or fields that are to be initialized or updated in an object, but it does not properly control which attributes can be modified.

If the object contains attributes that were only intended for internal use, then their unexpected modification could lead to a vulnerability. This weakness is sometimes known by the languagespecific mechanisms that make it possible, such as mass assignment, autobinding, or object injection.

Mitigation:


PHASE:Implementation:
If available, use features of the language or framework that allow specification of whitelists of attributes or fields that are allowed to be modified. If possible, prefer whitelists over black lists. For applications written with Ruby on Rails, use the attr_accessible (whitelist) or attr_protected (blacklist) macros in each class that may be used in mass assignment.

PHASE:Architecture and Design Implementation:
If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hashbased message authentication code (HMAC) could be used to ensure that data has not been modified.

PHASE:Implementation:STRATEGY:Input Validation:
For any externallyinfluenced input, check the input against a white list of internal object attributes or fields that are allowed to be modified.

PHASE:Implementation Architecture and Design:STRATEGY:Refactoring:
Refactor the code so that object attributes or fields do not need to be dynamically identified, and only expose getter/setter functionality for the intended attributes.

',1);
INSERT INTO "kb_items" VALUES (916,'Use of Password Hash With Insufficient Computational Effort','Description:

The software generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.

Many password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash. Many hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker''''s workload for bruteforce password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a builtin workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massivelyparallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker. There are several properties of a hash scheme that are relevant to its strength against an offline, massivelyparallel attack: The amount of CPU time required to compute the hash (stretching) The amount of memory required to compute the hash (memoryhard operations) Including a random value, along with the password, as input to the hash computation (salting) Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs (oneway hashing) Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (collision resistance) Note that the security requirements for the software may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massivelyparallel attack.

Mitigation:


PHASE:Architecture and Design:
Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (stretching) or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionallyfast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use. Some hash functions that have one or more of these desired properties include bcrypt [REF291], scrypt [REF292], and PBKDF2 [REF293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead. Note that using these functions can have an impact on performance, so they require special consideration to avoid denialofservice attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment''''s needs.:EFFECTIVENESS:High

PHASE:Implementation Architecture and Design:
When using industryapproved techniques, use them correctly. Don''''t cut corners by skipping resourceintensive steps (CWE325). These steps are often essential for preventing common attacks.

',1);
INSERT INTO "kb_items" VALUES (917,'Improper Neutralization of Special Elements used in an Expression Language Statement Expression Language Injection','Description:

The software constructs all or part of an expression language (EL) statement in a Java Server Page (JSP) using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended EL statement before it is executed.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (918,'Server Side Request Forgery SSRF','Description:

The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.

By providing URLs to unexpected hosts or ports, attackers can make it appear that the server is sending the request, possibly bypassing access controls such as firewalls that prevent the attackers from accessing the URLs directly. The server can be used as a proxy to conduct port scanning of hosts in internal networks, use other URLs such as that can access documents on the system (using file://), or use other protocols such as gopher:// or tftp://, which may provide greater control over the contents of requests.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (920,'Improper Restriction of Power Consumption','Description:

The software operates in an environment in which power is a limited resource that cannot be automatically replenished, but the software does not properly restrict the amount of power that its operation consumes.

In environments such as embedded or mobile devices, power can be a limited resource such as a battery, which cannot be automatically replenished by the software itself, and the device might not always be directly attached to a reliable power source. If the software uses too much power too quickly, then this could cause the device (and subsequently, the software) to stop functioning until power is restored, or increase the ficial burden on the device owner because of increased power costs. Normal operation of an application will consume power. However, in some cases, an attacker could cause the application to consume more power than intended, using components such as: Display CPU Disk I/O GPS Sound Microphone USB interface

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (921,'Storage of Sensitive Data in a Mechanism without Access Control','Description:

The software stores sensitive information in a file system or device that does not have builtin access control.

While many modern file systems or devices utilize some form of access control in order to restrict access to data, not all storage mechanisms have this capability. For example, memory cards, floppy disks, CDs, and USB devices are typically made accessible to any user within the system. This can become a problem when sensitive data is stored in these mechanisms in a multiuser environment, because anybody on the system can read or write this data. On Android devices, external storage is typically globally readable and writable by other applications on the device. External storage may also be easily accessible through the mobile device''''s USB connection or physically accessible through the device''''s memory card port.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (922,'Insecure Storage of Sensitive Information','Description:

The software stores sensitive information without properly limiting read or write access by unauthorized actors.

If read access is not properly restricted, then attackers can steal the sensitive information. If write access is not properly restricted, then attackers can modify and possibly delete the data, causing incorrect results and possibly a denial of service.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (923,'Improper Restriction of Communication Channel to Intended Endpoints','Description:

The software establishes a communication channel to (or from) an endpoint for privileged or protected operations, but it does not properly ensure that it is communicating with the correct endpoint.

Attackers might be able to spoof the intended endpoint from a different system or process, thus gaining the same level of access as the intended endpoint. While this issue frequently involves authentication between networkbased clients and servers, other types of communication channels and endpoints can have this weakness.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (924,'Improper Enforcement of Message Integrity During Transmission in a Communication Channel','Description:

The software establishes a communication channel with an endpoint and receives a message from that endpoint, but it does not sufficiently ensure that the message was not modified during transmission.

Attackers might be able to modify the message and spoof the endpoint by interfering with the data as it crosses the network or by redirecting the connection to a system under their control.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (925,'Improper Verification of Intent by Broadcast Receiver','Description:

The Android application uses a Broadcast Receiver that receives an Intent but does not properly verify that the Intent came from an authorized source.

Certain types of Intents, identified by action string, can only be broadcast by the operating system itself, not by thirdparty applications. However, when an application registers to receive these implicit system intents, it is also registered to receive any explicit intents. While a malicious application cannot send an implicit system intent, it can send an explicit intent to the target application, which may assume that any received intent is a valid implicit system intent and not an explicit intent from another application. This may lead to unintended behavior.

Mitigation:


PHASE:Architecture and Design:
Before acting on the Intent, check the Intent Action to make sure it matches the expected System action.

',1);
INSERT INTO "kb_items" VALUES (926,'Improper Export of Android Application Components','Description:

The Android application exports a component for use by other applications, but does not properly restrict which applications can launch the component or access the data it contains.

The attacks and consequences of improperly exporting a component may depend on the exported component: If access to an exported Activity is not restricted, any application will be able to launch the activity. This may allow a malicious application to gain access to sensitive information, modify the internal state of the application, or trick a user into interacting with the victim application while believing they are still interacting with the malicious application. If access to an exported Service is not restricted, any application may start and bind to the Service. Depending on the exposed functionality, this may allow a malicious application to perform unauthorized actions, gain access to sensitive information, or corrupt the internal state of the application. If access to a Content Provider is not restricted to only the expected applications, then malicious applications might be able to access the sensitive data. Note that in Android before 4.2, the Content Provider is automatically exported unless it has been explicitly declared as NOT exported.

Mitigation:


PHASE:Build and Compilation:STRATEGY:Attack Surface Reduction:
If they do not need to be shared by other applications, explicitly mark components with android:exported=false in the application manifest.

PHASE:Build and Compilation:STRATEGY:Attack Surface Reduction:
If you only intend to use exported components between related apps under your control, use android:protectionLevel=signature in the xml manifest to restrict access to applications signed by you.

PHASE:Build and Compilation Architecture and Design:STRATEGY:Attack Surface Reduction:
Limit Content Provider permissions (read/write) as appropriate.

PHASE:Build and Compilation Architecture and Design:STRATEGY:Separation of Privilege:
Limit Content Provider permissions (read/write) as appropriate.

',1);
INSERT INTO "kb_items" VALUES (927,'Use of Implicit Intent for Sensitive Communication','Description:

The Android application uses an implicit intent for transmitting sensitive data to other applications.

Since an implicit intent does not specify a particular application to receive the data, any application can process the intent by using an Intent Filter for that intent. This can allow untrusted applications to obtain sensitive data. There are two variations on the standard broadcast intent, ordered and sticky. Ordered broadcast intents are delivered to a series of registered receivers in order of priority as declared by the Receivers. A malicious receiver can give itself a high priority and cause a denial of service by stopping the broadcast from propagating further down the chain. There is also the possibility of malicious data modification, as a receiver may also alter the data within the Intent before passing it on to the next receiver. The downstream components have no way of asserting that the data has not been altered earlier in the chain. Sticky broadcast intents remain accessible after the initial broadcast. An old sticky intent will be broadcast again to any new receivers that register for it in the future, greatly increasing the chances of information exposure over time. Also, sticky broadcasts cannot be protected by permissions that may apply to other kinds of intents. In addition, any broadcast intent may include a URI that references data that the receiving component does not normally have the privileges to access. The sender of the intent can include special privileges that grant the receiver read or write access to the specific URI included in the intent. A malicious receiver that intercepts this intent will also gain those privileges and be able to read or write the resource at the specified URI.

Mitigation:


PHASE:Implementation:
If the application only requires communication with its own components, then the destination is always known, and an explicit intent could be used.

',1);
INSERT INTO "kb_items" VALUES (939,'Improper Authorization in Handler for Custom URL Scheme','Description:

The software uses a handler for a custom URL scheme, but it does not properly restrict which actors can invoke the handler using the scheme.

Mobile platforms and other architectures allow the use of custom URL schemes to facilitate communication between applications. In the case of iOS, this is the only method to do interapplication communication. The implementation is at the developer''''s discretion which may open security flaws in the application. An example could be potentially dangerous functionality such as modifying files through a custom URL scheme.

Mitigation:


PHASE:Architecture and Design:
Utilize a user prompt popup to authorize potentially harmful actions such as those modifying data or dealing with sensitive information. When designing functionality of actions in the URL scheme, consider whether the action should be accessible to all mobile applications, or if a whitelist of applications to interface with is appropriate.

',1);
INSERT INTO "kb_items" VALUES (940,'Improper Verification of Source of a Communication Channel','Description:

The software establishes a communication channel to handle an incoming request that has been initiated by an actor, but it does not properly verify that the request is coming from the expected origin.

When an attacker can successfully establish a communication channel from an untrusted origin, the attacker may be able to gain privileges and access unexpected functionality.

Mitigation:


PHASE:Architecture and Design:
Use a mechanism that can validate the identity of the source, such as a certificate, and validate the integrity of data to ensure that it cannot be modified in transit using a MITM attack. When designing functionality of actions in the URL scheme, consider whether the action should be accessible to all mobile applications, or if a whitelist of applications to interface with is appropriate.

',1);
INSERT INTO "kb_items" VALUES (941,'Incorrectly Specified Destination in a Communication Channel','Description:

The software creates a communication channel to initiate an outgoing request to an actor, but it does not correctly specify the intended destination for that actor.

Attackers at the destination may be able to spoof trusted servers to steal data or cause a denial of service. There are at least two distinct weaknesses that can cause the software to communicate with an unintended destination: If the software allows an attacker to control which destination is specified, then the attacker can cause it to connect to an untrusted or malicious destination. For example, because UDP is a connectionless protocol, UDP packets can be spoofed by specifying a false source address in the packet; when the server receives the packet and sends a reply, it will specify a destination by using the source of the incoming packet  i.e., the false source. The server can then be tricked into sending traffic to the wrong host, which is effective for hiding the real source of an attack and for conducting a distributed denial of service (DDoS). As another example, serverside request forgery (SSRF) and XML External Entity (XXE) can be used to trick a server into making outgoing requests to hosts that cannot be directly accessed by the attacker due to firewall restrictions. If the software incorrectly specifies the destination, then an attacker who can control this destination might be able to spoof trusted servers. While the most common occurrence is likely due to misconfiguration by an administrator, this can be resultant from other weaknesses. For example, the software might incorrectly parse an email or IP address and send sensitive data to an unintended destination. As another example, an Android application may use a sticky broadcast to communicate with a receiver for a particular application, but since sticky broadcasts can be processed by *any* receiver, this can allow a malicious application to access restricted data that was only intended for a different application.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (942,'Overly Permissive Cross domain Whitelist','Description:

The software uses a crossdomain policy file that includes domains that should not be trusted.

A crossdomain policy file (crossdomain.xml in Flash and clientaccesspolicy.xml in Silverlight) defines a whitelist of domains from which a server is allowed to make crossdomain requests. When making a crossdomain request, the Flash or Silverlight client will first look for the policy file on the target server. If it is found, and the domain hosting the application is explicitly allowed to make requests, the request is made. Therefore, if a crossdomain policy file includes domains that should not be trusted, such as when using wildcards, then the application could be attacked by these untrusted domains. An overly permissive policy file allows many of the same attacks seen in CrossSite Scripting (CWE79). Once the user has executed a malicious Flash or Silverlight application, they are vulnerable to a variety of attacks. The attacker could transfer private information, such as cookies that may include session information, from the victim''''s machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. In many cases, the attack can be launched without the victim even being aware of it.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:
Avoid using wildcards in the crossdomain policy file. Any domain matching the wildcard expression will be implicitly trusted, and can perform twoway interaction with the target server.

PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:
For Flash, modify crossdomain.xml to use metapolicy options such as ''''masteronly'''' or ''''none'''' to reduce the possibility of an attacker planting extraneous crossdomain policy files on a server.

PHASE:Architecture and Design Operation:STRATEGY:Attack Surface Reduction:
For Flash, modify crossdomain.xml to use metapolicy options such as ''''masteronly'''' or ''''none'''' to reduce the possibility of an attacker planting extraneous crossdomain policy files on a server.

',1);
INSERT INTO "kb_items" VALUES (943,'Improper Neutralization of Special Elements in Data Query Logic','Description:

The application generates a query intended to access or manipulate data in a data store such as a database, but it does not neutralize or incorrectly neutralizes special elements that can modify the intended logic of the query.

Depending on the capabilities of the query language, an attacker could inject additional logic into the query to: Modify the intended selection criteria, thus changing which data entities (e.g., records) are returned, modified, or otherwise manipulated Append additional commands to the query Return more entities than intended Return fewer entities than intended Cause entities to be sorted in an unexpected way The ability to execute additional commands or change which entities are returned has obvious risks. But when the application logic depends on the order or number of entities, this can also lead to vulnerabilities. For example, if the application query expects to return only one entity that specifies an administrative user, but an attacker can change which entities are returned, this could cause the logic to return information for a regular user and incorrectly assume that the user has administrative privileges. While this weakness is most commonly associated with SQL injection, there are many other query languages that are also subject to injection attacks, including HTSQL, LDAP, DQL, XQuery, Xpath, and NoSQL languages.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1004,'Sensitive Cookie Without HttpOnly Flag','Description:

The software uses a cookie to store sensitive information, but the cookie is not marked with the HttpOnly flag.

The HttpOnly flag directs compatible browsers to prevent clientside script from accessing cookies. Including the HttpOnly flag in the SetCookie HTTP response header helps mitigate the risk associated with CrossSite Scripting (XSS) where an attacker''''s script code might attempt to read the contents of a cookie and exfiltrate information obtained. When set, browsers that support the flag will not reveal the contents of the cookie to a third party via clientside script executed via XSS.

Mitigation:


PHASE:Implementation:
Leverage the HttpOnly flag when setting a sensitive cookie in a response.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1007,'Insufficient Visual Distinction of Homoglyphs Presented to User','Description:

The software displays information or identifiers to a user, but the display mechanism does not make it easy for the user to distinguish between visually similar or identical glyphs (homoglyphs), which may cause the user to misinterpret a glyph and perform an unintended, insecure action.

Some glyphs, pictures, or icons can be semantically distinct to a program, while appearing very similar or identical to a human user. These are referred to as homoglyphs. For example, the lowercase l (ell) and uppercase I (eye) have different character codes, but these characters can be displayed in exactly the same way to a user, depending on the font. This can also occur between different character sets. For example, the Latin capital letter A and the Greek capital letter &x0391; (Alpha) are treated as distinct by programs, but may be displayed in exactly the same way to a user. Accent marks may also cause letters to appear very similar, such as the Latin capital letter grave mark &65; and its equivalent &x00C1; with the acute accent. Adversaries can exploit this visual similarity for attacks such as phishing, e.g. by providing a link to an attackercontrolled hostname that looks like a hostname that the victim trusts. In a different use of homoglyphs, an adversary may create a back door username that is visually similar to the username of a regular user, which then makes it more difficult for a system administrator to detect the malicious username while reviewing logs.

Mitigation:

PHASE:Implementation:
Use a browser that displays Punycode for IDNs in the URL and status bars, or which color code various scripts in URLs. Due to the prominence of homoglyph attacks, several browsers now help safeguard against this attack via the use of Punycode. For example, Mozilla Firefox and Google Chrome will display IDNs as Punycode if toplevel domains do not restrict which characters can be used in domain names or if labels mix scripts for different languages.

PHASE:Implementation:
Use an email client that has strict filters and prevents messages that mix character sets to end up in a user''''s inbox. Certain email clients such as Google''''s GMail prevent the use of nonLatin characters in email addresses or in links contained within emails. This helps prevent homoglyph attacks by flagging these emails and redirecting them to a user''''s spam folder.
',1);
INSERT INTO "kb_items" VALUES (1009,'audit','Description:

Weaknesses in this category are related to the design and architecture of auditbased components of the system. Frequently these deal with logging user activities in order to identify attackers and modifications to the system. The weaknesses in this category could lead to a degradation of the quality of the audit capability if they are not addressed when designing or implementing a secure architecture.

Mitigation:

Follow the link to the CWE resource to find additional topics that cover this KB item. since it has multiple references.

',1);
INSERT INTO "kb_items" VALUES (1021,'Improper Restriction of Rendered UI Layers or Frames','Description:

The web application does not restrict or incorrectly restricts frame objects or UI layers that belong to another application or domain, which can lead to user confusion about which interface the user is interacting with.

A web application is expected to place restrictions on whether it is allowed to be rendered within frames, iframes, objects, embed or applet elements. Without the restrictions, users can be tricked into interacting with the application when they were not intending to.

Mitigation:


PHASE:Implementation:
The use of XFrameOptions allows developers of web content to restrict the usage of their application within the form of overlays, frames, or iFrames. The developer can indicate from which domains can frame the content. The concept of XFrameOptions is well documented, but implementation of this protection mechanism is in development to cover gaps. There is a need for whitelisting and allowing frames from multiple domains.

PHASE:Implementation:
A developer can use a framebreaker script in each page that should not be framed. This is very helpful for legacy browsers that do not support XFrameOptions security feature previously mentioned. It is also important to note that this tactic has been circumvented or bypassed. Improper usage of frames can persist in the web application through nested frames. The framebreaking script does not intuitively account for multiple nested frames that can be presented to the user.

PHASE:Implementation:
This defenseindepth technique can be used to prevent the improper usage of frames in web applications. It prioritizes the valid sources of data to be loaded into the application through the usage of declarative policies. Based on which implementation of Content Security Policy is in use, the developer should use the frameancestors directive or the framesrc directive to mitigate this weakness. Both directives allow for the placement of restrictions when it comes to allowing embedded content.

',1);
INSERT INTO "kb_items" VALUES (1022,'Use of Web Link to Untrusted Target with window.opener Access','Description:

The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying securitycritical properties of the window.opener object, such as the location property.

When a user clicks a link to an external site (target), the target=_blank attribute causes the target site''''s contents to be opened in a new window or tab, which runs in the same process as the original page. The window.opener object records information about the original page that offered the link. If an attacker can run script on the target page, then they could read or modify certain properties of the window.opener object, including the location property  even if the original and target site are not the same origin. An attacker can modify the location property to automatically redirect the user to a malicious site, e.g. as part of a phishing attack. Since this redirect happens in the original window/tab  which is not necessarily visible, since the browser is focusing the display on the new target page  the user might not notice any suspicious redirection.

Mitigation:


PHASE:Architecture and Design:
Specify in the design that any linked external document must not be granted access to the location object of the calling page.

PHASE:Implementation:
When creating a link to an external document using the <a> tag with a defined target, for example _blank or a named frame, provide the rel attribute with a value noopener noreferrer. If opening the external document in a new window via javascript, then reset the opener by setting it equal to null.

PHASE:Implementation:
Do not use _blank targets. However, this can affect the usability of your application.

',1);
INSERT INTO "kb_items" VALUES (1023,'Incomplete Comparison with Missing Factors','Description:

The software performs a comparison between entities that must consider multiple factors or characteristics of each entity, but the comparison does not include one or more of these factors.

An incomplete comparison can lead to resultant weaknesses, e.g., by operating on the wrong object or making a security decision without considering a required factor.

Mitigation:


PHASE:Testing:
Thoroughly test the comparison scheme before deploying code into production. Perform positive testing as well as negative testing.

',1);
INSERT INTO "kb_items" VALUES (1024,'Comparison of Incompatible Types','Description:

The software performs a comparison between two entities, but the entities are of different, incompatible types that cannot be guaranteed to provide correct results when they are directly compared.

In languages that are strictly typed but support casting/conversion, such as C or C++, the programmer might assume that casting one entity to the same type as another entity will ensure that the comparison will be performed correctly, but this cannot be guaranteed. In languages that are not strictly typed, such as PHP or JavaScript, there may be implicit casting/conversion to a type that the programmer is unaware of, causing unexpected results; for example, the string 123 might be converted to a number type. See examples.

Mitigation:


PHASE:Testing:
Thoroughly test the comparison scheme before deploying code into production. Perform positive testing as well as negative testing.

',1);
INSERT INTO "kb_items" VALUES (1025,'Comparison Using Wrong Factors','Description:

The code performs a comparison between two entities, but the comparison examines the wrong factors or characteristics of the entities, which can lead to incorrect results and resultant weaknesses.

This can lead to incorrect results and resultant weaknesses. For example, the code might inadvertently compare references to objects, instead of the relevant contents of those objects, causing two equal objects to be considered unequal.

Mitigation:


PHASE:Testing:
Thoroughly test the comparison scheme before deploying code into production. Perform positive testing as well as negative testing.

',1);
INSERT INTO "kb_items" VALUES (1037,'Processor Optimization Removal or Modification of Security critical Code','Description:

The developer builds a securitycritical protection mechanism into the software, but the processor optimizes the execution of the program such that the mechanism is removed or modified.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1038,'Insecure Automated Optimizations','Description:

The product uses a mechanism that automatically optimizes code, e.g. to improve a characteristic such as performance, but the optimizations can have an unintended side effect that might violate an intended security assumption.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1039,'Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations','Description:

The product uses an automated mechanism such as machine learning to recognize complex data inputs (e.g. image or audio) as a particular concept or category, but it does not properly detect or handle inputs that have been modified or constructed in a way that causes the mechanism to detect a different, incorrect concept.

When techniques such as machine learning are used to automatically classify input streams, and those classifications are used for securitycritical decisions, then any mistake in classification can introduce a vulnerability that allows attackers to cause the product to make the wrong security decision. If the automated mechanism is not developed or trained with enough input data, then attackers may be able to craft malicious input that intentionally triggers the incorrect classification. Targeted technologies include, but are not necessarily limited to: automated speech recognition automated image recognition For example, an attacker might modify road signs or road surface markings to trick autonomous vehicles into misreading the sign/marking and performing a dangerous action.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1041,'Use of Redundant Code','Description:

The software has multiple functions, methods, procedures, macros, etc. that contain the same code.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. For example, if there are two copies of the same code, the programmer might fix a weakness in one copy while forgetting to fix the same weakness in another copy.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1042,'Static Member Data Element outside of a Singleton Class Element','Description:

The code contains a member element that is declared as static (but not final), in which its parent class element is not a singleton class  that is, a class element that can be used only once in the ''''to'''' association of a Create action.

This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1043,'Data Element Aggregating an Excessively Large Number of Non Primitive Elements','Description:

The software uses a data element that has an excessively large number of subelements with nonprimitive data types such as structures or aggregated objects.

This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of excessively large may vary for each product or developer, CISQ recommends a default of 5 subelements.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1044,'Architecture with Number of Horizontal Layers Outside of Expected Range','Description:

The software''''s architecture contains too many  or too few  horizontal layers.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of expected range may vary for each product or developer, CISQ recommends a default minimum of 4 layers and maximum of 8 layers.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1045,'Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor','Description:

A parent class has a virtual destructor method, but the parent has a child class that does not have a virtual destructor.

This issue can prevent the software from running reliably, since the child might not perform essential destruction operations. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability, such as a memory leak (CWE401).

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1046,'Creation of Immutable Text Using String Concatenation','Description:

The software creates an immutable text string using string concatenation operations.

When building a string via a looping feature (e.g., a FOR or WHILE loop), the use of += to append to the existing string will result in the creation of a new object with each iteration. This programming pattern can be inefficient in comparison with use of text buffer data elements. This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this could be influenced to create performance problem.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1047,'Modules with Circular Dependencies','Description:

The software contains modules in which one module has references that cycle back to itself, i.e., there are circular dependencies.

As an example, with Java, this weakness might indicate cycles between packages. This issue makes it more difficult to maintain the software due to insufficient modularity, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1048,'Invokable Control Element with Large Number of Outward Calls','Description:

The code contains callable control elements that contain an excessively large number of references to other application objects external to the context of the callable, i.e. a FanOut value that is excessively large.

While the interpretation of excessively large FanOut value may vary for each product or developer, CISQ recommends a default of 5 referenced objects. This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1049,'Excessive Data Query Operations in a Large Data Table','Description:

The software performs a data query with a large number of joins and subqueries on a large data table.

This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large data table and large number of joins or subqueries may vary for each product or developer, CISQ recommends a default of 1 million rows for a large data table, a default minimum of 5 joins, and a default minimum of 3 subqueries.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1050,'Excessive Platform Resource Consumption within a Loop','Description:

The software has a loop body or loop condition that contains a control element that directly or indirectly consumes platform resources, e.g. messaging, sessions, locks, or file descriptors.

This issue can make the software perform more slowly. If an attacker can influence the number of iterations in the loop, then this performance problem might allow a denial of service by consuming more platform resources than intended.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1051,'Initialization with Hard Coded Network Resource Configuration Data','Description:

The software initializes data using hardcoded values that act as network resource identifiers.

This issue can prevent the software from running reliably, e.g. if it runs in an environment does not use the hardcoded network resource identifiers. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1052,'Excessive Use of Hard Coded Literals in Initialization','Description:

The software initializes a data element using a hardcoded literal that is not a simple integer or static constant element.

This issue makes it more difficult to modify or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1053,'Missing Documentation for Design','Description:

The product does not have documentation that represents how it is designed.

This issue can make it more difficult to understand and maintain the product. It can make it more difficult and timeconsuming to detect and/or fix vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1054,'Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer','Description:

The code at one architectural layer invokes code that resides at a deeper layer than the adjacent layer, i.e., the invocation skips at least one layer, and the invoked code is not part of a vertical utility layer that can be referenced from any horizontal layer.

This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1055,'Multiple Inheritance from Concrete Classes','Description:

The software contains a class with inheritance from more than one concrete class.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1056,'Invokable Control Element with Variadic Parameters','Description:

A namedcallable or method control element has a signature that supports a variable (variadic) number of parameters or arguments.

This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability. With variadic arguments, it can be difficult or inefficient for manual analysis to be certain of which function/method is being invoked.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1057,'Data Access Operations Outside of Expected Data Manager Component','Description:

The software uses a dedicated, central data manager component as required by design, but it contains code that performs dataaccess operations that do not use this data manager.

This issue can make the software perform more slowly than intended, since the intended central data manager may have been explicitly optimized for performance or other quality characteristics. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1058,'Invokable Control Element in Multi Thread Context with non Final Static Storable or Member Element','Description:

The code contains a function or method that operates in a multithreaded environment but owns an unsafe nonfinal static storable or member data element.

This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1059,'Incomplete Documentation','Description:

The documentation, whether on paper or in electronic form, does not contain descriptions of all the relevant elements of the product, such as its usage, structure, interfaces, design, implementation, configuration, operation, etc.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1060,'Excessive Number of Inefficient Server Side Data Accesses','Description:

The software performs too many data queries without using efficient data processing functionality such as stored procedures.

This issue can make the software perform more slowly due to computational expense. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of too many data queries may vary for each product or developer, CISQ recommends a default maximum of 5 data queries for an inefficient function/procedure.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1061,'Insufficient Encapsulation','Description:

The software does not sufficiently hide the internal representation and implementation details of data or methods, which might allow external components or modules to modify data unexpectedly, invoke unexpected functionality, or introduce dependencies that the programmer did not intend.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1062,'Parent Class with References to Child Class','Description:

The code has a parent class that contains references to a child class, its methods, or its members.

This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1063,'Creation of Class Instance within a Static Code Block','Description:

A static code block creates an instance of a class.

This pattern identifies situations where a storable data element or member data element is initialized with a value in a block of code which is declared as static. This issue can make the software perform more slowly by performing initialization before it is needed. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1064,'Invokable Control Element with Signature Containing an Excessive Number of Parameters','Description:

The software contains a function, subroutine, or method whose signature has an unnecessarily large number of parameters/arguments.

This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of large number of parameters. may vary for each product or developer, CISQ recommends a default maximum of 7 parameters/arguments.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1065,'Runtime Resource Management Control Element in a Component Built to Run on Application Servers','Description:

The application uses deployed components from application servers, but it also uses lowlevel functions/methods for management of resources, instead of the API provided by the application server.

This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1066,'Missing Serialization Control Element','Description:

The software contains a serializable data element that does not have an associated serialization method.

This issue can prevent the software from running reliably, e.g. by triggering an exception. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability. As examples, the serializable nature of a data element comes from a serializable SerializableAttribute attribute in .NET and the inheritance from the java.io.Serializable interface in Java.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1067,'Excessive Execution of Sequential Searches of Data Resource','Description:

The software contains a data query against an SQL table or view that is configured in a way that does not utilize an index and may cause sequential searches to be performed.

This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1068,'Inconsistency Between Implementation and Documented Design','Description:

The implementation of the product is not consistent with the design as described within the relevant documentation.

This issue makes it more difficult to maintain the software due to inconsistencies, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1069,'Empty Exception Block','Description:

An invokable code block contains an exception handling block that does not contain any code, i.e. is empty.

When an exception handling block (such as a Catch and Finally block) is used, but that block is empty, this can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1070,'Serializable Data Element Containing non Serializable Item Elements','Description:

The software contains a serializable, storable data element such as a field or member, but the data element contains member elements that are not serializable.

This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability. As examples, the serializable nature of a data element comes from a serializable SerializableAttribute attribute in .NET and the inheritance from the java.io.Serializable interface in Java.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1071,'Empty Code Block','Description:

The source code contains a block that does not contain any code, i.e., the block is empty.

Empty code blocks can occur in the bodies of conditionals, function or method definitions, exception handlers, etc. While an empty code block might be intentional, it might also indicate incomplete implementation, accidental code deletion, unexpected macro expansion, etc. For some programming languages and constructs, an empty block might be allowed by the syntax, but the lack of any behavior within the block might violate a convention or API in such a way that it is an error.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1072,'Data Resource Access without Use of Connection Pooling','Description:

The software accesses a data resource through a database without using a connection pooling capability.

This issue can make the software perform more slowly, as connection pools allow connections to be reused without the overhead and time consumption of opening and closing a new connection. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1073,'Non SQL Invokable Control Element with Excessive Number of Data Resource Accesses','Description:

The software contains a client with a function or method that contains a large number of data accesses/queries that are sent through a data manager, i.e., does not use efficient database capabilities.

This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large number of data accesses/queries may vary for each product or developer, CISQ recommends a default maximum of 2 data accesses per function/method.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1074,'Class with Excessively Deep Inheritance','Description:

A class has an inheritance level that is too high, i.e., it has a large number of parent classes.

This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of large number of parent classes may vary for each product or developer, CISQ recommends a default maximum of 7 parent classes.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1075,'Unconditional Control Flow Transfer outside of Switch Block','Description:

The software performs unconditional control transfer (such as a goto) in code outside of a branching structure such as a switch block.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1076,'Insufficient Adherence to Expected Conventions','Description:

The product''''s architecture, source code, design, documentation, or other artifact does not follow required conventions.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1077,'Floating Point Comparison with Incorrect Operator','Description:

The code performs a comparison such as an equality test between two float (floating point) values, but it uses comparison operators that do not account for the possibility of loss of precision.

Numeric calculation using floating point values can generate imprecise results because of rounding errors. As a result, two different calculations might generate numbers that are mathematically equal, but have slightly different bit representations that do not translate to the same mathematicallyequal values. As a result, an equality test or other comparison might produce unexpected results. This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1078,'Inappropriate Source Code Style or Formatting','Description:

The source code does not follow desired style or formatting for indentation, white space, comments, etc.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1079,'Parent Class without Virtual Destructor Method','Description:

A parent class contains one or more child classes, but the parent class does not have a virtual destructor method.

This issue can prevent the software from running reliably due to undefined or unexpected behaviors. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1080,'Source Code File with Excessive Number of Lines of Code','Description:

A source code file has too many lines of code.

This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of too many lines of code may vary for each product or developer, CISQ recommends a default threshold value of 1000.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1082,'Class Instance Self Destruction Control Element','Description:

The code contains a class instance that calls the method or function to delete or destroy itself.

For example, in C++, delete this will cause the object to delete itself. This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1083,'Data Access from Outside Expected Data Manager Component','Description:

The software is intended to manage data access through a particular data manager component such as a relational or nonSQL database, but it contains code that performs data access operations without using that component.

When the software has a data access component, the design may be intended to handle all data access operations through that component. If a data access operation is performed outside of that component, then this may indicate a violation of the intended design. This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1084,'Invokable Control Element with Excessive File or Data Access Operations','Description:

A function or method contains too many operations that utilize a data manager or file resource.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of too many operations may vary for each product or developer, CISQ recommends a default maximum of 7 operations for the same data manager or file.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1085,'Invokable Control Element with Excessive Volume of Commented out Code','Description:

A function, method, procedure, etc. contains an excessive amount of code that has been commented out within its body.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of excessive volume may vary for each product or developer, CISQ recommends a default threshold of 2% of commented code.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1086,'Class with Excessive Number of Child Classes','Description:

A class contains an unnecessarily large number of children.

This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of large number of children may vary for each product or developer, CISQ recommends a default maximum of 10 child classes.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1087,'Class with Virtual Method without a Virtual Destructor','Description:

A class contains a virtual method, but the method does not have an associated virtual destructor.

This issue can prevent the software from running reliably, e.g. due to undefined behavior. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1088,'Synchronous Access of Remote Resource without Timeout','Description:

The code has a synchronous call to a remote resource, but there is no timeout for the call, or the timeout is set to infinite.

This issue can prevent the software from running reliably, since an outage for the remote resource can cause the software to hang. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1089,'Large Data Table with Excessive Number of Indices','Description:

The software uses a large data table that contains an excessively large number of indices.

This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large data table and excessively large number of indices may vary for each product or developer, CISQ recommends a default threshold of 1000000 rows for a large table and a default threshold of 3 indices.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1090,'Method Containing Access of a Member Element from Another Class','Description:

A method for a class performs an operation that directly accesses a member element from another class.

This issue suggests poor encapsulation and makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1091,'Use of Object without Invoking Destructor Method','Description:

The software contains a method that accesses an object but does not later invoke the element''''s associated finalize/destructor method.

This issue can make the software perform more slowly by retaining memory and/or other resources longer than necessary. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1092,'Use of Same Invokable Control Element in Multiple Architectural Layers','Description:

The software uses the same control element across multiple architectural layers.

This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1093,'Excessively Complex Data Representation','Description:

The software uses an unnecessarily complex internal representation for its data structures or interrelationships between those structures.

This issue makes it more difficult to understand or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1094,'Excessive Index Range Scan for a Data Resource','Description:

The software contains an index range scan for a large data table, but the scan can cover a large number of rows.

This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large data table and excessive index range may vary for each product or developer, CISQ recommends a threshold of 1000000 table rows and a threshold of 10 for the index range.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1095,'Loop Condition Value Update within the Loop','Description:

The software uses a loop with a control flow condition based on a value that is updated within the body of the loop.

This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1096,'Singleton Class Instance Creation without Proper Locking or Synchronization','Description:

The software implements a Singleton design pattern but does not use appropriate locking or other synchronization mechanism to ensure that the singleton class is only instantiated once.

This issue can prevent the software from running reliably, e.g. by making the instantiation process nonthreadsafe and introducing deadlock (CWE833) or livelock conditions. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1097,'Persistent Storable Data Element without Associated Comparison Control Element','Description:

The software uses a storable data element that does not have all of the associated functions or methods that are necessary to support comparison.

For example, with Java, a class that is made persistent requires both hashCode() and equals() methods to be defined. This issue can prevent the software from running reliably, due to incorrect or unexpected comparison results. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1098,'Data Element containing Pointer Item without Proper Copy Control Element','Description:

The code contains a data element with a pointer that does not have an associated copy or constructor method.

This issue can prevent the software from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1099,'Inconsistent Naming Conventions for Identifiers','Description:

The product''''s code, documentation, or other artifacts do not consistently use the same naming conventions for variables, callables, groups of related callables, I/O capabilities, data types, file names, or similar types of elements.

This issue makes it more difficult to understand and/or maintain the software due to inconsistencies, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1100,'Insufficient Isolation of System Dependent Functions','Description:

The product or code does not isolate systemdependent functionality into separate standalone modules.

This issue makes it more difficult to maintain and/or port the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1101,'Reliance on Runtime Component in Generated Code','Description:

The product uses automaticallygenerated code that cannot be executed without a specific runtime support component.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1102,'Reliance on Machine Dependent Data Representation','Description:

The code uses a data representation that relies on lowlevel data representation or constructs that may vary across different processors, physical machines, OSes, or other physical components.

This issue makes it more difficult to maintain and/or port the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1103,'Use of Platform Dependent Third Party Components','Description:

The product relies on thirdparty software components that do not provide equivalent functionality across all desirable platforms.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1104,'Use of Unmaintained Third Party Components','Description:

The product relies on thirdparty components that are not actively supported or maintained by the original developer or a trusted proxy for the original developer.

Reliance on components that are no longer maintained can make it difficult or impossible to fix significant bugs, vulnerabilities, or quality issues. In effect, unmaintained code can become obsolete. This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1105,'Insufficient Encapsulation of Machine Dependent Functionality','Description:

The product or code uses machinedependent functionality, but it does not sufficiently encapsulate or isolate this functionality from the rest of the code.

This issue makes it more difficult to port or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1106,'Insufficient Use of Symbolic Constants','Description:

The source code uses literal constants that may need to change or evolve over time, instead of using symbolic constants.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1107,'Insufficient Isolation of Symbolic Constant Definitions','Description:

The source code uses symbolic constants, but it does not sufficiently place the definitions of these constants into a more centralized or isolated location.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1108,'Excessive Reliance on Global Variables','Description:

The code is structured in a way that relies too much on using or setting global variables throughout various points in the code, instead of preserving the associated information in a narrower, more local context.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1109,'Use of Same Variable for Multiple Purposes','Description:

The code contains a callable, block, or other code element in which the same variable is used to control more than one unique task or store more than one instance of data.

Use of the same variable for multiple purposes can make it more difficult for a person to read or understand the code, potentially hiding other quality issues. This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1110,'Incomplete Design Documentation','Description:

The product''''s design documentation does not adequately describe control flow, data flow, system initialization, relationships between tasks, components, rationales, or other important aspects of the design.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1111,'Incomplete I O Documentation','Description:

The product''''s documentation does not adequately define inputs, outputs, or system/software interfaces.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1112,'Incomplete Documentation of Program Execution','Description:

The document does not fully define all mechanisms that are used to control or influence how productspecific programs are executed.

This includes environmental variables, configuration files, registry keys, commandline switches or options, or system settings.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1113,'Inappropriate Comment Style','Description:

The source code uses comment styles or formats that are inconsistent or do not follow expected standards for the product.

This issue makes it more difficult to maintain the software due to insufficient legibility, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1114,'Inappropriate Whitespace Style','Description:

The source code contains whitespace that is inconsistent across the code or does not follow expected standards for the product.

This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1115,'Source Code Element without Standard Prologue','Description:

The source code contains elements such as source files that do not consistently provide a prologue or header that has been standardized for the project.

The lack of a prologue can make it more difficult to accurately and quickly understand the associated code. Standard prologues or headers may contain information such as module name, version number, author, date, purpose, function, assumptions, limitations, accuracy considerations, etc. This issue makes it more difficult to maintain the software due to insufficient analyzability, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1116,'Inaccurate Comments','Description:

The source code contains comments that do not accurately describe or explain aspects of the portion of the code with which the comment is associated.

When a comment does not accurately reflect the associated code elements, this can introduce confusion to a reviewer (due to inconsistencies) or make it more difficult and less efficient to validate that the code is implementing the intended behavior correctly. This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1117,'Callable with Insufficient Behavioral Summary','Description:

The code contains a function or method whose signature and/or associated inline documentation does not sufficiently describe the callable''''s inputs, outputs, side effects, assumptions, or return codes.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1118,'Insufficient Documentation of Error Handling Techniques','Description:

The documentation does not sufficiently describe the techniques that are used for error handling, exception processing, or similar mechanisms.

Documentation may need to cover error handling techniques at multiple layers, such as module, executable, compilable code unit, or callable.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1119,'Excessive Use of Unconditional Branching','Description:

The code uses too many unconditional branches (such as goto).

This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1120,'Excessive Code Complexity','Description:

The code is too complex, as calculated using a welldefined, quantitative measure.

This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. This issue can make the software perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1121,'Excessive McCabe Cyclomatic Complexity','Description:

The code contains McCabe cyclomatic complexity that exceeds a desirable maximum.

This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1122,'Excessive Halstead Complexity','Description:

The code is structured in a way that a Halstead complexity measure exceeds a desirable maximum.

A variety of Halstead complexity measures exist, such as program vocabulary size or volume. This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1123,'Excessive Use of Self Modifying Code','Description:

The product uses too much selfmodifying code.

This issue makes it more difficult to understand or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1124,'Excessively Deep Nesting','Description:

The code contains a callable or other code grouping in which the nesting / branching is too deep.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1125,'Excessive Attack Surface','Description:

The product has an attack surface whose quantitative measurement exceeds a desirable maximum.

Originating from software security, an attack surface measure typically reflects the number of input points and output points that can be utilized by an untrusted party, i.e. a potential attacker. A larger attack surface provides more places to attack, and more opportunities for developers to introduce weaknesses. In some cases, this measure may reflect other aspects of quality besides security; e.g., a product with many inputs and outputs may require a large number of tests in order to improve code coverage.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1126,'Declaration of Variable with Unnecessarily Wide Scope','Description:

The source code declares a variable in one scope, but the variable is only used within a narrower scope.

This issue makes it more difficult to understand and/or maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1127,'Compilation with Insufficient Warnings or Errors','Description:

The code is compiled without sufficient warnings enabled, which may prevent the detection of subtle bugs or quality issues.

This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or timeconsuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1164,'Irrelevant Code','Description:

The program contains code that is not essential for execution, i.e. makes no state changes and has no side effects that alter data or control flow, such that removal of the code would have no impact to functionality or correctness.

Irrelevant code could include dead code, initialization that is not used, empty blocks, code that could be entirely removed due to optimization, etc.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1173,'Improper Use of Validation Framework','Description:

The application does not use, or incorrectly uses, an input validation framework that is provided by the source language or an independent library.

Many modern coding languages provide developers with input validation frameworks to make the task of input validation easier and less errorprone. These frameworks will automatically check all input against specified criteria and direct execution to error handlers when invalid input is received. The improper use (i.e., an incorrect implementation or missing altogether) of these frameworks is not directly exploitable, but can lead to an exploitable condition if proper input validation is not performed later in the application. Not using provided input validation frameworks can also hurt the maintainability of code as future developers may not recognize the downstream input validation being used in the place of the validation framework.

Mitigation:


PHASE:Implementation:
Properly use provided input validation frameworks.

',1);
INSERT INTO "kb_items" VALUES (1174,'ASP.NET Misconfiguration: Improper Model Validation','Description:

The ASP.NET application does not use, or incorrectly uses, the model validation framework.



Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1176,'Inefficient CPU Computation','Description:

The program performs CPU computations using algorithms that are not as efficient as they could be for the needs of the developer, i.e., the computations can be optimized further.

This issue can make the software perform more slowly, possibly in ways that are noticeable to the users. If an attacker can influence the amount of computation that must be performed, e.g. by triggering worstcase complexity, then this performance problem might introduce a vulnerability.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1177,'Use of Prohibited Code','Description:

The software uses a function, library, or third party component that has been explicitly prohibited, whether by the developer or the customer.

The developer  or customers  may wish to restrict or eliminate use of a function, library, or third party component for any number of reasons, including real or suspected vulnerabilities; difficulty to use securely; export controls or license requirements; obsolete or poorlymaintained code; internal code being scheduled for deprecation; etc. To reduce risk of vulnerabilities, the developer might maintain a list of banned functions that programmers must avoid using because the functions are difficult or impossible to use securely. This issue can also make the software more costly and difficult to maintain.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1188,'Insecure Default Initialization of Resource','Description:

The software initializes or sets a resource with a default that is intended to be changed by the administrator, but the default is not secure.

Developers often choose default values that leave the software as open and easy to use as possible outofthebox, under the assumption that the administrator can (or should) change the default value. However, this easeofuse comes at a cost when the default is insecure and the administrator does not change it.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1189,'Improper Isolation of Shared Resources on System on Chip SoC','Description:

The product does not properly isolate shared resources between trusted and untrusted agents.

A SystemOnChip (SoC) has a lot of functionality, but may have a limited number of pins or pads. A pin can only perform one function at a time. However, it can be configured to perform multiple different functions. This technique is called pin multiplexing. Similarly, several resources on the chip may be shared to multiplex and support different features or functions. When such resources are shared between trusted and untrusted agents, untrusted agents may be able to access the assets intended to be accessed only by the trusted agents.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
When sharing resources, avoid mixing agents of varying trust levels. Group untrusted agents together to access when sharing a resource. Similarly, group trusted agents (at same trust level).

',1);
INSERT INTO "kb_items" VALUES (1190,'DMA Device Enabled Too Early in Boot Phase','Description:

The product enables a Direct Memory Access (DMA) capable device before the security configuration settings are established, which allows an attacker to extract data from or gain privileges on the product.

DMA is included in a number of devices because it allows data transfer between the computer and the connected device, using direct hardware access to read or write directly to main memory without any OS interaction. An attacker could exploit this to access secrets. Several virtualizationbased mitigations have been introduced to thwart DMA attacks. These are usually configured/setup during boot time. However, certain IPs that are powered up before boot is complete (known as early boot IPs) may be DMA capable. Such IPs, if not trusted, could launch DMA attacks and gain access to assets that should otherwise be protected.

Mitigation:


PHASE:Architecture and Design:
Utilize an IOMMU to orchestrate IO access from the start of the boot process.

',1);
INSERT INTO "kb_items" VALUES (1191,'Exposed Chip Debug Interface With Insufficient Access Control','Description:

The chip does not implement or does not correctly enforce access control on the debug interface, thus allowing an attacker to exercise the debug interface to access a portion of the chip internal registers that typically would not be exposed.

Integrated circuits can expose the chip internals through a scan chain interconnected through internal registers etc., through scan flipflops. A Joint Test Action Group (JTAG) compatible test access port usually provides access to this scan chain for debugging the chip. Since almost every asset in the chip can be accessed over this debug interface, chip manufacturers typically insert some form of passwordbased or challengeresponse based access control mechanisms to prevent misuse. This mechanism is implemented in addition to onchip protections that are already present. If this debug access control is not implemented or the access control check is not implemented properly, or if the hardware does not clear secret keys, etc., when debug more is entered, an attacker may be able to bypass onchip access control mechanisms through debug features/interfaces.

Mitigation:


PHASE:Architecture and Design:STRATEGY:Separation of Privilege:
Implement an access control mechanism to exercise the debug interface in order to control and observe securitysensitive chip internals. Password checking logic should be resistant to timing attacks. Securitysensitive data stored in registers, such as keys, etc. should be cleared when entering debug mode.

',1);
INSERT INTO "kb_items" VALUES (1193,'Power On of Untrusted Execution Core Before Enabling Fabric Access Control','Description:

The product enables components that contain untrusted firmware before memory and fabric access controls have been enabled.

After initial reset, SystemonChip (SoC) fabric access controls and other security features need to be programmed by trusted firmware as part of the boot sequence. If untrusted IPs or peripheral microcontrollers are enabled first, then the untrusted component can master transactions on the hardware bus and target memory or other assets to compromise the SoC boot firmware.

Mitigation:


PHASE:Architecture and Design:
The boot sequence should enable fabric access controls and memory protections before enabling thirdparty hardware IPs and peripheral microcontrollers that use untrusted firmware.

',1);
INSERT INTO "kb_items" VALUES (1209,'Failure to Disable Reserved Bits','Description:

The reserved bits in a hardware design are not disabled prior to production. Typically, reserved bits are used for future capabilities and should not support any functional logic in the design. However, designers might covertly use these bits to debug or further develop new capabilities in production hardware. Adversaries with access to these bits will write to them in hopes of compromising hardware state.

Reserved bits are labeled as such so they can be allocated for a later purpose. They are not to do anything in the current design. However, designers might want to use these bits to debug or control/configure a future capability to help minimize time to market (TTM). If the logic being controlled by these bits is still enabled in production, an adversary could use the logic to induce unwanted/unsupported behavior in the hardware.

Mitigation:


PHASE:Architecture and Design Implementation:
Include a feature disable

PHASE:Integration:
Any writes to these reserve bits are blocked (e.g., ignored, accessprotected, etc.), or an exception can be asserted.

',1);
INSERT INTO "kb_items" VALUES (1220,'Insufficient Granularity of Access Control','Description:

The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the securitysensitive assets.

Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically accesscontrolled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary accesscontrol protection. A common weakness that can exist in such protection schemes is that access controls or policies are not granular enough. This condition allows agents beyond trusted agents to access assets and could lead to a loss of functionality or the ability to set up the device securely. This further results in security risks from leaked, sensitive, key material to modification of device configuration.

Mitigation:


PHASE:Architecture and Design Implementation Testing:
Accesscontrolpolicy protections must be reviewed for design inconsistency and common weaknesses. Accesscontrolpolicy definition and programming flow must be tested in presilicon, postsilicon testing.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1221,'Incorrect Register Defaults or Module Parameters','Description:

Hardware description language code incorrectly defines register defaults or hardware IP parameters to insecure values.

Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. Hardware descriptive languages also support definition of parameter variables, which can be defined in code during instantiation of the hardware IP module. Such parameters are generally used to configure a specific instance of a hardware IP in the design. The system security settings of a hardware design can be affected by incorrectly defined default values or IP parameters. The hardware IP would be in an insecure state at power reset, and this can be exposed or exploited by untrusted software running on the system. Both register defaults and parameters are hardcoded values, which cannot be changed using software or firmware patches but must be changed in hardware silicon. Thus, such security issues are considerably more difficult to address later in the lifecycle. Hardware designs can have a large number of such parameters and register defaults settings, and it is important to have design tool support to check these settings in an automated way and be able to identify which settings are security sensitive.

Mitigation:


PHASE:Architecture and Design:
During hardware design all the system parameters and register defaults must be reviewed to identify security sensitive settings

PHASE:Implementation:
The default values of these security sensitive settings need to be defined as part of the design review phase.

PHASE:Testing:
Testing phase should use automated tools to test that values are configured per design specifications.

',1);
INSERT INTO "kb_items" VALUES (1222,'Insufficient Granularity of Address Regions Protected by Register Locks','Description:

The product defines a large address region protected from modification by the same register lock control bit. This results in a conflict between the functional requirement that some addresses need to be writable by software during operation and the security requirement that the system configuration lock bit must be set during the boot process.

Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. In hardware design, this is commonly implemented using a programmable lock bit which enables/disables writing to a protected set of registers or address regions. When the programmable lock bit is set, the relevant address region can be implemented as a hardcoded value in hardware logic that cannot be changed later. A problem can arise wherein the protected region definition is not granular enough. After the programmable lock bit has been set, then this new functionality cannot be implemented without change to the hardware design.

Mitigation:


PHASE:Architecture and Design:
The defining of protected locked registers should be reviewed or tested early in the design phase with software teams to ensure software flows are not blocked by the security locks. As an alternative to using register lock control bits and fixed access control regions, the hardware design could use programmable security access control configuration so that device trusted firmware can configure and change the protected regions based on software usage and security models.

',1);
INSERT INTO "kb_items" VALUES (1223,'Race Condition for Write Once Attributes','Description:

A writeonce register in hardware design is programmable by an untrusted software component earlier than the trusted software component, resulting in a race condition issue.

Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make them writeonce. This means the hardware implementation only allows writing to such registers once, and they become readonly after having been written once by software. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings. Implementation issues in hardware design of such controls can expose such registers to a race condition security flaw. For example, consider a hardware design that has two different software/firmware modules executing in parallel. One module is trusted (module A) and another is untrusted (module B). In this design it could be possible for Module B to send write cycles to the writeonce register before Module A. Since the field is writeonce the programmed value from Module A will be ignored and the preempted value programmed by Module B will be used by hardware.

Mitigation:


PHASE:Architecture and Design:
During hardware design all register writeonce or sticky fields must be evaluated for proper configuration.

PHASE:Testing:
The testing phase should use automated tools to test that values are not reprogrammable and that writeonce fields lock on writing zeros.

',1);
INSERT INTO "kb_items" VALUES (1224,'Improper Restriction of Write Once Bit Fields','Description:

The hardware design control register sticky bits or writeonce bit fields are improperly implemented, such that they can be reprogrammed by software.

Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to define default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make the settings writeonce or sticky. This allows writing to such registers only once, whereupon they become readonly. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings. Failure to implement writeonce restrictions in hardware design can expose such registers to being reprogrammed by software and written multiple times. For example, writeonce fields could be implemented to only be writeprotected if they have been set to value 1, wherein they would work as write1once and not writeonce.

Mitigation:


PHASE:Architecture and Design:
During hardware design all register writeonce or sticky fields must be evaluated for proper configuration.

PHASE:Testing:
The testing phase should use automated tools to test that values are not reprogrammable and that writeonce fields lock on writing zeros.

',1);
INSERT INTO "kb_items" VALUES (1229,'Creation of Emergent Resource','Description:

The product manages resources or behaves in a way that indirectly creates a new, distinct resource that can be used by attackers in violation of the intended policy.

A product is only expected to behave in a way that was specifically intended by the developer. Resource allocation and management is expected to be performed explicitly by the associated code. However, in systems with complex behavior, the product might indirectly produce new kinds of resources that were never intended in the original design. For example, a covert channel is a resource that was never explicitly intended by the developer, but it is useful to attackers. Parasitic computing, while not necessarily malicious in nature, effectively tricks a product into performing unintended computations on behalf of another party.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1230,'Exposure of Sensitive Information Through Metadata','Description:

The product prevents direct access to a resource containing sensitive information, but it does not sufficiently limit access to metadata that is derived from the original, sensitive information.

Developers might correctly prevent unauthorized access to a database or other resource containing sensitive information, but they might not consider that portions of the original information might also be recorded in metadata, search indices, statistical reports, or other resources. If these resources are not also restricted, then attackers might be able to extract some or all of the original information, or otherwise infer some details. For example, an attacker could specify search terms that are known to be unique to a particular person, or view metadata such as activity or creation dates in order to identify usage patterns.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1231,'Improper Implementation of Lock Protection Registers','Description:

The product incorrectly implements register lock bit protection features such that protected controls can be programmed even after the lock has been set.

In integrated circuits and hardware IPs, device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. Design or coding errors in the implementation of the lock bit protection feature may allow the lock bit to be modified or cleared by software after being set to unlock the system.

Mitigation:


PHASE:Architecture and Design Implementation Testing:
Security lock bit protections must be reviewed for design inconsistency and common weaknesses. Security lock programming flow and lock properties must be tested in presilicon, postsilicon testing.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1232,'Improper Lock Behavior After Power State Transition','Description:

The product implements register lock bit protection features with the intent to disable changes to system configuration after the lock is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes).

Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. In hardware design this is commonly implemented using a programmable lock bit, which when set disables writes to a protected set of registers or address regions. Some common weaknesses that can exist in such a protection scheme is that the lock gets cleared, the values of the protected registers get reset, or the lock become programmable after a power state transition.

Mitigation:


PHASE:Architecture and Design Implementation Testing:
Security Lock bit protections must be reviewed for behavior across supported power state transitions. Security lock programming flow and lock properties must be tested in presi, postsi testing, including testing these across power transitions.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1233,'Improper Hardware Lock Protection for Security Sensitive Controls','Description:

The product implements a register lock bit protection feature that permits security sensitive controls to modify the protected configuration.

Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If any system registers/controls that can modify the protected configuration are not writeprotected by the lock, they can then be leveraged by software to modify the protected configuration.

Mitigation:


PHASE:Architecture and Design Implementation Testing:
Security lock bit protections must be reviewed for design inconsistency and common weaknesses. Security lock bit protections must be reviewed common weaknesses. Security lock programming flow and lock properties must be tested in presi, postsi testing.

',1);
INSERT INTO "kb_items" VALUES (1234,'Hardware Internal or Debug Modes Allow Override of Locks','Description:

The product implements register lock bit protection features that may permit security sensitive controls to modify system configuration after the lock is set through internal modes or debug features.

In integrated circuits and hardware IPs, device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, they may allow modification of the lock protection.

Mitigation:


PHASE:Architecture and Design Implementation Testing:
Security Lock bit protections must be reviewed for any bypass/override modes supported. Any supported override modes either must be removed, or these modes should be protected using features like secure authenticated, authorized debug modes. Security lock programming flow and lock properties must be tested in presi, postsi testing.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1235,'Incorrect Use of Autoboxing and Unboxing for Performance Critical Operations','Description:

The code uses boxed primitives, which may introduce inefficiencies into performancecritical operations.

Languages such as Java and C support automatic conversion through their respective compilers from primitive types into objects of the corresponding wrapper classes, and vice versa. For example, a compiler might convert an int to Integer (called autoboxing) or an Integer to int (called unboxing). This eliminates forcing the programmer to perform these conversions manually, which makes the code cleaner. However, this feature comes at a cost of performance and can lead to resource exhaustion and impact availability when used with generic collections. Therefore, they should not be used for scientific computing or other performance critical operations. They are only suited to support impedance mismatch between reference types and primitives.

Mitigation:


PHASE:Implementation:
Use of boxed primitives should be limited to certain situations such as when calling methods with typed parameters. Examine the use of boxed primitives prior to use. Use SparseArrays or ArrayMap instead of HashMap to avoid performance overhead.

',1);
INSERT INTO "kb_items" VALUES (1236,'Improper Neutralization of Formula Elements in a CSV File','Description:

The software saves userprovided information into a CommaSeparated Value (CSV) file, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as a command when the file is opened by spreadsheet software.

Userprovided data is often saved to traditional databases. This data can be exported to a CSV file, which allows users to read the data using spreadsheet software such as Excel, Numbers, or Calc. This software interprets entries beginning with ''''='''' as formulae, which are then executed by the spreadsheet software. The software''''s formula language often allows methods to access hyperlinks or the local command line, and frequently allows enough characters to invoke an entire script. Attackers can populate data fields which, when saved to a CSV file, may attempt information exfiltration or other malicious activity when automatically executed by the spreadsheet software.

Mitigation:


PHASE:Implementation:
When generating CSV output, ensure that formulasensitive metacharacters are effectively escaped or removed from all data before storage in the resultant CSV. Risky characters include ''''='''' (equal), ''''+'''' (plus), '''''''' (minus), and ''''@'''' (at).:EFFECTIVENESS:Moderate

PHASE:Implementation:
If a field starts with a formula character, prepend it with a '''' (single apostrophe), which prevents Excel from executing the formula.:EFFECTIVENESS:Moderate

PHASE:Architecture and Design:
Certain implementations of spreadsheet software might disallow formulae from executing if the file is untrusted, or if the file is not authored by the current user.:EFFECTIVENESS:Limited

',1);
INSERT INTO "kb_items" VALUES (1239,'Improper Zeroization of Hardware Register','Description:

The hardware product does not properly clear sensitive information from builtin registers when the user of the hardware block changes.

Hardware logic operates on data stored in registers local to the hardware block. Most hardware IPs, including cryptographic accelerators, rely on registers to buffer I/O, store intermediate values, and interface with software. The result of this is that sensitive information, such as passwords or encryption keys, can exist in locations not transparent to the user of the hardware logic. When a different entity obtains access to the IP due to a change in operating mode or conditions, the new entity can extract information belonging to the previous user if no mechanisms are in place to clear register contents. It is important to clear information stored in the hardware if a physical attack on the product is detected, or if the user of the hardware block changes. The process of clearing register contents in a hardware IP is referred to as zeroization in standards for cryptographic hardware modules such as FIPS1402 [REF267].

Mitigation:


PHASE:Architecture and Design:
Every register potentially containing sensitive information must have a policy specifying how and when information is cleared, in addition to clarifying if it is the responsibility of the hardware logic or IP user to initiate the zeroization procedure at the appropriate time.

',1);
INSERT INTO "kb_items" VALUES (1240,'Use of a Risky Cryptographic Primitive','Description:

The product implements a cryptographic algorithm using a nonstandard or unproven cryptographic primitive.

Cryptographic algorithms (or Cryptographic systems) depend on cryptographic primitives as their basic building blocks. As a result, cryptographic primitives are designed to do one very specific task in a precisely defined and highly reliable fashion. For example, one can declare that a specific crypto primitive (like an encryption routine) can only be broken after trying out N different inputs (the larger the value of N, the stronger the crypto). If a vulnerability is found that leads to breaking this primitive in significantly less than N attempts, then the specific cryptographic primitive is considered broken, and the entirety of the cryptographic algorithm (or the cryptographic system) is now considered insecure. Thus, even breaking a seemingly small cryptographic primitive is sufficient to render the whole system vulnerable. Cryptographic primitives are products of extensive reviews from cryptographers, industry, and government entities looking for any possible flaws. However, over time even wellknown cryptographic primitives lose their compliance status with emergence of novel attacks that might either defeat the algorithm or reduce its robustness significantly. If adhoc cryptographic primitives are implemented, it is almost certain that such implementation will be vulnerable to attacks resulting in the exposure of sensitive information and/or other consequences.

Mitigation:


PHASE:Architecture and Design:
Follow these good cryptography practices: Do not create your own crypto algorithms. They will likely be exposed to attacks that are wellunderstood by cryptographers. Reverse engineering techniques are mature. As with all cryptographic mechanisms, the source code should be available for analysis. If the algorithm can be compromised when attackers find out how it works, then it is especially weak. Do not use outdated/notcompliant cryptography algorithms. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. Do not use LFSR as a substitute for proper Random Number Generator IPs. Do not use checksum as a substitute for proper Hashes. Design the hardware at the IP level so that one cryptographic algorithm can be replaced with another in the next generation. Use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. Do not store keys in areas accessible to untrusted agents. Carefully manage and protect cryptographic keys (see CWE320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant. Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industrystandard implementations will save development time and might be more likely to avoid errors that can occur during implementation of cryptographic algorithms. When using industryapproved techniques, use them correctly. Don''''t cut corners by skipping resourceintensive steps (CWE325). These steps are often essential for preventing common attacks.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1241,'Use of Predictable Algorithm in Random Number Generator','Description:

The product requires a true random number but uses an algorithm that is predictable and generates a pseudorandom number.



Mitigation:


PHASE:Architecture and Design:
Leverage wellknown true random number generation techniques.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1242,'Inclusion of Undocumented Features or Chicken Bits','Description:

The chip includes chicken bits or undocumented features that can create entry points for unauthorized actors.

A common design practice is to use chicken bits, which are bits on a chip that can be used to disable certain functional security features. They can facilitate quick identification and isolation of faulty components, features that negatively affect performance, or features that do not provide the required controllability for debug and test. Another way to achieve this is through implementation of undocumented features. An attacker might exploit these interfaces for unauthorized access.

Mitigation:


PHASE:Architecture and Design Implementation:
Do not implement chicken bits. If implemented, ensure that they are disabled in production devices. Document all interfaces to the chip.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1243,'Exposure of Security Sensitive Fuse Values During Debug','Description:

The product exposes securitysensitive values stored in fuses during debug.

Several securitysensitive values are blown as fuses in a chip to be used during earlyboot flows or later at runtime. Examples of these securitysensitive values include root keys, encryption keys, manufacturingspecific information, chipmanufacturerspecific information, and originalequipmentmanufacturer (OEM) data. After the chip is powered on, these values are sensed from fuses and stored in temporary locations such as registers and local memories. These locations are typically accesscontrol protected from untrusted agents capable of accessing them. Even to trusted agents, only readaccess is provided. However, these locations are not blocked during debug flows, allowing an untrusted debugger to access these assets and compromise system security.

Mitigation:


PHASE:Architecture and Design Implementation:
When in debug mode, disable access to securitysensitive values sensed from fuses and stored in temporary locations.

',1);
INSERT INTO "kb_items" VALUES (1244,'Improper Authorization on Physical Debug and Test Interfaces','Description:

The product''''s physical debug and test interface protection does not block untrusted agents, resulting in unauthorized access to and potentially control of sensitive assets.

If the product implements accesscontrol protection on the debug and test interface, a debugger is typically required to enter either a valid response to a challenge provided by the authorization logic or, alternatively, enter the right password in order to exercise the debug and test interface. However, if this protection mechanism does not exclude all untrusted, debug agents, an attacker could access/control securitysensitive registers.

Mitigation:


PHASE:Architecture and Design Implementation:
For securitysensitive assets accessible over debug/test interfaces, only allow trusted agents.

',1);
INSERT INTO "kb_items" VALUES (1245,'Improper Finite State Machines FSMs in Hardware Logic','Description:

Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim''''s system.

The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don''''t cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.

Mitigation:


PHASE:Architecture and Design Implementation:
Define all possible states and handle all unused states through default statements. Ensure that system defaults to a secure state.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1246,'Improper Write Handling in Limited write Non Volatile Memories','Description:

The product does not implement or incorrectly handles the implementation of write operations in limitedwrite nonvolatile memories.

Nonvolatile memories such as NAND Flash, EEPROM, etc. have individually erasable segments, each of which can be put through a limited number of program/erase or write cycles. For example, the device can only endure a limited number of writes, after which the device becomes unreliable. In order to wear out the cells in a uniform manner, nonvolatile memory and storage products based on the abovementioned technologies implement a technique called wear leveling. Once a set threshold is reached, wear leveling maps writes of a logical block to a different physical block. This prevents a single physical block from prematurely failing due to a high concentration of writes. If wear leveling is improperly implemented, attackers can execute a write virus and cause the storage to become unreliable much faster than the minimally guaranteed platform lifetime.

Mitigation:


PHASE:Architecture and Design Implementation Testing:
Include secure wear leveling algorithms and ensure that it cannot be bypassed by known write viruses.:EFFECTIVENESS:High

',1);
INSERT INTO "kb_items" VALUES (1247,'Missing Protection Against Voltage and Clock Glitches','Description:

The product does not contain the necessary additional circuitry or sensors to detect and mitigate voltage and clock glitches.

A product might support security features such as secure boot that are supported through hardware and firmware implementation. This involves establishing a chain of trust, starting with an immutable root of trust by checking the signature of the next stage (culminating with the OS and runtime software) against a golden value before transferring control. The intermediate stages typically set up the system in a secure state by configuring several access control settings. Similarly, any passwordchecking logic for exercising the debug interface, etc. can implemented in hardware, firmware, or both. This implementation needs to be robust against fault attacks such as voltage glitches and clock glitches that an attacker may leverage to compromise the system.

Mitigation:


PHASE:Architecture and Design Implementation:
At the circuitlevel, using Tunable Replica Circuits (TRCs) or special flipflops such as Razor flipflops helps mitigate glitches. At SoC or platform level, level sensors can be implemented to detect glitches. Implementing redundancy in securitysensitive code (e.g., where checks are performed) helps in mitigating glitches.

',1);
INSERT INTO "kb_items" VALUES (1248,'Semiconductor Defects in Hardware Logic with Security Sensitive Implications','Description:

The securitysensitive hardware module contains semiconductor defects.

A semiconductor device can fail for various reasons. While some are manufacturing and packaging defects, the rest are due to prolonged use or usage under extreme conditions. Some mechanisms that lead to semiconductor defects include encapsulation failure, dieattach failure, wirebond failure, bulksilicon defects, oxidelayer faults, aluminummetal faults (including electromigration, corrosion of aluminum, etc.), and thermal/electrical stress. These defects manifest as faults on chipinternal signals or registers, have the effect of inputs, outputs, or intermediate signals being always 0 or always 1, and do not switch as expected. If such faults occur in securitysensitive hardware modules, security guarantees offered by the device will be compromised.

Mitigation:


PHASE:Testing:
While semiconductormanufacturing companies implement several mechanisms to continuously improve the semiconductor manufacturing process to ensure reduction of defects, some defects can only be fixed after manufacturing. Postmanufacturing testing of silicon die is critical. Fault models such as stuckat0 or stuckat1 must be used to develop postmanufacturing test cases and achieve good coverage. Once the silicon packaging is done, extensive postsilicon testing must be performed to ensure that hardware logic implementing security functionalities is defectfree.

PHASE:Operation:
Operating the hardware outside device specification, such as at extremely high temperatures, voltage, etc., accelerates semiconductor degradation and results in defects. When these defects manifest as faults in securitycritical, hardware modules, it results in compromise of security guarantees. Thus, operating the device within the specification is important.

',1);
INSERT INTO "kb_items" VALUES (1249,'Application Level Admin Tool with Inconsistent View of Underlying Operating System','Description:

The product provides an application for administrators to manage parts of the underlying operating system, but the application does not accurately identify all of the relevant entities or resources that exist in the OS; that is, the application''''s model of the OS''''s state is inconsistent with the OS''''s actual state.

Many products provide webbased applications or other software for managing the underlying operating system. This is common with cloud, network access devices, home networking, and other systems. When the management tool does not accurately represent what is in the OS  such as user accounts  then the administrator might not see suspicious activities that would be noticed otherwise. For example, numerous systems utilize a web frontend for administrative control. They also offer the ability to add, alter, and drop users with various privileges as it relates to the functionality of the system. A potential architectural weakness may exist where the user information reflected in the web interface does not mirror the users in the underlying operating system. Many web UI or REST APIs use the underlying operating system for authentication; the system''''s logic may also track an additional set of user capabilities within configuration files and datasets for authorization capabilities. When there is a discrepancy between the user information in the UI or REST API''''s interface system and the underlying operating system''''s user listing, this may introduce a weakness into the system. For example, if an attacker compromises the OS and adds a new user account  a ghost account  then the attacker could escape detection if the management tool does not list the newlyadded account. This discrepancy could be exploited in several ways: A rogue admin could insert a new account into a system that will persist if they are terminated or wish to take action on a system that cannot be directly associated with them. An attacker can leverage a separate command injection attack available through the web interface to insert a ghost account with shell privileges such as ssh. An attacker can leverage existing web interface APIs, manipulated in such a way that a new user is inserted into the operating system, and the user web account is either partially created or not at all. An attacker could create an admin account which is viewable by an administrator, use this account to create the ghost account, delete logs and delete the first created admin account. Many of these attacker scenarios can be realized by leveraging separate vulnerabilities related to XSS, command injection, authentication bypass, or logic flaws on the various systems.

Mitigation:


PHASE:Architecture and Design:
Ensure that the admin tool refreshes its model of the underlying OS on a regular basis, and note any inconsistencies with configuration files or other data sources that are expected to have the same data.

',1);
INSERT INTO "kb_items" VALUES (1250,'Improper Preservation of Consistency Between Independent Representations of Shared State','Description:

The product has or supports multiple distributed components or subsystems that are each required to keep their own local copy of shared data  such as state or cache  but the product does not ensure that all local copies remain consistent with each other.

In highly distributed environments, or on systems with distinct physical components that operate independently, there is often a need for each component to store and update its own local copy of key data such as state or cache, so that all components have the same view of the overall system and operate in a coordinated fashion. For example, users of a social media service or a massively multiplayer online game might be using their own personal computers while also interacting with different physical hosts in a globally distributed service, but all participants must be able to have the same view of the world. Alternately, a processor''''s Memory Management Unit (MMU) might have shadow MMUs to distribute its workload, and all shadow MMUs are expected to have the same accessible ranges of memory. In such environments, it becomes critical for the product to ensure that this shared state is consistently modified across all distributed systems. If state is not consistently maintained across all systems, then critical transactions might take place out of order, or some users might not get the same data as other users. When this inconsistency affects correctness of operations, it can introduce vulnerabilities in mechanisms that depend on consistent state.

Mitigation:
',1);
INSERT INTO "kb_items" VALUES (1251,'Mirrored Regions with Different Values','Description:

The product''''s architecture mirrors regions without ensuring that their contents always stay in sync.

Having mirrored regions with different values might result in the exposure of sensitive information and/or other consequences, including loss of access control. Due to architectural and performance constraints, one might need to duplicate a resource. The most common example of doing this in computer architecture is the concept of cache, which keeps a local copy of the data element in memory, because the time to access the memory (which is located far off from the computing core) is significantly longer compared to the time it takes to access a local copy (cache). Thus, keeping a local copy of some distant entity provides significant performance improvement. Unfortunately, this improvement also comes with a downside, since the product needs to ensure that the local copy always mirrors the original copy truthfully. If they get out of sync somehow, the computational result is no longer true. In designing hardware, memory is not the only thing that gets mirrored. There are many other entities that get mirrored, too: registers, memory regions, and, in some cases, even whole units. For example, for a multicore processor, if every memory access from any of those tens of cores goes through a single memorymanagement unit (MMU) for security reasons, then the MMU becomes a performance bottleneck. In such cases, it might make sense to create duplicate, local MMUs that will serve only a subset of the cores of processors rather than all of them. These local copies are also called shadow copies or mirrored copies. If the original resource that was being duplicated into these local copies never changed, the question of the local copies getting out of sync would not arise. Unfortunately, in many cases, the values inside the original copy change. For example, a memory range might be inaccessible during boot time, but once the boot process is over and the system is now in a stable state, that memory range may now be opened up for access. So, if a register(s) in the accesscontrol unit stores the start and end addresses of the accessible memory chunks, those values would change after the boot process is over. Now, when the original copy changes, the mirrored copies must also change, and change fast. This situation of shadowcopypossiblyoutofsyncwithoriginalcopy might occur as a result of multiple scenarios, including the following: After the values in the original copy change, due to some reason the original copy does not send the update request to its shadow copies. After the values in the original copy change, the original copy dutifully sends the update request to its shadow copies, but due to some reason the shadow copy does not execute this update request. After the values in the original copy change, the original copy sends the update request to its shadow copies, and the shadow copy executes this update request faithfully. However, during the small time period when the original copy has new values and the shadow copy is still holding the old values, an attacker can exploit the old values. Then it becomes a race condition between the attacker and the update process of who can reach the target, shadow copy first, and, if the attacker reaches first, the attacker wins. The attacker might send a spoofed update request to the target shadow copy, pretending that this update request is coming from the original copy. This spoofed request might cause the targeted shadow copy to update its values to some attackerfriendly values, while the original copies remain unchanged by the attacker. Suppose a situation where the original copy has a system of reverting back to its original value if it does not hear back from all the shadow copies that such copies have successfully completed the update request. In such a case, an attack might occur as follows: (1) the original copy might send an update request; (2) the shadow copy updates it; (3) the shadow copy sends back the successful completion message; (4) through a separate issue, the attacker is able to intercept the shadow copy''''s completion message. In this case, the original copy thinks that the update did not succeed, hence it reverts to its original value. Now there is a situation where the original copy has the old value, and the shadow copy has the new value.

Mitigation:


PHASE:Architecture and Design:
Whenever there are multiple, physically different copies of the same value that might change and the process to update them is not instantaneous and atomic, it is impossible to assert that the original and shadow copies will always be in sync  there will always be a time period when they are out of sync. To mitigate the consequential risk, the recommendations essentially are: Make this outofsync time period as small as possible, and Make the update process as robust as possible.:EFFECTIVENESS:Moderate

',1);
INSERT INTO "kb_items" VALUES (1252,'CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations','Description:

The CPU is not configured to provide hardware support for exclusivity of write and execute operations on memory. This allows an attacker to execute data from all of memory.

CPUs provide a special bit that supports exclusivity of write and execute operations. This bit is used to segregate areas of memory to either mark them as code (instructions, which can be executed) or data (which should not be executed). In this way, if a user can write to a region of memory, the user cannot execute from that region and vice versa. This exclusivity provided by special hardware bit is leveraged by the operating system to protect executable space. While this bit is available in most modern processors by default, in some CPUs the exclusivity is implemented via a memoryprotection unit (MPU) and memorymanagement unit (MMU) in which memory regions can be carved out with exact read, write, and execute permissions. However, if the CPU does not have an MMU/MPU, then there is no write exclusivity. Without configuring exclusivity of operations via segregated areas of memory, an attacker may be able to inject malicious code onto memory and later execute it.

Mitigation:


PHASE:Architecture and Design:
Implement a dedicated bit that can be leveraged by the Operating System to mark data areas as nonexecutable. If such a bit is not available in the CPU, implement MMU/MPU (memory management unit / memory protection unit).

PHASE:Integration:
If MMU/MPU are not available, then the firewalls need to be implemented in the SoC interconnect to mimic the writeexclusivity operation.

',1);
INSERT INTO "kb_items" VALUES (1253,'key vault','Description:

Keys should remain in a protected key vault at all times. 
In particular, ensure that there is a gap between the threat vectors 
that have direct access to the data and the threat vectors that have direct access to the keys. 
This implies that keys should not be stored on the application or web server 
(assuming that application attackers are part of the relevant threat model).

A key vault helps secure, store and tightly control access to tokens, passwords, certificates and,
encryption keys for protecting secrets and other sensitive data.  

Imagine the use of a keyvault in the following scenario''''s

* Running a docker container and provisioning it with secrets over CLI
* Checking in API keys in your source repositories
* Encrypting sensitive data at rest

Vault provides encryption as a service with centralized key management to simplify encrypting data 
in transit and at rest across clouds and datacenters.

a Vault can be used to encrypt/decrypt data that is stored elsewhere. The primary use of this is to allow applications to encrypt their data while still storing it in the primary data store.

The benefit of this is that developers do not need to worry about how to properly encrypt data. The responsibility of encryption is on Vault and the security team managing it, and developers just encrypt/decrypt data as needed.

Mitigation:

centrally store, access, and distribute secrets like API keys,
AWS IAM/STS credentials, SQL/NoSQL databases, X.509 certificates, 
SSH credentials, etc by means of a key vault.

When selecting a key vault that is fit for your needs make sure it has Cryptographic Compliance
towards the FIPS standards.


',1);
INSERT INTO "kb_items" VALUES (1337,'Sensitive Information Exposure in URL','Description:

If the application logic transmits session IDs in the URL, their values could be leaked through the Referer header to thirdparty websites, logged by proxy servers, bookmarked in the browser, accidentally sent via emails or chats. 
Whenever the session ID is disclosed in the URL there might be also the possibility to perform other attacks (like session fixation) that lead to session hijacking.

Mitigation:

Session tokens should never be included in places other than the application Cookie header or other custom headers defined by the application.

',1);
INSERT INTO "kb_items" VALUES (1338,'Sensitive Information Exposure in client Side Storage','Description:

Clientside storage (also known as offline storage or web storage) is a functionality provided by browsers to allow applications to save information on the user''''s computer and retrieve them when necessary. 
Since this operations are performed by clientside scripting languages (notably Javascript), this information can be retrieved by thirdparty codes included in the webpages or by Crosssite scripting attacks (XSS) performed by attackers.
Moreover, attackers with local privileges on the user''''s machine are able to access these storages and possibly compromise the session of the users.

Mitigation:

Sensitive data (like session tokens or Personal Identifiable Information) should never be stored in clientside storages. 
This means to carefully verify that the application never saves at any time this kind of information in:
* Local Storage
* Session Storage
* Web SQL
* Cache Storage
* Application Cache
* IndexDB',1);
INSERT INTO "kb_items" VALUES (2000,'empty control','Description:

empty control

Mitigation:

empty control',2);
INSERT INTO "kb_items" VALUES (5001,'Password Hash Salt Length','Description:

For secure storage of passwords, it is recommended to hash the passwords with a unique salt. A salt is a nonsecret, unique value in the database which is appended (depending on the used algorithm) to the password before it gets hashed. A salt is used to prevent Rainbow Table lookups (an attack where you compute a table of hashes for passwords). The length of a salt is critical to ensure true randomness and entropy amongst the hashed password and prevent collusion.


Mitigation:

Ensure the length of the salt is atleast 32bit, SHALL be generated by an approved random bit generator and chosen arbitrarily to minimize salt value collisions among stored hashes.
',1);
INSERT INTO "kb_items" VALUES (5100,'OOB Unencrypted','Description:

In authentication, outofband refers to utilizing two separate networks or channels, one of which being different from the primary network or channel, simultaneously used to communicate between two parties or devices for identifying a user. A cellular network is commonly used for outofband authentication. An example of outofband authentication is when an online banking user is accessing their online bank account with a login and a one time password is sent to their mobile phone via SMS to identify them. The primary channel would be the online login screen where the user enters their login information and the second separate channel would be the cellular network. This added layer of security prevents the likelihood of hackers and malware from compromising access to the complete authentication process.


Mitigation:

The most effective solution to eliminate the use of mediums such as unencrypted emails or VOIP and switch to more secure channels or implement mechanisms like mutual TLS authentication between the interacting parties where possible.
',1);
INSERT INTO "kb_items" VALUES (5101,'Secure OOB Channel','Description:

The essential idea behind outofband authentication is that by using two different channels, authentication systems can guard against fraudulent users that may only have access to one of these channels. One of the most common examples of outofband authentication is in banking transactions. Typically, a customer wishing to do an online bank transaction will be sent an SMS message by cell phone with a password. This way, any hackers or identity thieves that have access through key loggers or other equipment will not be able to access that particular password, because it is sent over a 3G or 4G wireless network instead of being sent over the Internet.It is worthy to ensure the channel between the communicating parties is through a trusted and secure channel.


Mitigation:

The most effective solution is to switch to a more secure channel and implement mechanisms like mutual TLS between the interacting parties where possible.
',1);
INSERT INTO "kb_items" VALUES (5102,'OOB PIN Expiry','Description:

If an application allows the user to attempt for outofband authentication after a set time interval, it increases the chance of an attacker to replay a valid outofband authentication key after successfully compromising the session.


Mitigation:

The most effective solution is to reject out of band authentication attempts after 10 minutes and also ensure the outofband authentication key can be used only once.
',1);
INSERT INTO "kb_items" VALUES (5103,'OOB Key Used Once','Description:

If an application allows the user to attempt for outofband authentication using an old outofband authentication key, it increases the likelihood of replay attacks and can assist in comprising a user session.


Mitigation:

The most effective solution is to reject out of band authentication attempts after 10 minutes and also ensure the outofband authentication key can be used only once. The system providing outofband authentication keying material should discard the key once it used.
',1);
INSERT INTO "kb_items" VALUES (6904,'Identity Spoofing','Description:

It is important to uniquely identify the users of an application for traceability. Therefore it should not be possible to use shared accounts,
nor should it be possible to rebind identities to a different identity (spoofing)

Mitigation:

Verify identities cannot be rebound to a different identity and shared accounts are not present ("root", "admin", or "sa").
Administrative accounts like root, admin, sa,... should not be shared, should be renamed and should not be exposed to the front end of the application.
',1);
INSERT INTO "kb_items" VALUES (6914,'No Character type limitation','Description:

The application should allow and not limit or enforce the type of characters that are permitted. 
Moreover, the application should enable the user to make pass phrases containng any usable character and 
therefore strengthen security. 

Mitigation:
	
Verify that there are no password composition rules limiting the type of characters permitted. 
There should be no requirement for upper or lower case or numbers or special characters.
',1);
INSERT INTO "kb_items" VALUES (6915,'No Credential Rotation Requirements','Description:

Do not require that memorized secrets be changed arbitrarily (e.g., periodically)
unless there is a user request or evidence of authenticator compromise. 
Password expiration policies do more harm than good, because these policies drive users to very
predictable passwords composed of sequential words and numbers which are closely related to each
other (that is, the next password can be predicted based on the previous password). Password change
offers no containment benefits cyber criminals almost always use credentials as soon as they
compromise them.
Mandated password changes are a longstanding security practice, but current research strongly
indicates that password expiration has a negative effect. 

Mitigation:

Verify that there are no arbitrary or periodic credential rotation requirements.
',1);
INSERT INTO "kb_items" VALUES (10001,'Filename injection Path traversal','Description:

A Path Traversal attack aims to access files and directories that are stored outside the web root folder. By browsing the application, the attacker looks for absolute links to files stored on the web server. By manipulating variables that reference files with dotdotslash (../); sequences and its variations, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and critical system files, limited by system operational access control. The attacker uses  ../../ sequences to move up to root directory, thus permitting navigation through the file system. This attack can be executed with an external malicious code injected on the path, like the Resource Injection attack.


Mitigation:

The most effective solution to eliminate file inclusion vulnerabilities is to avoid passing
usersubmitted input to any filesystem/framework API. If this is not possible the application
can maintain a white list of files, that may be included on the page, and then use an identifier
(for example the index number) to access the selected file. Any request containing an invalid
identifier has to be rejected, in this way there is no attack surface for malicious users to
manipulate the path.

',1);
INSERT INTO "kb_items" VALUES (10002,'XSS injection','Description:

Every time the application gets userinput, whether this showing it on screen or processing
this data in the application background, these parameters should be escaped for malicious
code in order to prevent crosssite scripting injections.
When an attacker gains the possibility to perform an XSS injection,
he is given the opportunity to inject HTML and JavaScript code directly into the
application. This could lead to accounts being compromised by stealing session cookies or directly 
affect the operation of the target application. 

Altough templating engines(razor, twig, jinja, etc) and contextaware applications(Angular, React, etc)
do a lot of auto escaping for you. These frameworks should always be validated for effectiveness.


Mitigation:

In order to prevent XSS injections, all userinput should be escaped or encoded.
You could start by sanitizing userinput as soon as it is inserted into the application,
by preference using a so called whitelisting method.
This means you should not check for malicious content like the tags or anything,
but only allow the expected input. Every input which is outside of the intended operation
of the application should immediately be detected and login rejected.
Do not try to help use the input in any way because that could introduce a new type of attack by converting characters. 

The second step would be encoding all the parameters or userinput before putting this in
your html with encoding libraries specially designed for this purpose.

You should take into consideration that there are several contexts for encoding userinput for
escaping XSS injections. These contexts are amongst others:

* HTML encoding, is for whenever your userinput is displayed directly into your HTML.
* HTML attribute encoding, is the type of encoding/escaping that should be applied 
  whenever your user input is displayed into the attribute of your HTML tags.
* HTML URL encoding, this type of encoding/escaping should be applied to whenever you are using userinput into a HREF tag.

JavaScript encoding should be used whenever parameters are rendered via JavaScript; your application will detect normal injections in the first instant. But your application still remains vulnerable to JavaScript encoding which will not be detected by the normal encoding/escaping methods.

',1);
INSERT INTO "kb_items" VALUES (10003,'Command injection','Description:

Command injection is an attack in which the goal is execution of arbitrary commands on
the host operating system via a vulnerable application. Command injection attacks are
possible when an application passes unsafe user supplied data
(forms, cookies, HTTP headers etc.) to a system shell. In this attack,
the attackersupplied operating system commands are usually executed with the privileges
of the vulnerable application. Command injection attacks are possible largely due to
insufficient input validation. This attack differs from Code Injection, in that code
injection allows the attacker to adds his own code that is then executed by the application.
In Code Injection, the attacker extends the default functionality of the application
without the necessity of executing system commands.

Mitigation:

Userinput that is used in a shell command should not contain dangerous characters.
A blacklist of characters is not a good option because it may be difficult to think of
all of the characters to validate against. A white list containing only allowable
characters should be created to validate the userinput.
',1);
INSERT INTO "kb_items" VALUES (10004,'Cross site request forgery','Description:

CrossSite Request Forgery (CSRF) is a type of attack that occurs when a malicious Web site,
email, blog, instant message, or program causes a users Web browser to perform an unwanted
action on a trusted site for which the user is currently authenticated.

The impact of a successful crosssite request forgery attack is limited to the
capabilities exposed by the vulnerable application. For example, this attack could result
in a transfer of funds, changing a password, or purchasing an item in the users context.
In effect, CSRF attacks are used by an attacker to make a target system perform a
function (funds Transfer, form submission etc.) via the targets browser without
knowledge of the target user at least until the unauthorised function has been committed.

Mitigation:

To arm an application against automated attacks and tooling you need to use unique tokens
which are included into the forms of an application, API calls or AJAX requests.  
Any state changing operation requires a secure random token (e.g CSRF token) to prevent
against CSRF attacks. Characteristics of a CSRF Token are a unique, large random
value generated by a cryptographically secure random number generator.

The CSRF token is then added as a hidden field for forms and validated on the sever side whenever
a user is sending a request to the server.

Note :
Whenever the application is an REST service and is using tokens such as JWT tokens, whenever these tokens are being sent
in the application headers rather than stored in cookies the application should not be suspectible to CSRF attacks for a succesfull CSRF attacke depends on the browsers cookie jar.
',1);
INSERT INTO "kb_items" VALUES (10005,'XXE injections','Description:

Processing of an Xml eXternal Entity containing tainted data may lead to the disclosure of
confidential information and other system impacts.
The XML 1.0 standard defines the structure of an XML document.
The standard defines a concept called an entity, which is a storage unit of some type.

There exists a specific type of entity, an external general parsed entity often shortened
to an external entity, that can access local or remote content via a declared system
identifier and the XML processor may disclose confidential information normally not
accessible by the application. Attacks can include disclosing local files, which may
contain sensitive data such as passwords or private user data.

Mitigation:

Disable the possibility to fetch resources from an external source.
This is normally done in the configuration of the used XML parser.
',1);
INSERT INTO "kb_items" VALUES (10006,'X Path injections','Description:

Web applications heavily use databases to store and access the data they need for their
operations. Historically, relational databases have been by far the most common
technology for data storage, but in the last years, we are witnessing an increasing
popularity for databases that organise data using the XML language.
Just like relational databases are accessed via SQL language, XML databases use XPath as
their standard query language.

Mitigation:

Just like the techniques to avoid SQL injection, you need to use a parameterised XPath
interface if one is available, or escape the user input to make it safe to include in a
dynamically constructed query. If you are using quotes to terminate untrusted input in a
dynamically constructed XPath query, then you need to escape that quote in the untrusted
input to ensure the untrusted data can not try to break
out of that quoted context.
',1);
INSERT INTO "kb_items" VALUES (10007,'XML injection','Description:

XML Injection is an attack technique used to manipulate or compromise the logic of an XML
application or service. The injection of unintended XML content and/or structures into
an XML message can alter the intended logic of the application. Further, XML injection
can cause the insertion of malicious content into the resulting message/document.

Mitigation:

In addition to the existing input validation, define a positive approach which
escapes/encodes characters that can be interpreted as XML. At a minimum this includes
the following: < > / " ''''
',1);
INSERT INTO "kb_items" VALUES (10008,'External DTD parsing','Description:

Processing of an external entity containing tainted data may lead to the disclosure of confidential information and other system impacts. The XML 1.0 standard defines the structure of an XML document. The standard defines a concept called an entity, which is a storage unit of some type. There exists a specific type of entity, an external general parsed entity often shortened to an external entity that can access local or remote content via a declared system identifier. The system identifier is assumed to be a URI that can be dereferenced (accessed) by the XML processor when processing the entity.
The XML processor then replaces occurrences of the named external entity with the contents dereferenced by the system identifier. If the system identifier contains tainted data and the XML processor dereferences this tainted data, the XML processor may disclose confidential information normally not accessible by the application. Attacks can include disclosing local files, which may contain sensitive data such as passwords or private user data, using file: schemes or relative paths in the system identifier.
Since the attack occurs relative to the application processing the XML document, an attacker may use this trusted application to pivot to other internal systems, possibly disclosing other internal content via HTTP(s) requests. In some situations, an XML processor library that is vulnerable to clientside memory corruption issues may be exploited by dereferencing a malicious URI, possibly allowing arbitrary code execution under the application account. Other attacks can access local resources that may not stop returning data, possibly impacting application availability if too many threads or processes are not released.


Mitigation:

Disable the XML DTD (Document Type Definition) parsing. This can be set when initiating the XML parser.
',1);
INSERT INTO "kb_items" VALUES (10009,'LDAP injection','Description:

LDAP (Lightweight Directory Access Protocol) Injection is an attack used to exploit web based applications that construct LDAP statements based on user input. When an application fails to properly sanitize user input, it is possible to modify LDAP statements using a local proxy. This could result in the execution of arbitrary commands such as granting permissions to unauthorized queries, and content modification inside the LDAP tree. The same advanced exploitation techniques available in SQL Injection can be similarly applied in LDAP Injection.

Mitigation:

The best way to prevent LDAP injection is to use a positive validation scheme for ensuring that the data going into your queries does not contain any attacks. However, in some cases, it is necessary to include special characters in the input that is passed into an LDAP query. In this case, using escaping can prevent the LDAP interpreter from thinking those special characters are actually part of the LDAP query.
',1);
INSERT INTO "kb_items" VALUES (10010,'SSI injections','Description:

Web servers usually give developers the ability to add small pieces of dynamic code inside
static HTML pages, without having to deal with fullfledged serverside
or clientside languages.

This feature is incarnated by the ServerSide Includes (SSI).
The attacker will try to inject code into the application that will
be interpreted by SSI mechanisms. A successful exploitation of this vulnerability
allows an attacker to inject code into HTML pages or even perform remote code execution.

Mitigation:

The SSI handler on the webserver should not be activated when it is not used.
',1);
INSERT INTO "kb_items" VALUES (10011,'File upload injections','Description:

Uploaded files represent a significant risk to applications.
The first step in many attacks is to get some code to the system to be attacked.
Then the attack only needs to find a way to get the code executed. Using a file upload
helps the attacker accomplish the first step.

The consequences of unrestricted file upload can vary, including complete system takeover,
an overloaded file system or database, forwarding attacks to backend systems, and simple
defacement.

There are really two classes of problems here.
The first is with the file metadata, like the path and file name.
These are generally provided by the transport, such as HTTP multipart encoding.
This data may trick the application into overwriting a critical file or storing the file
in a bad location. You must validate the metadata extremely carefully before using it.

The other class of problem is with the file size or content.
An attacker can easily craft a valid image file with PHP code inside.

Mitigation:

 Uploaded files always need to be placed outside the document root of the webserver
 Check to not accept large files that could fill up storage or cause a denial of service attack
 Check the userinput(filename) for having the right allowed extensions such as .jpg, .png etc
  Note: when checking these extensions always make sure your application validates the last
  possible extension so an attacker could not simply inject ".jpg.php" and bypass your
  validation

 Check the userinput(filename) for containing possible path traversal patterns in order to prevent him from uploading outside of the intended directory.

You may also want to check if the filenames do already exist before uploading in order to
prevent the overwriting of files.

Also for serving the files back there needs to be a file handler function that can select
the file based on an identifier that will serve the file back towards the user.

Most developers also do a mimetype check. This is a good protection however not
whenever you are checking this mimetype through the post request. This header can not be
trusted since it can be easily manipulated by an attacker.

The best way to check the mimetype
is to extract the file from the server after uploading and check it from the file itself.
Deleting it whenever it does not comply with expected values.

',1);
INSERT INTO "kb_items" VALUES (10012,'Version management','Description:

Whenever a programmer decides to use third party software,
he should keep an eye implementing a proper version management methodology for this software.
When hackers discover vulnerabilities they often publish these exploits online in order
to push the developers of this software to fix their issues. As a result,
when your software is not upgraded to the latest available version,
script kiddies could easily compromise your application by following the
exploit tutorials online, thus compromising your application.

Mitigation:

One option is not to use components that you did not write.
But that is not very realistic.

Most component projects do not create vulnerability patches for old versions.
Instead, most simply fix the problem in the next version. So upgrading to these new
versions is critical.
Software projects should have a process in place to:

Identify all components and the versions you are using, including all dependencies.
(e.g., the versions plugin).

Monitor the security of these components in public databases,
project mailing lists, and security mailing lists, and keep them up to date.

Establish security policies governing components use, such as requiring certain software
development practices, passing security tests, and acceptable licenses.

Where appropriate, consider adding security wrappers around components to disable unused
functionality and/ or secure weak or vulnerable aspects of the component.

This also goes for all other components that should be up to date with proper security
configuration(s) and version(s) such as server OS etc.

This should include removal of unneeded configurations and folders such as sample
applications, platform documentation, and default or example users.
',1);
INSERT INTO "kb_items" VALUES (10013,'Verbose error messaging','Description:

An important aspect of secure application development is to prevent information leakage. 
Error messages give an attacker great insight into the inner workings of an application.

The purpose of reviewing the Error Handling code is to assure the application fails safely under all 
possible error conditions, expected and unexpected. No sensitive information is presented to the user 
when an error occurs.

When an exception or error is thrown we also need to log this occurrence. Sometimes this is due to bad
development, but it can be the result of an attack or some other service your application relies on failing.

All code paths that can cause an exception to be thrown should check for success in order for the exception 
not to be thrown.

Mitigation:

We should use a localized description string in every exception, a friendly error reason such as “System Error – Please try again later”. When the user sees an error message, it will be derived from this description string of the exception that was thrown, and never from the exception class which may contain a stack trace, line number where the error occurred, 
class name or method name.

Do not expose sensitive information in exception messages. Information such as paths on the local file system is considered privileged information; any system internal information should be hidden from the user. As mentioned before an attacker could use this information to gather private user information from the application or components that make up the app.

Don’t put people’s names or any internal contact information in error messages. Don’t put any “human” information, which would lead to a level of familiarity and a social engineering exploit.

Another good example would be for password forget functions to throw a generic error message when a email adress
is or is not known on the system. This should prevent enumeration of email adresses.

',1);
INSERT INTO "kb_items" VALUES (10014,'Debug enabeling','Description:

Sometimes it is possible through an "enabling debug parameter" to display technical
information/secrets within the application. As a result, the attacker learns more about the
operation of the application, increasing his attack surface. Sometimes having a debug flag 
enabled could even lead to code execution attacks (older versions of werkzeug) 

Mitigation:

Disable the possibility to enable debug information on a live environment.
',1);
INSERT INTO "kb_items" VALUES (10015,'Robots.txt','Description:

Each site uses a robots.txt file which allows search engines to provide information.
The robots.txt determines what pages may or may not be indexed by google or yahoo etc.
However, a common mistake made by programmers is applying a blacklisting method causing
the application displaying sensitive information to attackers.

Mitigation:

Instead of the blacklisting method:

Useragent: *
Disallow: /squirrelmail/
Disallow: /admin/
Disallow: /modules/

You should use a whitelisting method:

Useragent: *
Disallow: *
Allow: /index.html
Allow: /home.html
',1);
INSERT INTO "kb_items" VALUES (10016,'Accessible non parsed dynamic scripts','Description:

Applications often include files in other pages. When these files can be directly
approached by normal users, the operation of the application can be traced because the
source code becomes available. This improves the possibility that the attacker discovers
vulnerabilities.

It is also highly recommended that old files are removed from the server and not beind stored
or backuped as i.e "file.php.old". 

Mitigation:

Always add the different types of extensions to the webserver handler to parse.
This way the file source cannot be viewed.
',1);
INSERT INTO "kb_items" VALUES (10017,'Include anti caching headers','Description:

Anticaching headers have the ability to tell the browser,
computer and proxies what information they may or may not store on the intermediate media

Mitigation:

These headers are also known as the: Cachecontrol: nostore,nocache and provide
protection of sensitive information when implemented in the application or webserver.

Rightly configured anti caching headers will look like the following as a response

	Expires: Tue, 03 Jul 2001 06:00:00 GMT
	LastModified: {now} GMT
	CacheControl: nostore, nocache, mustrevalidate, maxage=0
	CacheControl: postcheck=0, precheck=0
	Pragma: nocache
',1);
INSERT INTO "kb_items" VALUES (10018,'Include anti clickjacking headers','Description:

Clickjacking, also known as a "UI redress attack", is when an attacker uses multiple
transparent or opaque layers to trick a user into clicking on a button or link on another
page when they were intending to click on the top level page. Thus, the attacker is
"hijacking" clicks meant for their page and routing them to another page, most likely
owned by another application, domain, or both.

Using a similar technique, keystrokes can also be hijacked. With a carefully crafted
combination of stylesheets, iframes, and text boxes, a user can be led to believe they
are typing in the password to their email or bank account, but are instead typing into an
invisible frame controlled by the attacker.

Mitigation:

To avoid your application from being clickjacked you can add the XframeOptions header
to your application. These headers can be configured as:

    XframeOptions: deny

The page cannot be displayed in a frame, regardless of the site attempting to do so.

    XFrameOptions: sameorign  

The page can only be displayed in a frame on the same origin as the page itself.

    XFrameOptions: ALLOWFROM uri

The page can only be displayed in a frame on the specified origin.

You may also want to consider to include "Framebreaking/Framebusting" defense for legacy
browsers that do not support XFrameOption headers.

Source:
https://www.codemagi.com/blog/post/194
',1);
INSERT INTO "kb_items" VALUES (10019,'Include X XSS','Description:

This header enables the Crosssite scripting (XSS) filter built into most recent
web browsers. It is usually enabled by default anyway, so the role of this header is to reenable the filter for this particular website if it was disabled by the user. This header is supported in IE 8 and in Chrome 4.

Mitigation:

These headers are also known as the: XXSSProtection: 1; mode=block and provide protection against XSS attacks when implemented in the application or webserver.

NOTE:
This header only protects against some reflected XSS attacks. This is no substitute for normal escaping and input filtering and sanitization.
',1);
INSERT INTO "kb_items" VALUES (10020,'Include X Content Type Options header','Description:

The only defined value, nosniff, prevents Internet Explorer and Google Chrome from
MIMEsniffing a response away from the declared contenttype.
This also applies to Google Chrome, when downloading extensions.
This reduces exposure to driveby download attacks and sites serving user uploaded
content that, by clever naming, could be treated by MSIE as executable or dynamic HTML
files.

Mitigation:

These headers are also known as the: XContentTypeOptions: nosniff;
and provide protection against Mime content type attacks when implemented in the
application or webserver.
',1);
INSERT INTO "kb_items" VALUES (10021,'Include Strict Transport Security header','Description:

HTTP StrictTransportSecurity (HSTS) enforces secure (HTTP over SSL/TLS) connections to
the server. This reduces the impact of bugs in web applications leaking session data through
cookies and external links and defends against Maninthemiddle attacks. HSTS also
disables the ability for user''''s to ignore SSL negotiation warnings

Mitigation:

These headers are also known as the: StrictTransportSecurity: maxage=16070400:
includeSubDomains and provide protection against SSL Strip attacks when implemented in the
application or web server.

When connecting to an HSTS host for the first time, the browser won''''t know whether or not
to use a secure connection, because it has never received an HSTS header from that host.
Consequently, an active network attacker could prevent the browser from ever connecting
securely (and even worse, the user may never realize something is amiss). To mitigate
this attack, you can add your application to a preload list which makes HSTS enforced by default.
When a user connects to one of these hosts for the first time, the browser will know that
it must use a secure connection. If a network attacker prevents secure connections to the
server, the browser will not attempt to connect over an insecure protocol, thus
maintaining the user''''s security.

Visit:
    https://hstspreload.appspot.com/
Here you can find how to add your application to HSTS preload
',1);
INSERT INTO "kb_items" VALUES (10022,'Unauthorized credential changes','Description:

An application which offers user login functionality, usually has an administration page
where userdata can be modified. When the user wants to change this data he should
specify his current password.

Mitigation:

When changing user credentials or email address the user must always enter a valid
password in order to implement the changes. This is also called reauthentication or
stepup / adaptive authentication. Whenever a user "reauthenticates" himself the current
session ID value should also be refreshed in order to fend oFf so called "session hijackers"
',1);
INSERT INTO "kb_items" VALUES (10023,'Double decoding of headers parameters','Description:

Double decoding is a problem which often occurs when multiple servers are used in which a
configuration error is made.
A hacker can encode his payload differently so it will not be recognized by a Web Application Firewall (WAF) or an Intrusion Detection System (IDS) and also bypass the escaping of the application.

By using double encoding it''''s possible to bypass security filters that only decode user
input once. The second decoding process is executed by the backend platform or modules
that properly handle encoded data, but don''''t have the corresponding security checks in
place.

Attackers can inject double encoding in pathnames or query strings to bypass the
authentication scheme and security filters in use by the web application.

Mitigation:

Only one webserver should decode/encode the data.
',1);
INSERT INTO "kb_items" VALUES (10024,'Resource identifier injection','Description:

A resource identifier injection basically means that the attacker can determine which
resources are loaded into the web application.
An attacker could thus influence the operation of the web application and redirect users
to other websites. This attack consists of changing resource identifiers used by an
application in order to perform a malicious task. When an application permits a user
input to define a resource, like a file name or port number,
this data can be manipulated to execute or access different resources.
In order to be properly executed, the attacker must have the possibility to specify a
resource identifier through the application form and the application must permit the execution.
The resource type affected by user input indicates the content type that may be exposed.
For example, an application that permits input of special characters like period, slash,
and backlash is risky when used in methods that interact with the file system.
The resource injection attack focuses on accessing other resources than the local
filesystem, which is different attack technique known as a Path Manipulation attack.

Mitigation:

Safe use of resource identifiers can be done by performing authorisation checks if the
identifier belongs to the user.
',1);
INSERT INTO "kb_items" VALUES (10025,'Dynamic scripting injection','Description:

When user input is used to evaluate scripting code, highsecurity risks could be introduced. If the input is not properly escaped an attacker can inject his own script code and gain access to the server.

Mitigation:

Do not use direct userinput in the dynamic scripting function. You should first
use an input validation or encoding function on the user submitted data to clean and
sanitize the input against malicious intent.
',1);
INSERT INTO "kb_items" VALUES (10026,'Regular expression injection','Description:

If the application uses regular expressions which receive user input,
then the user input should be properly escaped.
If not done properly, then the hacker can affect the regular expression and modify their
logic. In some cases, an attacker could even gain access to the server.


Mitigation:

Do not use userinput without escaping in a regular expression "regex pattern",
Since this could lead to serious security vulnerabilities.
',1);
INSERT INTO "kb_items" VALUES (10027,'Automated spamming via feedback scripts','Description:

A hacker must not gain the ability to abuse an applications email functionality by
means of scripts which sends automated spamming mails.

Mitigation:

This problem could be prevented by implementing CAPTCHA or ratelimiting mechanisms.
',1);
INSERT INTO "kb_items" VALUES (10028,'Session cookies without the Secure attribute','Description:

The secure flag is an option that can be set when creating a cookie.
This flag ensures that the cookie will not be sent over an unencrypted
connection by the browser,which ensures that the session cookie can not be sent over a nonencrypted link.

Mitigation:

When creating a session cookie which is sent over an encrypted connection
you should set the secure flag. The Secure flag should be set during every setcookie.
This will instruct the browser to never send the cookie over HTTP.
The purpose of this flag is to prevent the accidental exposure of a cookie value if a user
follows an HTTP link.


',1);
INSERT INTO "kb_items" VALUES (10029,'Session cookies without the HttpOnly attribute','Description:

An HttpOnly flag is an option that can be set when creating a cookie. This v ensures that the cookie cannot be read or edited by JavaScript. This ensures an attacker cannot steal this cookie as a crosssite scripting vulnerability is present in the application.

Mitigation:

The HttpOnly flag should be set to disable malicious script access to the cookie values such as the session ID value. Also, disable unnecessary HTTP request methods such as the TRACE option. Misconfiguration of the HTTP request headers can lead to stealing the session cookie even though HttpOnly protection is in place.
',1);
INSERT INTO "kb_items" VALUES (10030,'External session hijacking','Description:

When an attacker obtains a users session cookie, then he can steal the identity of the
user which the session cookie belongs to.

Mitigation:

As soon as a session is set for an authenticated user,
the server should keep track of the IP address in which the user used when he started the session.
When the server discovers a change in IP address, for instance when an attacker hijacks an
users session. The server then should deny access, destroy the session and redirect the
''''hijacker'''' to the login page.
',1);
INSERT INTO "kb_items" VALUES (10031,'Communication between components (low privileges)','Description:

If accounts for communicating between components have granted more privileges than
necessary, these accounts could impose a great threat whenever one of these components gets
compromised by attackers. 

i.e:
A web application running on root privileges which has a path traversal vulnerability
can be used to read both the "etc/passwd" file as well as reading the "etc/shadow" file.

These files can then be used in an offline password cracking attacks to recover accounts
on the server.

Mitigation:

Communications between components, such as between the application server and the database 
server should be authenticated using an account with the least necessary privileges.
',1);
INSERT INTO "kb_items" VALUES (10032,'Insecure transmission of session cookies','Description:

If the session cookies are sent over an unencrypted connection,
they should be withdrawn immediately.
These cookies are not to be trusted anymore as a hacker may have captured their values.

Mitigation:

Session cookies that are used to authenticate the user should always be set on a
secure connection.

In order to achieve this, you should set the "secure" flag on your session cookie
to make sure your application in any circumstance does not send this cookie over nonHTTPS connections.
',1);
INSERT INTO "kb_items" VALUES (10033,'Principle of complete mediation','Description:

Throughout development of the application, there must be perpetual checks in place to check
if all pages and resources by default require authentication except those specifically intended to be public.

Sometimes developers simply forget to implement these checks, or they remove the checks 
temporarily for testing purposes. 

Mitigation:

Verify all access controls are implemented properly in order to prevent a user access data/functions which 
he was not intended to use.
',1);
INSERT INTO "kb_items" VALUES (10034,'Prepared statements and query parameterization','Description:

All SQL queries, HQL, OSQL, NOSQL and stored procedures, related to stored procedures should be
protected by the use of query parameterization.
If an attacker can inject malicious code into these queries and gain the ability to
manipulate them and can withdraw, update and delete data which is stored on the
target database.

Mitigation:

The use of prepared statements and parameterized queries is how all developers should
first be taught how to write database queries. They are simple to write, and easier to
understand than dynamic queries. Parameterized queries force the developer to first define
all the SQL code, and then pass in each parameter to the query later. This coding style
allows the database to distinguish between code and data, regardless of what user input
is supplied.
',1);
INSERT INTO "kb_items" VALUES (10035,'Sensitive information transmitted by unencrypted methods','Description:

Whenever sensitive information is sent by unencrypted methods an attacker could intercept
this data and use this for malicious intents.

Mitigation:

All sensitive information should always be sent by encrypted methods
such as HTTPS(TLS) connections.


',1);
INSERT INTO "kb_items" VALUES (10036,'The crossdomain xml should only contains trusted domains','Description:

The use of a crossdomain.xml file is required when the web application uses Flash.
This file is used to set up restrictions for any other web servers using the
flash application. If these are not set correctly, an attacker could exploit this to
execute targeted attacks against the users of the web application.

Mitigation:

Always make sure the crossdomain.xml only contains trusted domains.
',1);
INSERT INTO "kb_items" VALUES (10037,'Directory listing','Description:

Whenever directory listing is enabled, an attacker could gain sensitive information about
the systems hierarchical structure and gain knowledge about directories or files which should
possibly not be publicly accessible. An attacker could use this information to
increase his attack vector. In some cases this could even lead to an attacker gaining knowledge about
credentials or old vulnerable system demo functions which might lead to remote code execution.

Mitigation:

Different types of servers require a different type of approach in order to disable
directory listing. For instance: Apache uses a .htacces in order to disable directory listing.
As for iis7, directory listing is disabled by default.
',1);
INSERT INTO "kb_items" VALUES (10038,'Open forward and Open redirects','Description:

Unvalidated redirects and forwards are possible when a web application accepts untrusted
input that could cause the web application to redirect the request to a URL contained
within the untrusted input. By modifying untrusted URL input to a malicious site, an attacker
may successfully launch a phishing scam and steal user credentials. Because the server
name in the modified link is identical to the original site, phishing attempts may have
a more trustworthy appearance. Unvalidated redirect and forward attacks can also be used
to maliciously craft a URL that would pass the application''''s access control check and
then forward the attacker to privileged functions that they would normally not be able
to access.

Mitigation:

Use a whitelisting method for determining where the user should be redirected towards.
You could also show a warning when redirecting to potentially untrusted content.

If not deemed necessary user supplied input should not be used in redirects and forwards anyways.
',1);
INSERT INTO "kb_items" VALUES (10039,'Extraneous files in document root','Description:

Whenever the document root contains extraneous files, these files could be accessed by an
attacker or could possibly contain functionality which could contain other vulnerabilities.

Mitigation:

Extraneous files in document root should be investigated and deleted if it''''s not necessary
for the operation of the application.

There are more chances of accessing hidden folders, files and some configuration files to be
accessed through document root.

For example if you are using some version control system like git or svn. You may have .git,
.svn folders and .gitignore files. If you are using IDE project files, you may have .idea hidden folder. Even there are chances of configuration files with common extensions, like config.json, config.yml, config.xml, package.json, .htaccess, README.md files to be present in the document root.
Even there are chances of having swap files, backup files to be there in the document root.

The solution for this problem is to prevent directory listing , remove the hidden folders, files and configuration files. We can even prevent the users from accessing this files with properly 
configuring the configuration files of the server like .htaccess files.',1);
INSERT INTO "kb_items" VALUES (10040,'Username enumeration','Description:

Whenever an application generates an error like:

"This username already exists"

An attacker could enumerate these usernames, enlarging his chance for a successful
bruteforce attack. Same goes for "Password forget" functions.

Whenever an user forgets his password, make him fill in his email address
rather than an username.

Mitigation:

All error messages should be generalized in order to prevent username enumeration.
Also sometimes you cannot avoid information leaking in functionalities such as a
registration page. Here you need to use tarpitting methods to prevent an automated
attack by an attacker.

',1);
INSERT INTO "kb_items" VALUES (10041,'GET POST requests','Description:

Authors of services which use the HTTP protocol SHOULD NOT use GETbased forms for the
submission of sensitive data, because this will cause this data to be
encoded in the RequestURI. Many existing servers, proxies,
and browsers will log the request URL in some place where it might be
visible to third parties. Servers can use POSTbased form submission instead.
GET parameters are also more likely to be vulnerable to XSS. Please refer to the
XSS manual in the knowledge base for more information.

Mitigation:

Whenever transmitting sensitive data always do this by means of the POST request or by header.
Note: Avoid userinput in your application header, this could lead to vulnerabilities.
Also make sure you disable all other HTTP request methods which are unnecessary for
your applications operation such as; REST, PUT, TRACE, DELETE, OPTIONS, etc, since
allowing these request methods could lead to vulnerabilities and injections.
',1);
INSERT INTO "kb_items" VALUES (10042,'Audit logs','Description:

An audit trail (also called audit log) is a securityrelevant chronological record,
set of records, and/or destination and source of records that provide documentary
evidence of the sequence of activities that have affected at any time a specific operation,
procedure, or event.

Mitigation:

An audit log should contain the following items:

 User ID
 Operation
 Success/failure of the operation
 Privileges
 Timestamp

Depending on the gravity of the users violation, there should also be a record kept for
each user to lock their accounts after a certain number of violations. This should be
applied since we can now assume it is an attacker trying to compromise your application.

Also when doing audit logs, make sure you always do logging before taking action in case the
action is not properly processed or terminated by your application. When using this
approach you are always in possession of an complete audit trail.
',1);
INSERT INTO "kb_items" VALUES (10043,'Re authentication','Description:

Whenever a user is changing credentials such as his password, the user should always be
challenged by the application to reauthenticate himself. This is in order to prevent an
attacker from changing credentials if ever an attacker could hijack another users session.

Mitigation:

Verify that the changing password functionality includes the old password,
the new password, and a password confirmation, as well as a passphrase strength indication
to encourage the adoption of strong password phrases. This same principle applies for other operations
that are considered critical such as changing an email adress or phone number.
',1);
INSERT INTO "kb_items" VALUES (10044,'Absolute session time out','Description:

All sessions should implement an absolute timeout, regardless of session activity.
This timeout defines the maximum amount of time a session can be active,
closing and invalidating the session upon the defined absolute period since the given
session was initially created by the web application. After invalidating the session,
the user is forced to (re)authenticate again in the web application and establish
a new session. The absolute session limits the amount of time an attacker can use a
hijacked session and impersonate the victim user.

Mitigation:

Always ensure that sessions absolute timeout  is on the serverside in order to decrease a hackers
attack vector.
',1);
INSERT INTO "kb_items" VALUES (10045,'Session Domain cookies','Description:

The Domain option allows you to specify whether or not to send the cookie to subdomains.

Mitigation:

Setting www.example.com will mean only the exact domain www.example.com will
be matched, while .example.com (wildcard) will also match again any
subdomain (forums.example.com, blog.example.com).

The use of a wildcard is not recommended at all and should be avoided.

There are a lot of different mitigations in order to harden your session management.
These mitigations are amongst others the setting of the "HttpOnly and secure" flags on
your sessions. Follow the "Sessions pattern" list to make sure your session management is
secure.

Recommended knowledge base items:

 Cross subdomain cookie attacks

',1);
INSERT INTO "kb_items" VALUES (10046,'Input rejection','Description:

Whenever the application detects malicious or unexpected userinput, you want to make sure
the application actual rejects the submitted userinput rather than directly process it.

Mitigation:

Verify that the application actually rejects the user requests whenever malicious input
is detected by your application. The base of this process will be checking the application
for expected userinput, for example: Whenever the user is filling in a form which
contains a checkbox, there are fixed values which your application can expect from
the user to return. Whenever this value differs from what the application served the user
as possible answers, you can assume the request was corrupted and you reject the request.

You must also keep track of the users movements by adding an audit trail as well as a
counter for tracking the number of his violations(submitting bad input) in your input
validation class. You should enforce a lockout whenever a unreasonable number of
violations are detected by your application in order to protect it from attackers.

',1);
INSERT INTO "kb_items" VALUES (10047,'Input validation','Description:

To ensure that the application is robust against all forms of input data, this data should
be sanitized and/or encoded on serverside since an attacker could otherwise easy bypass
these checks with an intercepting proxy.

Mitigation:

All input validation and encodingroutines should be implemented on the serverside
outside the reach of an attacker. Just as with the input rejection you should make sure that
after validating the userinput, whenever the input is bad it actually rejects, sanitizes
or formats your userinput into not malicious data.

The recommended method for validating user input would be the positive validation method.
Whitelist input validation means allowing only input that is explicitly defined as valid,
as opposed to blacklist input validation, which filters out known bad input.

You must also keep track of the users movements by adding an audit trail as well as a
counter for tracking the number of his violations(submitting bad input) in your input
validation class. You should enforce a lockout whenever a unreasonable number of
violations are detected by your application in order to protect it from attackers.


',1);
INSERT INTO "kb_items" VALUES (10048,'Single input validation controls','Description:

Input validation refers to the process of validating all the input to an application
before using it. Input validation is absolutely critical to application security,
and most application risks involve tainted input at some level.

Mitigation:

Verify that a single input validation control is used by the application for each
type of data that is accepted. This way your validation controls stay clear, transparent
and manageable. This method leaves less room for error.

',1);
INSERT INTO "kb_items" VALUES (10049,'CA certificates','Description:

In cryptography, a certificate authority or certification authority (CA) is an entity that
issues digital certificates. A digital certificate certifies the ownership of a public key
by the named subject of the certificate. Sometimes it happens that a CA goes bad and is
revoked from the browser. This will lead to untrusted TLS connections if your application
uses an issued certificate from this CA.

A selfsigned certificate is an identity certificate that is signed by the same entity whose identity it certifies. This term has nothing to do with the identity of the person or organization that actually performed the signing procedure. In technical terms a selfsigned certificate is one signed with its own private key.

In typical public key infrastructure (PKI) arrangements, a digital signature from a certificate authority (CA) attests that a particular public key certificate is valid. Each CA has one or more root keys; and the certificates associated with those public keys are "trust anchors" that use a special type of selfsigned certificates. Establishing trust of the CA root certificate is dependent upon procedures beyond checking its digital signature.

Mitigation:

In a CA based PKI system, the CA must be trusted by both parties. This is usually accomplished by placing the CA certificates in a whitelist of trusted certificates. For example, web browsers developers may use procedures specified by the CA/Browser Forum, or a private CA''''s certificate may be placed in the firmware of an embedded system. The trust issues of an entity accepting a new selfsigned certificate, is similar to the issues of an entity trusting the addition of a new CA certificate. The parties in a selfsigned PKI must establish trust with each other (using procedures outside the PKI), and confirm the accurate transfer of public keys (e.g. compare the hash out of band).

There are many subtle differences between CA signed and selfsigned certificates, especially in the amount of trust that can be placed in the security assertions of the certificate. Some CAs can verify the identity of the person to whom they issue a certificate; for example the US military issues their Common Access Cards in person, with multiple forms of other ID. The CA can attest identity values like these by including them in the signed certificate. The entity that validates the certificate can trust the information in that certificate, to the same extent that they trust the CA that signed it (and by implication, the security procedures the CA used to verify the attested information).

With a selfsigned certificate by contrast, trust of the values in the certificate are more complicated because the entity possesses the signing key, and can always generate a new certificate with different values. For example, the validity dates of a selfsigned certificate might not be trusted because the entity could always create and sign a new certificate that contained a valid date range. The values in a selfsigned certificate can be trusted when the following conditions are true: the values were (outofband) verified when the selfsigned was formally trusted, and there is a method to verify the selfsigned certificate has not changed after it was trusted. For example, the procedure of trusting a selfsigned certificate includes a manual verification of validity dates, and a hash of the certificate is incorporated into the white list. When the certificate is presented for an entity to validate, they first verify the hash of the certificate matches the reference hash in the whitelist, and if they match (indicating the selfsigned certificate is the same as the one that was formally trusted) then the certificate''''s validity dates can be trusted. Special treatment of X.509 certificate fields for selfsigned certificate can be found in RFC 3280.

Verify that connections to and from the server use trusted TLS certificates. Where internally generated or selfsigned certificates are used, the server must be configured to only trust specific internal CAs and specific selfsigned certificates. All others should be rejected.
',1);
INSERT INTO "kb_items" VALUES (10050,'Sandboxing','Description:

A sandbox is a security mechanism for separating running programs.
It is often used to execute untested code, or untrusted programs from
unverified third parties, suppliers, untrusted users and untrusted websites. It''''s creating
an extra layer of security where an attacker first needs to break out from.

Mitigation:

Examples of sandbox implementations include the following:
A jail: networkaccess restrictions, and a restricted file system namespace. Jails are most commonly used in virtual hosting.
Rulebased execution gives users full control over what processes are started, spawned (by other applications), or allowed to inject code into other applications and have access to the net, by having the system assign access levels to users or programs according to a set of determined rules. It also can control file/registry security (what programs can read and write to the file system/registry). In such an environment, viruses and Trojans have fewer opportunities of infecting a computer. The SELinux and AppArmor security frameworks are two such implementations for Linux.
Virtual machines emulate a complete host computer, on which a conventional operating system may boot and run as on actual hardware. The guest operating system runs sandboxed in the sense that it does not function natively on the host and can only access host resources through the emulator.
Sandboxing on native hosts: Security researchers rely heavily on sandboxing technologies to analyze malware behavior  By creating an environment that mimics or replicates the targeted desktops, researchers can evaluate how malware infects and compromises a target host. Numerous malware analysis services are based on the sandboxing technology.
Capability systems can be thought of as a finegrained sandboxing mechanism, in which programs are given opaque tokens when spawned and have the ability to do specific things based on what tokens they hold. Capabilitybased implementations can work at various levels, from kernel to userspace. An example of capabilitybased userlevel sandboxing involves HTML rendering in a Web browser.
Secure Computing Mode (seccomp) is a sandbox built in the Linux kernel. When activated, seccomp only allows the write(), read(), exit(), and sigreturn() system calls.
HTML5 has a "sandbox" attribute for use with iframes.
Java virtual machines include a sandbox to restrict the actions of untrusted code, such as a Java applet.
The .NET Common Language Runtime provides Code Access Security to enforce restrictions on a untrusted code.

```
',1);
INSERT INTO "kb_items" VALUES (10051,'Repudiation attack','Description:

A repudiation attack happens when an application or system does not adopt controls to
properly track and log users actions, thus permitting malicious manipulation or forging
the identification of new actions. This attack can be used to change the authoring
information of actions executed by a malicious user in order to log wrong data to log files.
Its usage can be extended to general data manipulation in the name of others,
in a similar manner as spoofing mail messages. If this attack takes place, the data stored
in log files can be considered invalid or misleading.

Mitigation:

This type of data should always be processed out of reach of the user and should be
verified and enforced serverside.
',1);
INSERT INTO "kb_items" VALUES (10052,'Server side validation','Description:

Validation of user supplied input must always be enforced on the server side.
Whenever validation of the input is being perfomed on the client side then
the constraints can easilly be bypassed whenever an attacker uses an intercepting proxy
which he can use to tamper data after they have been validated and send to the server. 

Or the attacker can simply change the constraint on the client side in his browser to bypass the 
constraints.

Mitigation:

All validation of input should be handled on the server side. Whenever the validation is handled on 
the server side, the validation logic is outside of the scope of the attacker and he can not influence
the results.

Note: Validation of input should never be done with a blacklisting aproach since attackers can be very
nifty in bypassing these type of constraints. Always perform white list validation checks preferably in
combination on type checking. i.e if the application expects the value to be an integer, do not make
the application accept a value of a string. This input should be logged and rejected.
',1);
INSERT INTO "kb_items" VALUES (10053,'HTTP header injection','Description:

HTTP header injection is a general class of web application security vulnerability which
occurs when Hypertext Transfer Protocol (HTTP) headers are
dynamically generated based on user input. Header injection in HTTP responses can allow
for HTTP response splitting (also known as CRLF, Carriage Return Line Feed),
Session fixation via the SetCookie header, crosssite scripting (XSS),
and malicious redirect attacks via the location header. HTTP header injection is a
relatively new area for webbased attacks, and has primarily been pioneered
by Amit Klein in his work on request/response smuggling/splitting.
Vulnerabilities due to HTTP header injections such as CRLF are no longer
feasible due to the fact that multiple header requests are not possible.

Mitigation:

When userinput will be used in HTTP headers then the newlines should be escaped in a
correct manner. Recommended would be a whitelist of expected input or use a validation method
which for example only accepts alphanumeric values. Every detection of input which is out of
the intended operation should be rejected.
',1);
INSERT INTO "kb_items" VALUES (10054,'Enforce sequential step order','Description:

Whenever a functionality consists out of following several steps to achieve some goal i.e,

User adds items to chart > User enters shipping information > User pays for goods > Items will be shipped.
You want to make sure the user can not skip the payment step in order to receive his goods.

Mitigation:

In order to verify that this stage was run through by a sincere user you want to enforce
the application to only process business logic flows in sequential step order, with all
steps being processed in realistic human time, and not process out of order, skipped steps,
processed steps from another user, or too quickly submitted transactions.

',1);
INSERT INTO "kb_items" VALUES (10055,'Step up or adaptive authentication','Description:

Whenever a user browses a section of a webbased application that contains sensitive information the user should be challenged authenticate again using a higher assurance credential to be granted access to this information.
This is to prevent attackers from reading sensitive information after they successfully hijacked a user account.


Mitigation:

Verify the application has additional authorization (such as step up or adaptive authentication) so the user is challenged before being granted access to sensitive information. This rule also applies for making critical changes to an account or action.
Segregation of duties should be applied for highvalue applications to enforce antifraud controls as per the risk of application and past fraud.

',1);
INSERT INTO "kb_items" VALUES (10056,'Cross origin resource sharing','Description:

Cross Origin Resource Sharing or CORS is a mechanism that enables a web browser to perform
''''crossdomain'''' requests using the XMLHttpRequest L2 API in a controlled manner.
In the past, the XMLHttpRequest L1 API only allowed requests to be sent within the same
origin as it was restricted by the same origin policy.

Mitigation:

CrossOrigin requests have an Origin header, that identifies the domain initiating the request and is always sent to the server. CORS defines the protocol to use a web browser and a server to determine whether a crossorigin request is allowed. In order to accomplish this goal, there are a few HTTP headers involved in this process, that are supported by all major browsers:

 Origin
 AccessControlRequestMethod
 AccessControlRequestHeaders
 AccessControlAllowOrigin
 AccessControlAllowCredentials
 AccessControlAllowMethods
 AccessControlAllowHeaders

Things you must consider when using CORS

1. Validate URLs passed to XMLHttpRequest.open. Current browsers allow these URLs to be
cross domain; this behavior can lead to code injection by a remote attacker. Pay extra
attention to absolute URLs.

2. Ensure that URLs responding with AccessControlAllowOrigin: * do not include any
sensitive content or information that might aid an attacker in further attacks.
Use the AccessControlAllowOrigin header only on chosen URLs that need to be
accessed crossdomain. Don''''t use the header for the whole domain.

3. Allow only selected, trusted domains in the AccessControlAllowOrigin header.
Prefer whitelisting domains over blacklisting or allowing any domain
(do not use * wildcard nor blindly return the Origin header content without any checks)

4. Keep in mind that CORS does not prevent the requested data from going to an
unauthenticated location. It''''s still important for the server to perform usual
CSRF prevention.

5. While the RFC recommends a preflight request with the OPTIONS verb, current
implementations might not perform this request, so it''''s important that "ordinary"
(GET and POST) requests perform any access control necessary.

6. Discard requests received over plain HTTP with HTTPS origins to prevent mixed
content bugs.

7. Don''''t rely only on the Origin header for Access Control checks. Browser always sends
this header in CORS requests, but may be spoofed outside the browser.
Applicationlevel protocols should be used to protect sensitive data.

**NOTE:** 
Modern application frameworks do dynamically allocation of the origin header, resulting in the browser
also allowing to send the "AccessControlAllowCredentials: true" header as well in requests. 
Whenever JSON web tokens are being send in cookies rather than headers, potential attackers could abuse this behaviour to 
make unauthenticated XHR get requests on the authenticated users behalf to read sensitive information from the 
pages.
',1);
INSERT INTO "kb_items" VALUES (10057,'Principle of least privilege','Description:

The principle of least privilege recommends that accounts have the least amount of
privilege required to perform their business processes. This encompasses user rights,
resource permissions such as CPU limits, memory, network, and file system permissions.

Mitigation:

The principle means giving a user account only those privileges which are essential to
that user’s work. For example, a backup user does not need to install software: hence,
the backup user has rights only to run backup and backuprelated applications.
Any other privileges, such as installing new software, are blocked.

The principle applies also to a personal computer user who usually does work in a normal
user account, and opens a privileged, password protected account (that is, a superuser)
only when the situation absolutely demands it.

This principle can also be applied to your webapplications. Instead of solely depending
on role based authentication methods using sessions, we rather want to assign privileges
to users by means of a DatabaseBased Authentication system.

We still use sessions in order to identify if the user was logged in correctly, only now
instead of assigning that user with a specific role we assign him with privileges to
verify which actions he is privileged to perform on the system.

Also, a big pro of this method is, whenever a user has to be assigned fewer privileges
your changes will be applied on the fly since the assigning does not depend on the session
which otherwise had to expire first.
',1);
INSERT INTO "kb_items" VALUES (10058,'Character encoding','Description:

Character encoding is the process of mapping characters, numbers and other symbols to a
standard format. Typically, this is done to create a message ready for transmission
between sender and receiver. It is, in simple terms, the conversion of characters
(belonging to different languages like English, Chinese, Greek or any other known language)
into bytes. An example of a widely used character encoding scheme is the American
Standard Code for Information Interchange (ASCII) that initially used 7bit codes.
More recent examples of encoding schemes would be the Unicode UTF8 and UTF16 computing
industry standards. In the space of application security and due to the plethora of
encoding schemes available, character encoding has a popular misuse. It is being used for
encoding malicious injection strings in a way that obfuscates them. This can lead to the
bypass of input validation filters, or take advantage of particular ways in which browsers
render encoded text.

Mitigation:

When trying to figure out the character encoding of a resource, user agents will try, in
this order:

 The HTTP ContentType header sent by the server
 The XML declaration (only for XHTML documents)
 HTML/XHTML meta element.

Make sure this information is provided by your application for the server in order to
prevent it from guessing the wrong encoding standard, leaving room for injection.

 Note:

These three ways of providing the character encoding of a document are not
equivalent.
',1);
INSERT INTO "kb_items" VALUES (10059,'HTTP request methods','Description:

HTTP offers a number of methods that can be used to perform actions on the web server.
Many of these methods are designed to aid developers in deploying and testing
HTTP applications. These HTTP methods can be used for nefarious purposes if the web
server is misconfigured. It recommended to read about the different available methods, their purposes and
limitations.

Available method are:

GET
The GET method requests a representation of the specified resource. Requests using GET should only retrieve data and should have no other effect. (This is also true of some other HTTP methods.)[1] The W3C has published guidance principles on this distinction, saying, "Web application design should be informed by the above principles, but also by the relevant limitations.

HEAD
The HEAD method asks for a response identical to that of a GET request, but without the response body. This is useful for retrieving metainformation written in response headers, without having to transport the entire content.

POST
The POST method requests that the server accept the entity enclosed in the request as a new subordinate of the web resource identified by the URI. The data POSTed might be, for example, an annotation for existing resources; a message for a bulletin board, newsgroup, mailing list, or comment thread; a block of data that is the result of submitting a web form to a datahandling process; or an item to add to a database.


PUT
The PUT method requests that the enclosed entity be stored under the supplied URI. If the URI refers to an already existing resource, it is modified; if the URI does not point to an existing resource, then the server can create the resource with that URI.


DELETE
The DELETE method deletes the specified resource.


TRACE
The TRACE method echoes the received request so that a client can see what (if any) changes or additions have been made by intermediate servers.

OPTIONS
The OPTIONS method returns the HTTP methods that the server supports for the specified URL. This can be used to check the functionality of a web server by requesting ''''*'''' instead of a specific resource.

CONNECT
The CONNECT method converts the request connection to a transparent TCP/IP tunnel, usually to facilitate SSLencrypted communication (HTTPS) through an unencrypted HTTP proxy.

PATCH
The PATCH method applies partial modifications to a resource.

Some of the methods (for example, GET, HEAD, OPTIONS and TRACE) are, by convention, defined as safe, which means they are intended only for information retrieval and should not change the state of the server. In other words, they should not have side effects, beyond relatively harmless effects such as logging, web caching, the serving of banner advertisements or incrementing a web counter. Making arbitrary GET requests without regard to the context of the application''''s state should therefore be considered safe. However, this is not mandated by the standard, and it is explicitly acknowledged that it cannot be guaranteed.

Despite the prescribed safety of GET requests, in practice their handling by the server is not technically limited in any way. Therefore, careless or deliberate programming can cause nontrivial changes on the server. This is discouraged, because it can cause problems for web caching, search engines and other automated agents, which can make unintended changes on the server. For example, a website might allow deletion of a resource through a URL such as http://example.com/article/1234/delete, which, if arbitrarily fetched, even using GET, would simply delete the article.

By contrast, methods such as POST, PUT, DELETE and PATCH are intended for actions that may cause side effects either on the server, or external side effects such as financial transactions or transmission of email. Such methods are therefore not usually used by conforming web robots or web crawlers; some that do not conform tend to make requests without regard to context or consequences.

Methods PUT and DELETE are defined to be idempotent, meaning that multiple identical requests should have the same effect as a single request (note that idempotence refers to the state of the system after the request has completed, so while the action the server takes (e.g. deleting a record) or the response code it returns may be different on subsequent requests, the system state will be the same every time). Methods GET, HEAD, OPTIONS and TRACE, being prescribed as safe, should also be idempotent, as HTTP is a stateless protocol.

In contrast, the POST method is not necessarily idempotent, and therefore sending an identical POST request multiple times may further affect state or cause further side effects (such as financial transactions). In some cases this may be desirable, but in other cases this could be due to an accident, such as when a user does not realize that their action will result in sending another request, or they did not receive adequate feedback that their first request was successful. While web browsers may show alert dialog boxes to warn users in some cases where reloading a page may resubmit a POST request, it is generally up to the web application to handle cases where a POST request should not be submitted more than once.

Note that whether a method is idempotent is not enforced by the protocol or web server. It is perfectly possible to write a web application in which (for example) a database insert or other nonidempotent action is triggered by a GET or other request. Ignoring this recommendation, however, may result in undesirable consequences, if a user agent assumes that repeating the same request is safe when it is not.

The TRACE method can be used as part of a class of attacks known as crosssite tracing; for that reason, common security advice is for it to be disabled in the server configuration. Microsoft IIS supports a proprietary "TRACK" method, which behaves similarly, and which is likewise recommended to be disabled

Mitigation:

Verify that the application accepts only a defined set of HTTP request methods, such as
GET and POST and unused methods are explicitly blocked/disabled.
',1);
INSERT INTO "kb_items" VALUES (10060,'HTML Caching and client side caching','Description:

Developers creating HTML5 applications can create fully offlineaware applications using
the HTML5 ApplicationCache interface. The Application Cache uses a cache manifest file to
specify which files in an HTML5 application can be used offline, and which files require a
network connection.

Mitigation:

Never store sensitive information in a client side cache since this can be easily
compromised by attackers. The same principle does also apply to autocomplete functions.

Recommended knowledge base item:

 Caching headers
 Client side storage
',1);
INSERT INTO "kb_items" VALUES (10061,'Automatic parameter binding','Description:

If the application framework allows automatic mass parameter assignment
(also called automatic variable binding) from the inbound request to a model,
verify that security sensitive fields such as ''''accountBalance'''', ''''role'''' or ''''password''''
are protected from malicious automatic binding. Whenever your application takes parameters
in HTTPs GET statement and passes them as variables to code within the application this
could become a safety hazard since the application processes these variables
in his operations.

Mitigation:

When working with automatic variable binding you should create whitelists of what
parameters are expected and allow only these parameters to be passed into your
application operation.
',1);
INSERT INTO "kb_items" VALUES (10062,'Access control pattern','Description:

For successful access control/login functionality there are a lot of things to take into
consideration before you start developing this type of functionality.

Mitigation:

It is highly recommended to study all the listed items and implement these principles in
your access control/login system in order to enforce a higher level of security.

1. Audit logs
2. Principle of least privilege (Privilege based authentication system)
3. Passwords must be encrypted, salted and stretched
4. CrossSite Request Forgery (CSRF for authenticated forms)
5. Session pattern
6. Session fixation
7. Session hijacking
8. Forget password functions
9. Client side authentication
10. Client side state management
11. Cross subdomain cookie attack
',1);
INSERT INTO "kb_items" VALUES (10063,'Password forget pattern','Description:

Whenever you are implementing a forgot password function into your system there are
a few things you need to take into consideration in order to prevent security flaws
in your application.

1. Forget password functions
2. Denial of service by locking out accounts
3. Username enumeration
4. Does The application enforce the use of secure passwords
5. Disallow the use of old passwords

Mitigation:

The first thing is verify the password has been forgotten and other recovery paths send a link including a timelimited activation token rather than the password itself.
Additional authentication based on softtokens (e.g. SMS token, native mobile applications, etc.) can be required as well before the link is sent over.
Second, you should not lock out the user’s account whilst the process of getting a new password is in progress. This could lead to a Denial of service attack whenever an attacker decides to intentionally lock out the users with an automated attack.
Third, whenever the new password request was set in progress, the message you display should be generalized in order to prevent username enumeration.
Fourth, always disallow the use of old passwords and implement a strong password policy.

',1);
INSERT INTO "kb_items" VALUES (10064,'SQL injection Column truncation','Description:

Whenever an applications structural logic mismatches with the database structural logic an attacker gains the opportunity to truncate his submit towards your database column by submitting a value longer than the limit allowed in the database.
Imagine you have a system where users can register themselves.

The attacker can abuse this behavior of the database to overflow the length limit and truncate his submit and register himself as the admin, thus gaining its privileges.


Mitigation:

On critical places where unique values are enforced and expected,
such as usernames in order to authorize or distribute certain privileges. The users submit
should be checked on the server side in order to verify if it does not exceed the limit
set in your database.
',1);
INSERT INTO "kb_items" VALUES (10065,'Cross subdomain cookie attack','Description:

A quick overview of how it works:

1. A website www.example.com hands out subdomains to untrusted third parties
2. One such party, Mallory, who now controls evil.example.com, lures Alice to her site
3. A visit to evil.example.com sets a session cookie with the domain .example.com on Alice''''s browser
4. When Alice visits www.example.com, this cookie will be sent with the request, as the specs for cookies states, and Alice will have the session specified by Mallory''''s cookie.
5. Mallory can now use Alice her account.

Mitigation:

In this scenario changing the sessionID on login does not make any difference since
Alice is already logged in when she visits Mallory''''s evil web page.

It is good practice to use a completely different domain for all trusted activity.

For example Google uses google.com for trusted activities and *.googleusercontent.com
for untrusted sites.

Also when setting your cookies to specify which domains they are allowed to
be send to. Especially on your trusted domain you do not want to leak cookies to unintended
subdomains. highly recommended is to not use wildcards when setting this option.
',1);
INSERT INTO "kb_items" VALUES (10066,'RFD and file download injections','Description:

Reflective file download occurs whenever an attacker can "forge" a download through misconfiguration in your "disposition" and "content type" headers. Instead of having the attacker to upload an evil file to the web server he can now force the browser to download a malicious file by abusing these headers and setting the file extension to any type he wants.

Now, whenever there is also userinput being reflected back into that download it can be used to forge evil attacks. The attacker can present an evil file to ignorant victim''''s who are trusting the domain of which the download was presented from.

File download injection is a similar type of attack except this attack is made possible whenever there is userinput that is reflected into the "filename=" parameter in the "disposition" header. The attacker again can force the browser to download a file with his own choice of extension and set the content of this file by injecting this directly into the response like filename=evil.bat%0A%0D%0A%0DinsertEvilStringHere

Whenever the user now opens the downloaded file the attacker can gain full control over the target’s device.


Mitigation:

First, never use user input directly into your headers since an attacker can now take control over it.

Secondly, you should check if a filename really does exist before presenting it towards the users. You could also create a whitelist of all files which are allowed to be downloaded and terminate requests whenever they do not match.

Also, you should disable the use of "path parameters". It increases the attacker’s attack vector and these parameters also cause a lot of other vulnerabilities.
And last you should sanitize and encode all your userinput as much as possible. Reflective file downloads depend on userinput being reflected in the response header. Whenever this input has been sanitized and encoded it should not do any harm to any system it is being executed on

',1);
INSERT INTO "kb_items" VALUES (10067,'Forward secrecy ciphers','Description:

In cryptography, forward secrecy (FS; also known as perfect forward secrecy, or PFS) is a property of keyagreement protocols ensuring that a session key derived from a set of longterm keys cannot be compromised if one of the longterm keys is compromised in the future. The key used to protect the transmission of data must not be used to derive any additional keys, and if the key used to protect the transmission of data is derived from some other keying material, then that material must not be used to derive any more keys. In this way, compromise of a single key permits access only to data protected by that single key.

Mitigation:

In the beginning SSL handshake, the client sends a list of supported cipher suites (among other things). The server then picks one of the cipher suites, based on a ranking, and tells the client which one they will be using.

This step is the one that determines whether or not the future connection will have perfect forward secrecy. Note that, at this point, certificates have not entered the picture at all. This is because whether or not a connection has perfect forward secrecy is determined by how the session key is derived. And how the session key is derived is determined by the cipher suite in use. So, the cipher suites that use ephemeral DiffieHellman (DHE) or the elliptic curve variant (ECDHE) will have perfect forward secrecy while the other options will not.
',1);
INSERT INTO "kb_items" VALUES (10068,'STRIDE','Description:

STRIDE is a collective for a series of vulnerabilities your applications should
cover in order to harden your applications security.

STRIDE stands for:
Spoofing
Tampering
Repudiation
Information Disclosure
Elevation of privilege

Mitigation:

The STRIDE was initially created as part of the process of threat modelling. STRIDE is a model of threats, used to help reason and find threats to a system. It is used in conjunction with a model of the target system that can be constructed in parallel. This includes a full breakdown of processes, data stores, data flows and trust boundaries.

Today it is often used by security experts to help answer the question "what can go wrong in this system we''''re working on?"
',1);
INSERT INTO "kb_items" VALUES (10069,'Limiting user input size','Description:

Whenever there is userinput supplied into your application you also want to limit
the size of the userinput to appropriate maximum lengths.

Mitigation:

Verify all the user input has been limited and the application only accepts expected input 
lengths
',1);
INSERT INTO "kb_items" VALUES (10070,'XML attacks','Description:

Whenever you are using XML in your application there are a few possibilities for
injections depending on how you are applying XML in your system.

Extensible Markup Language (XML) is a markup language that defines a set of rules for
encoding documents in a format which is both humanreadable and machinereadable. It is
defined by the W3C''''s XML 1.0 Specification and by several other related specifications,
all of which are free open standards.

Mitigation:

Items listed below are recommended to read whenever you are planning to use XML in your
application.

Recommended knowledge base items:

 XML injection
 External DTD parsing
 XSLT injections
 XPath injections
 XXE injections
',1);
INSERT INTO "kb_items" VALUES (10071,'Auto escaping technology','Description:

Some frameworks/templates have the option to autoescape all incoming userinput to harmless
encoded data in order to prevent attacks. However, this autoescaping functionality is also
optional to be disabled. Whenever this autoescaping function has been disabled your application
might be vulnerable to attacks like XSS.

Mitigation:

Whenever autoescaping functionality in your application has been disabled for whatever reason, you
should make sure there is other protection in place like a HTML sanitizer in order to
prevent attackers from injecting malicious code into your application.
',1);
INSERT INTO "kb_items" VALUES (10072,'Hardware key vault','Description:

Keys should remain in a protected key vault at all times. In particular, ensure that there
is a gap between the threat vectors that have direct access to the data and the threat
vectors that have direct access to the keys. This implies that keys should not be stored
on the application or web server (assuming that application attackers are part of the
relevant threat model).

Mitigation:

Verify that all consumers of cryptographic services do not have direct access to key material.
Isolate cryptographic processes, including master secrets and consider the use of a hardware key vault (HSM).
',1);
INSERT INTO "kb_items" VALUES (10073,'SOAP basic profile','Description:

Simple Soap Binding Profile is a specification from the Web Services Interoperability industry consortium. It
is intended as a support profile for the WSI Basic Profile. This profile defines the way WSDL
documents are to bind operations to a specific transport protocol SOAP.

Mitigation:

Verify that the SOAP based web services are making use of the WSI Basic profile. To be compliant with this standard, it essentially means the application infrastructure must be TLS protected.

Source:
http://www.wsi.org/Profiles/SimpleSoapBindingProfile1.0.html
',1);
INSERT INTO "kb_items" VALUES (10074,'Sanitize unstructured data','Description:

Verify that unstructured data is sanitized to enforce generic safety measures. When this is not
setup an attacker can use this unstructured data to harm the application and perform injections.

Mitigation:

Unstructured data needs to be sanitized to enforce generic safety measures for example:

 allowed characters
 character length,

Also some characters are potentially harmful in given context and thus should be escaped.
(e.g. natural names with Unicode or apostrophes, such as &x306D;&x3053; or O''''Hara)
',1);
INSERT INTO "kb_items" VALUES (10075,'PII protection','Description:

There should be extra care taken into account when you are dealing with 

 PII(personal identifiable information) 
 Fincancial data ( credit history, tax records, pay history, beneficiaries)
 Health data (medical records, medical device details, or deanonymized research records)

There are multiple laws in countries that demand proper protection by
means of SSL/TLS for when the data is in transit and encrypted with pub priv key system
when stored on the disk. This is needed to protect the user from identity theft and fraud.

Mitigation:

Personally Identifiable Information needs to be stored encrypted at rest ideally in a secured environment such as your vault.
In addition to being able to store secrets, a Vault can be used to encrypt/decrypt data that is stored elsewhere. The primary use of this is to allow applications to encrypt their data while still storing it in the primary data store.

The benefit of this is that developers do not need to worry about how to properly encrypt data. The responsibility of encryption is on Vault and the security team managing it, and developers just encrypt/decrypt data as needed.

Also, ensure that all communication goes via protected channels like SSL/TLS. 
',1);
INSERT INTO "kb_items" VALUES (10076,'Principle of least privilege','Description:

The application should always be request minimal permissions for required functionality and
resources. This is also known as principle of least privilege. The principle of least privilege 
recommends that accounts have the least amount of privilege required to perform their 
business processes. This encompasses user rights, resource permissions such as CPU limits, 
memory, network, and file system permissions. 

Whenever the application is compromised by a potential attacker, the attacker does not gain more arbitrary control over the victim''''s device

Mitigation:

Verify that the application is requesting minimal permissions for required functionality and
resources.

',1);
INSERT INTO "kb_items" VALUES (10077,'CSRF on REST','Description:

CrossSite Request Forgery (CSRF) is a type of attack that occurs when a malicious Web site,
email, blog, instant message, or program causes a users Web browser to perform an unwanted
action on a trusted site for which the user is currently authenticated.

The impact of a successful crosssite request forgery attack is limited to the
capabilities exposed by the vulnerable application. For example, this attack could result
in a transfer of funds, changing a password, or purchasing an item in the users context.
In effect, CSRF attacks are used by an attacker to make a target system perform a
function (funds Transfer, form submission etc.) via the targets browser without
knowledge of the target user at least until the unauthorized function has been committed.

Mitigation:

REST (REpresentational State Transfer) is a simple stateless architecture that generally runs
over HTTPS/TLS. The REST style emphasizes that interactions between clients and services are
enhanced by having a limited number of operations

Since the architecture is stateless, the application should make use of sessions or cookies to
store the HTTP sessions, which allow associating information with individual visitors. The preferred method for REST
services is to utilize tokens for interactive information interchange between the user and the server. 

By sending this information solely by means of headers, the application is no longer susceptible to CSRF attacks
since the CSRF attack utilizes the browsers cookie jar for succesful attacks.
',1);
INSERT INTO "kb_items" VALUES (10078,'File upload anti virus check','Description:

whenever files from untrusted services are uploaded to the server, there should be additional checks
in place to verify whether these files contain viruses (malware, trojans, ransomware). 

Mitigation:

After uploading the file, the file should be placed in quarantine and antivirus has to 
inspect the file for malicious viruses. Antivirus software that has a commandline interface is 
requisite for doing such scans. There are also API''''s available for other services such as
from "VirusTotal.com" 

This site provides a free service in which your file is given as input to 
numerous antivirus products and you receive back a detailed report with the evidence resulting from 
the scanning process
',1);
INSERT INTO "kb_items" VALUES (10079,'File upload outside document root','Description:

Files that are uploaded by users or other untrusted services should always be placed outside
of the document root. This is to prevent malicious files from being parsed by attackers such as PHP/HTML/Javascript files.

Should an attacker succeed to bypass file upload restrictions and upload a malicous file, it would
be impossible for the attacker to parse these files since they are not located inside of the
applications document root.

Mitigation:

Files should be stored outside of the applications document root. Preferably files should be stored
on a seperate file server which serves back and forth to the application server. 

Files should always be stored outside of the scope of the attacker to prevent files from
being parsed or executed.

When storing files outside of the document root, take into consideration potential path traversal injections
in the applications file name such as "../html/backtoroot/file.php". Whenever this filename is being used directly
into the path that is used to store files, it could be used to manipulate the storage path.
',1);
INSERT INTO "kb_items" VALUES (10080,'High value transactions','Description:

Whenever there are high value transactions a normal username/password static authentication method does
not suffice to ensure a high level of security. Whenever the application digests high level of transactions ensure that
risk based reauthentication, two factor or transaction signing is in place.

Mitigation:

1 risk based authentication:
In Authentication, riskbased authentication is a nonstatic authentication 
system which takes into account the profile of the agent requesting access to 
the system to determine the risk profile associated with that transaction. 

The risk profile is then used to determine the complexity of the challenge.
Higher risk profiles leads to stronger challenges, whereas a static username/password may suffice for 
lowerrisk profiles. Riskbased implementation allows the application to challenge the user for additional 
credentials only when the risk level is appropriate.

2 two factor authentication:
Multifactor authentication (MFA) is a method of computer access control in which a user is 
granted access only after successfully presenting several separate pieces of evidence to an 
authentication mechanism – typically at least two of the following categories: knowledge (something they know), 
possession (something they have), and inherence (something they are)

3 Transaction signing:
Transaction signing (or digital transaction signing) is the process of calculating a keyed hash function 
to generate a unique string which can be used to verify both the authenticity and integrity of an online transaction.

A keyed hash is a function of the user''''s private or secret key and the transaction details, 
such as the transfer to the account number and the transfer amount.

To provide a high level of assurance of the authenticity and integrity of 
the hash it is essential to calculate the hash on a trusted device, such as a separate smart card reader.
Calculating a hash on an Internetconnected PC or mobile device such as a mobile telephone/PDA would be
counterproductive as malware and attackers can attack these platforms and potentially subvert the signing process itself.
',1);
INSERT INTO "kb_items" VALUES (10081,'Log injection','Description:

Log injection problems are a subset of injection problem, in which invalid entries taken
from user input are inserted in logs or audit trails, allowing an attacker to mislead
administrators or cover traces of an attack. Log injection can also sometimes be used to
attack log monitoring systems indirectly by injecting data that monitoring systems will
misinterpret.


Mitigation:

You should consider these three controls when implementing logging systems.

 Design: If at all possible, avoid logging data that came from external inputs.

 Implementation: Ensure that all log entries are statically created, or if they must
  record external data that the input is vigorously whitelist checked.

 Run time: Avoid viewing logs with tools that may interpret control characters in the
  file, such as commandline shells.

Also verify that all nonprintable symbols and field separators are properly encoded in log entries,
to prevent log injection.
',1);
INSERT INTO "kb_items" VALUES (10082,'TLS settings are in line with current leading practice','Description:

TLS settings must always be in line with current leading practice. Whenever TLS
settings and ciphers get outdated, the TLS connection can be degraded/broken and used by
attackers to eavesdrop on users traffic over the application.

Mitigation:

There should be structural scans that are done regularly against the applications TLS settings
and configurations to check whether the TLS settings are in line with current leading practice.

This could be achieved by using the SSLLabs api or the OWASP OSaft project.

OSaft is an easy to use tool to show informations about SSL certificate and tests the SSL 
connection according to a given list of ciphers and various SSL configurations.

It''''s designed to be used by penetration testers, security auditors or server administrators. 
The idea is to show the important information or the special checks with a simple call of the tool.
However, it provides a wide range of options so that it can be used for comprehensive and special 
checks by experienced people.

While doing these tests also take into consideration the following configuration on the server
side:

Verify that old versions of SSL and TLS protocols, algorithms, ciphers, and configuration are 
disabled, such as SSLv2, SSLv3, or TLS 1.0 and TLS 1.1. The latest version of TLS should be the 
preferred cipher suite.

',1);
INSERT INTO "kb_items" VALUES (10083,'Data retention policy','Description:

For all the data gathered in an application, there should be set up a data retention policy
to make sure all the data is removed from the application when it is no longer used. This reduces
the damage done by potential attackers when they get access to the applications data due to a breach.

Mitigation:

All the sensitive information within the application must be mapped along with the 
timeframe it is necessary to store this data on the application. For each data set it
must be determined how to effectively clear this information from the application.

',1);
INSERT INTO "kb_items" VALUES (10084,'Authenticated data cleared from client storage','Description:

All authenticated data should be removed from the browsers storage as soon as
the session is terminated. This reduces the possibility that a potential attacker gains
sensitive authenticated information whenever the application is attacked.

This approach also is necessary to disable unauthenticated users to access the information
if the user was initially logged in on a public computer.

Mitigation:

Whenever the user terminates his session all sensitive authenticated information should be 
cleared from the browser in the client storage. such as:

* local storage
* Session storage
* web SQL
* Cache storage
* Application cache
* etc
',1);
INSERT INTO "kb_items" VALUES (10085,'All error handling logic must fail securely','Description:

Handling errors securely is a key aspect of secure coding.
There are two types of errors that deserve special attention. The first is exceptions
that occur in the processing of a security control itself. It''''s important that these
exceptions do not enable behavior that the countermeasure would normally not allow.
As a developer, you should consider that there are generally three possible outcomes
from a security mechanism:

1. Allow the operation
2. Disallow the operation
3. Exception

In general, you should design your security mechanism so that a failure will follow the same execution path
as disabling the operation

Mitigation:

Make sure all the error handling logic is thoroughly tested for failing securely before
using it in your application. It is common that complete unittest are created especially
for this purpose.
',1);
INSERT INTO "kb_items" VALUES (10086,'Display concurrent and active sessions','Description:

Whenever the user is presented a summary of all concurrent sessions, this decreases a potentially
succesful hijacking attack since the user can now see all sessions and terminate one whenever
it does not feel trusted.

Mitigation:

The user should be presented with all concurrent and active sessions in his profile/account 
summary. This way the user can keep track of what is happening and can choose to terminate a 
session whenever it feels untrusted. 

Whenever the user shared permission to other applications by means of for example OAuth,
than the user should also be presented that have shared permissions along with the type of permissions 
and activation date.

',1);
INSERT INTO "kb_items" VALUES (10087,'Centralized the mechanisms for protecting resources and the access','Description:

Applications have often different ways for granting access to protected resources, sometimes these are 
done based on a role that is defined in a Database or using an Active Directory permission. Also, external
authorization services may be implemented and needed for the application. With all these different ways 
for protecting resources and the access to these assets mistakes will be easily made. 

Mitigation:

Immplement a centralized mechanism where all the different types of resources and grating access to 
these resources (including libraries that call external authorization services) are located. This way
it''''s easier to maintain and the lower the complexity.

This centralized solution should also contain sufficient logging and monitoring to detect account abuse or breaches.
',1);
INSERT INTO "kb_items" VALUES (10088,'Third party components','Description: 

All third party components the application depends on to operate must be mapped in
terms of the functions, and/or security functions, they provide for several reasons.

1. Whenever one of these dependencies is down the application has to handle the missing of
   that dependency gracefully and not break down resulting in a DOS.

2. All security functions they provide must be mapped and backed up by a WAF or ModSecurity in case
   the dependency goes down for service.

Mitigation:

Verify that all components that are not part of the application but that the application
relies on to operate are defined in terms of the functions, and/or security functions, they provide.
',1);
INSERT INTO "kb_items" VALUES (10089,'Policy for processing sensitive data','Description: 

Some data on an application can be consider sensitive due to its importance:
 Social security number
 Credit card or banking information
Or by the context of the information:
 Passphrase used as a password of an application
 University restricted or critical data

On applications, data considered sensitive should be kept safe. The way we secure the data could be defined by us, but some information it should be made according to a standard  i.e. all applications that manipulate credit card information should comply with one of the pci standards.


Mitigation:

Identify the list of sensitive data that is being processed by the application.

Establish, maintain, and disseminate a security policy for processing and storing sensitive data. If information should be encrypted, separated in another database, etc. If exist, follow the appropriate standard.
',1);
INSERT INTO "kb_items" VALUES (10090,'Server side request forgery','Description:

Server Side Request Forgery (SSRF) attack, where an attacker abuse the functionality of a
vulnerable web application to send crafter request which which read or update internal 
resources. Attacker can attack an internal network or application behind the firewall with
this attack which is normally not accessible through external network and even attack the
internal network web applications.

SSRF attack can be used to make requests to other internal resources for accessing the 
metadata and to run a port can on the internal network. URL schema such as file:// can
be used to read the file from the server. Attackers can use legacy URL schemas such as 
dict, gopher, expect etc which can even cause remote code execution.

Mitigation:

Disable unused URL schemas which are dangerous like expect://, file:///, ftp://, gopher://.
Proper whitelisting of domain or IP address which you need to access to. Response received from 
the internal server should not be shown to the attacker. Some services like Memcached, Redis, Elasticsearch and MongoDB do not require authentication by default, so we need to enable 
authentication for these services.
',1);
INSERT INTO "kb_items" VALUES (10091,'Tabnabbing','Description:

Reverse tabnabbing is an attack where a page linked from the target page is able to rewrite that page, 
for example to replace it with a phishing site. As the user was originally on the correct page they are 
less likely to notice that it has been changed to a phishing site, especially it the site looks the same as the target. 
If the user authenticates to this new page then their credentials (or other sensitive data) are sent to the phishing site rather than the legitimate one.

As well as the target site being able to overwrite the target page, any http link can be spoofed to overwrite the target 
page if the user is on an unsecured network, for example a public wifi hotspot. The attack is possible even if the target 
site is only available via https as the attacker only needs to spoof the http site that is being linked to.

Mitigation:

To prevent this issue the following actions are available:

Cut the back link between the parent and the child pages:
  For html link:
   * To cut this back link then add the attribute rel="noopener" on the 
     tag used to create the link from the parent page to the child page. 
     This attribute value cut the link but, depending on the browser, let referrer
     information be present in the request to the child page.
   * To remove also the referrer information then use this attribute value: rel="noopener noreferrer".
  For javascript window.open function, add the values noopener,noreferrer in the windowFeatures parameter of the window.open function.

As the behavior using the elements above is different between the browsers either using html 
link or javascript to open a window (or tab) then use this configuration to maximize the cross supports:

* For html link, add the attribute rel="noopener noreferrer" for every links.
* For Javascript, use this function to open a window (or tab):

  function openPopup(url, name, windowFeatures){
    //Open the popup and set the opener and referrer policy instruction
    var newWindow = window.open(url, name, ''''noopener,noreferrer,'''' + windowFeatures);
    //Reset the opener link
    newWindow.opener = null;
  }
  
Add the HTTP response header ReferrerPolicy: noreferrer the every HTTP responses send by the application
(Header ReferrerPolicy information). This configuration will ensure that no referrer information is sent along with requests from page.
',1);
INSERT INTO "kb_items" VALUES (10092,'Insecure direct object references','Description:

Applications frequently use the actual name or key of an object when generating web pages. 
Applications don’t always verify the user is authorized for the target object. 
This results in an insecure direct object reference flaw. Testers can easily manipulate parameter 
values to detect such flaws and code analysis quickly shows whether authorization is properly verified.

The most classic example:
The application uses unverified data in a SQL call that is accessing account information:

String query = "SELECT * FROM accts WHERE account = ?";
PreparedStatement pstmt = connection.prepareStatement(query , ... );
pstmt.setString( 1, request.getParameter("acct"));
ResultSet results = pstmt.executeQuery();

The attacker simply modifies the ‘acct’ parameter in their browser to send whatever 
account number they want. If not verified, the attacker can access any user’s account, instead of 
only the intended customer’s account.

http://example.com/app/accountInfo?acct=notmyacct

Mitigation:

Preventing insecure direct object references requires selecting an approach 
for protecting each user accessible object (e.g., object number, filename):

Use per user or session indirect object references. This prevents attackers from directly 
targeting unauthorized resources. For example, instead of using the resource’s database key, 
a drop down list of six resources authorized for the current user could use the numbers 1 to 6 to 
indicate which value the user selected. The application has to map the peruser indirect reference 
back to the actual database key on the server.

Check access. Each use of a direct object reference from an untrusted source must include an access control 
check to ensure the user is authorized for the requested object.
',1);
INSERT INTO "kb_items" VALUES (10093,'Type checking and length checking','Description:

Type checking, length checking and whitelisting is an essential in defense in depth strategie to make
your application more resiliant against input injection attacks.

Example:
    ```
    SELECT * FROM pages WHERE id=mysql_real_escape_string($_GET[''''id''''])
    ```
    
This PHP example did effectively not mitigate the SQL injection. This was due to the fact
that it only escaped string based SQL injection. 

Now, if this application also had additional checks to validate if the value of 
the $_GET[''''id''''] parameter was indeed as expected an integer and rejected if this condition was false, 
the attack would effectively been mitigated.


Mitigation:

All the user supplied input that works outside of the intended opteration of the application
should be rejected by the application.

Syntax and Semantic Validity
An application should check that data is both syntactically and semantically 
valid (in that order) before using it in any way (including displaying it back to the user). 

Syntax validity, means that the data is in the form that is expected. For example, an application
may allow a user to select a fourdigit “account ID” to perform some kind of operation. 
The application should assume the user is entering a SQL injection payload, and should 
check that the data entered by the user is exactly four digits in length, and consists only of numbers 
(in addition to utilizing proper query parameterization).

Semantic validity, includes only accepting input that is within an acceptable range for the
given application functionality and context. For example, a start date must be before an end
date when choosing date ranges.

',1);
INSERT INTO "kb_items" VALUES (10094,'SMTP IMAP injection','Description:

This threat affects all applications that communicate with mail servers (IMAP/SMTP), generally webmail applications. The aim of this test is to verify the capacity to inject arbitrary IMAP/SMTP commands into the mail servers, due to input data not being properly sanitized.

The IMAP/SMTP Injection technique is more effective if the mail server is not directly accessible from Internet. Where full communication with the backend mail server is possible, it is recommended to conduct direct testing.

An IMAP/SMTP Injection makes it possible to access a mail server which otherwise would not be directly accessible from the Internet. In some cases, these internal systems do not have the same level of infrastructure security and hardening that is applied to the frontend web servers. Therefore, mail server results may be more vulnerable to attacks by end users.

Mitigation:

Limit the available IMAP/SMTP commands to the ones that are really needed. Also make sure you make it not publicly available when there is no need for this.',1);
INSERT INTO "kb_items" VALUES (10095,'Insecure object deserialization','Description:

Serialization is the process of turning some object into a data format that can be restored later. 
People often serialize objects in order to save them to storage, or to send as part of communications.

Deserialization is the reverse of that process, taking data structured from some format, and rebuilding it
into an object. Today, the most popular data format for serializing data is JSON. Before that, it was XML.

However, many programming languages offer a native capability for serializing objects. These native formats
usually offer more features than JSON or XML, including customizability of the serialization process.

Unfortunately, the features of these native deserialization mechanisms can be repurposed for malicious
effect when operating on untrusted data. Attacks against deserializers have been found to allow denialofservice,
access control, and remote code execution (RCE) attacks.


Mitigation:

Verify that serialized objects use integrity checks or are encrypted to prevent hostile object creation or data tampering.

A great reduction of risk is achieved by avoiding native (de)serialization formats. By switching to a 
pure data format like JSON or XML, you lessen the chance of custom deserialization logic being repurposed 
towards malicious ends.

Many applications rely on a datatransfer object pattern that involves creating a separate domain of 
objects for the explicit purpose data transfer. Of course, it''''s still possible that the application 
will make security mistakes after a pure data object is parsed.

If the application knows before deserialization which messages will need to be processed, 
they could sign them as part of the serialization process. The application could then to 
choose not to deserialize any message which didn''''t have an authenticated signature.
',1);
INSERT INTO "kb_items" VALUES (10096,'Functional security constraints','Description:

Functional security constraints help your software developers determine the level of
grants/authorizations the users have over the application. 

Mitigation:

Verify that all user stories and features contain functional security constraints, such as 
"As a user, I should be able to view and edit my profile. I should not be able to view or edit anyone else''''s profile"
',1);
INSERT INTO "kb_items" VALUES (10097,'Attribute based authorization','Description:

Access Control (or Authorization) is the process of granting or denying specific requests from a user, 
program, or process. Access control also involves the act of granting and revoking those privileges.

It should be noted that authorization (verifying access to specific features or resources) is not equivalent
to authentication (verifying identity).  

Mitigation:

Attribute Based Access Control (ABAC) will grant or deny user requests based on arbitrary 
attributes of the user and arbitrary attributes of the object, and environment conditions 
that may be globally recognized and more relevant to the policies at hand. 

Once you have chosen a specific access control design pattern, it is often difficult and time
consuming to reengineer access control in your application with a new pattern. Access Control is
one of the main areas of application security design that must be thoroughly designed up front, 
especially when addressing requirements like multitenancy and horizontal (data dependent) access control. 


Ideally we want to move from here:
```
if (user.hasRole("ADMIN")) || (user.hasRole("MANAGER")) {
   deleteAccount();
}
```

To here:

```
if (user.hasAccess("DELETE_ACCOUNT")) {
   deleteAccount();
}
```

This is becuase the latter is more manageble over time.

For more information please refer to the OWASP top 10 pro active controls.

https://www.owasp.org/index.php/OWASP_Proactive_Controls

OWASP pro active controls chapter C7 "Enforce Access Controls"

',1);
INSERT INTO "kb_items" VALUES (10098,'Key management and key lifecycle by NIST','Description:

This knowledgebase item refers to the NIST standard for key managment and
key lifecycle.

This Recommendation provides cryptographic key management guidance. It consists of
three parts. Part 1 provides general guidance and best practices for the management of
cryptographic keying material. Part 2 provides guidance on policy and security planning
requirements for U.S. government agencies. Finally, Part 3 provides guidance when using
the cryptographic features of current systems. 

Mitigation:

Please refer to the following documentation for more indepth information:

https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.80057pt1r4.pdf
',1);
INSERT INTO "kb_items" VALUES (10099,'Key vault','Description:

Keys should remain in a protected key vault at all times. 
In particular, ensure that there is a gap between the threat vectors 
that have direct access to the data and the threat vectors that have direct access to the keys. 
This implies that keys should not be stored on the application or web server 
(assuming that application attackers are part of the relevant threat model).

A key vault helps secure, store and tightly control access to tokens, passwords, certificates and,
encryption keys for protecting secrets and other sensitive data.  

Imagine the use of a keyvault in the following scenario''''s

* Running a docker container and provisioning it with secrets over CLI
* Checking in API keys in your source repositories
* Encrypting sensitive data at rest

Vault provides encryption as a service with centralized key management to simplify encrypting data 
in transit and at rest across clouds and datacenters.

a Vault can be used to encrypt/decrypt data that is stored elsewhere. The primary use of this is to allow applications to encrypt their data while still storing it in the primary data store.

The benefit of this is that developers do not need to worry about how to properly encrypt data. The responsibility of encryption is on Vault and the security team managing it, and developers just encrypt/decrypt data as needed.

Mitigation:

centrally store, access, and distribute secrets like API keys,
AWS IAM/STS credentials, SQL/NoSQL databases, X.509 certificates, 
SSH credentials, etc by means of a key vault.

When selecting a key vault that is fit for your needs make sure it has Cryptographic Compliance
towards the FIPS standards.


',1);
INSERT INTO "kb_items" VALUES (10100,'Secrets shared with the client','Description:

symmetric keys, passwords, or API secrets that are shared with the client should
not be used for functions that are classified critical.

Whenever a client is sucessfully targeted by a malicious attacker the integrety
of these keys is no longer guaranteed. 

Mitigation:

Verify that symmetric keys, passwords, or API secrets generated
by or shared with clients are used only in protecting low risk secrets, 
such as encrypting local storage, or temporary ephemeral uses such as parameter obfuscation.
Sharing secrets with clients is cleartext equivalent and architecturally should be treated as such.
',1);
INSERT INTO "kb_items" VALUES (10101,'Data protection levels','Description:

The CIA triad of confidentiality, integrity, and availability is at the heart of information security.

Confidentiality
In information security, confidentiality "is the property, that information
is not made available or disclosed to unauthorized individuals, entities, or processes." 
While similar to "privacy," the two words aren''''t interchangeable. Rather, confidentiality 
is a component of privacy that implements to protect our data from unauthorized viewers.
Examples of confidentiality of electronic data being compromised include laptop theft, 
password theft, or sensitive emails being sent to the incorrect individuals.

Integrity
In information security, data integrity means maintaining and assuring the accuracy
and completeness of data over its entire lifecycle. This means that data cannot
be modified in an unauthorized or undetected manner. This is not the same thing as
referential integrity in databases, although it can be viewed as a special case of
consistency as understood in the classic ACID model of transaction processing.
Information security systems typically provide message integrity along side to confidentiality.

Availability
For any information system to serve its purpose, the information must be available when it is needed.
This means the computing systems used to store and process the information, 
the security controls used to protect it, and the communication channels used to
access it must be functioning correctly. High availability systems aim to remain available
at all times, preventing service disruptions due to power outages, hardware failures, 
and system upgrades. Ensuring availability also involves preventing denialofservice attacks, 
such as a flood of incoming messages to the target system, essentially forcing it to shut down.


Mitigation:

Based on CIA determine a protection level and define countermessures that belong to that specific 
protection level such as but not limited to.

 encryption requirements
 integrity requirements 
 retention
 privacy 

and other confidentiality requirements, and that these are applied in the architecture.
',1);
INSERT INTO "kb_items" VALUES (10102,'Referrer policy header','Description:
Requests made from a document, and for navigations away from that document
are associated with a Referer header. While the header can be suppressed for
links with the noreferrer link type, authors might wish to control the Referer
header more directly for a number of reasons,

 Privacy
A social networking site has a profile page for each of its users, 
and users add hyperlinks from their profile page to their favorite bands. 
The social networking site might not wish to leak the user’s profile URL 
to the band web sites when other users follow those hyperlinks 
(because the profile URLs might reveal the identity of the owner of the profile).

Some social networking sites, however, might wish to inform the band web sites that
the links originated from the social networking site but not reveal which specific
user’s profile contained the links.

 Security
A web application uses HTTPS and a URLbased session identifier. The web application might
wish to link to HTTPS resources on other web sites without leaking the user’s session 
identifier in the URL.

Alternatively, a web application may use URLs which themselves grant some capability. 
Controlling the referrer can help prevent these capability URLs from leaking via 
referrer headers.

Note that there are other ways for capability URLs to leak, and controlling 
the referrer is not enough to control all those potential leaks.

 Trackback
A blog hosted over HTTPS might wish to link to a blog hosted over HTTP and 
receive trackback links.

Mitigation:

For more information about the policy and how it should be implemented please
visit the following link,

https://www.w3.org/TR/referrerpolicy/referrerpolicies
',1);
INSERT INTO "kb_items" VALUES (10103,'Insecure application defaults','Description:

When default sample applications, default users, etc
are not removed from your production environment you
are increasing an attackers potentiall attack surface significantly.

Mitigation:

Verify that all unneeded features, documentation, samples, 
configurations are removed, such as sample applications, 
platform documentation, and default or example users.
',1);
INSERT INTO "kb_items" VALUES (10104,'GraphQL security','Description:

GraphQL is an opensource data query and manipulation language for APIs, 
and a runtime for fulfilling queries with existing data. GraphQL was 
developed internally by Facebook in 2012 before being publicly released i
n 2015. On 7 November 2018, the GraphQL project was moved from Facebook 
to the newlyestablished GraphQL foundation, hosted by the nonprofit Linux Foundation.

Mitigation:

Verify that GraphQL or other data layer authorization logic is be 
implemented at the business logic layer instead of the GraphQL layer.
',1);
INSERT INTO "kb_items" VALUES (10105,'JSON validation schema','Description:

JSON Schema is a vocabulary that allows you to annotate and validate JSON documents.

When adding schema''''s to your or JSON files you have better control over what
type of userinput can be supplied in your application. 
This dramatically decreases an attacker’s vector when implemented the right way. 
Nonetheless, you should always apply your own input validation and rejection
as an extra layer of defense. This approach is also desirable since you also 
want to do countering and logging on the user’s requests and input.

Mitigation:

Verify that JSON schema validation takes place to ensure a properly formed
JSON request, followed by validation of each input field before any 
processing of that data takes place.
',1);
INSERT INTO "kb_items" VALUES (10106,'Serve files whitelist.','Description:

Configiring the web server to only serve files with an expected
file extension helps prevent information leakage whenever developers
forget to remove backup files or zipped versions of the web application
from the webserver.


Mitigation:

Verify that the web tier is configured to serve only files with specific
file extensions to prevent unintentional information and source
code leakage. For example, backup files (e.g. .bak), temporary working
files (e.g. .swp), compressed files (.zip, .tar.gz, etc) and other extensions
commonly used by editors should be blocked unless required.
',1);
INSERT INTO "kb_items" VALUES (10107,'User supplied scriptable or expression template language content','Description:

usersupplied scriptable or expression template language content, such as Markdown, 
CSS or XSL stylesheets, BBCode, or similar are designed to give users the option
to add a lot of rich styling to the application. However whenever these templates 
do not filter for harmfull attacks, these templates can be used to leverage
XSS attacks.


Mitigation:

Verify that the application sanitizes, disables, or sandboxes 
usersupplied scriptable or expression template language content, such as Markdown, 
CSS or XSL stylesheets, BBCode, or similar.

How this is most effectively done depends on the framework and library you
are choosing to incorperate. It is advised to investigate how to put up constraints
for translating these template syntaxes to HTML tags and what their security
implications are. 
',1);
INSERT INTO "kb_items" VALUES (10108,'Replay attacks','Description:
A replay attack (also known as playback attack) is a form of attack in which
a valid data transmission is maliciously or fraudulently repeated or delayed. 
This is carried out either by the originator or by an adversary who intercepts the data and retransmits it.
This is one of the lower tier versions of a "Maninthemiddle attack".

Mitigation:
Replay attacks can be prevented by tagging each encrypted component with a session ID and a component number.
Using this combination of solutions does not use anything that is interdependent on one another. 
Because there is no interdependency there are fewer vulnerabilities. This works because a unique, 
random session id is created for each run of the program thus a previous run becomes more difficult to replicate. 
In this case an attacker would be unable to perform the replay because on a new run the session ID would have changed
',1);
INSERT INTO "kb_items" VALUES (10109,'Race conditions','Description:
A race condition is a flaw that produces an unexpected result when the timing of actions impact other actions. 
An example may be seen on a multithreaded application where actions are being performed on the same data. 
Race conditions, by their very nature, are difficult to test for.

Race conditions may occur when a process is critically or unexpectedly dependent on the sequence or timings of 
other events. In a web application environment, where multiple requests can be processed at a given time, 
developers may leave concurrency to be handled by the framework, server, or programming language.

Mitigation:

One common solution to prevent race conditions is known as locking. This ensures that at any given time, 
at most one thread can modify the database. Many databases provide functionality to lock a given row when a 
thread is accessing it.

',1);
INSERT INTO "kb_items" VALUES (10110,'Stateless session tokens','Description:

JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and selfcontained way 
for securely transmitting information between parties as a JSON object. This information can be verified and 
trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA.

JSON Web Token is used to carry information related to the identity and characteristics (claims) of a client. This "container" is signed by the server in order to avoid that a client tamper it in order to change, for example, the identity or any characteristics (example: change the role from simple user to admin or change the client login).

This token is created during authentication (is provided in case of successful authentication) and is verified by the server before any processing. It is used by an application to allow a client to present a token representing his "identity card" (container with all information about him) to server and allow the server to verify the validity and integrity of the token in a secure way, all of this in a stateless and portable approach (portable in the way that client and server technologies can be different including also the transport channel even if HTTP is the most often used).

Mitigation:

For more information about all the different implementation flaws for JWT please refer to:

https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/JSON_Web_Token_Cheat_Sheet_for_Java.md
',1);
INSERT INTO "kb_items" VALUES (10111,'Exception handling','Description:
Exception handling is the process of responding to the occurrence, during computation, 
of exceptions – anomalous or exceptional conditions requiring special processing 
often disrupting the normal flow of program execution. It is provided by specialized 
programming language constructs, computer hardware mechanisms like interrupts or operating 
system IPC facilities like signals.

In general, an exception breaks the normal flow of execution and executes a preregistered 
exception handler. The details of how this is done depends on whether it is a hardware or 
software exception and how the software exception is implemented. Some exceptions, 
especially hardware ones, may be handled so gracefully that execution can resume where it was interrupted.

Alternative approaches to exception handling in software are error checking, 
which maintains normal program flow with later explicit checks for contingencies 
reported using special return values or some auxiliary global variable 
such as C''''s errno or floating point status flags; or input validation to preemptively 
filter exceptional cases.

Mitigation:

By catching all different errors and exceptions your program will never be redirected in a 
excecution flow that causes unexpected behaviour. This behaviour could include bypassing authorization 
logic or other sanity checks that could be used to attack the target system.

',1);
INSERT INTO "kb_items" VALUES (10112,'Back up data','Description:
In information technology, a backup, or data backup, or the process of backing up, 
refers to the copying into an archive file of computer data that is already in 
secondary storage so that it may be used to restore the original after a data loss event. 

Mitigation:
Backups have two distinct purposes. The primary purpose is to recover data after its loss, 
be it by data deletion or corruption. Data loss can be a common experience of computer users. 

The secondary purpose of backups is to recover data from an earlier time, according to a 
userdefined data retention policy, typically configured within a backup application for how 
long copies of data are required. 

Though backups represent a simple form of disaster recovery 
and should be part of any disaster recovery plan, backups by themselves should not be considered
a complete disaster recovery plan. One reason for this is that not all backup systems are able to
reconstitute a computer system or other complex configuration such as a computer cluster, 
active directory server, or database server by simply restoring data from a backup.

In order to always poses over the latest state of your data it is recommended to do active syncing
between the application server and the backup service. Also, try to not only write recovery policies 
but also put them to the test regularly to verify the plans effective coverage in case if an incident.
',1);
INSERT INTO "kb_items" VALUES (10113,'Code signing','Description:
Code signing is the process of digitally signing executables and scripts to confirm the software 
author and guarantee that the code has not been altered or corrupted since it was signed. 
The process employs the use of a cryptographic hash to validate authenticity and integrity.

Code signing can provide several valuable features. The most common use of code signing is to 
provide security when deploying; in some programming languages, it can also be used to help prevent 
namespace conflicts. Almost every code signing implementation will provide some sort of digital 
signature mechanism to verify the identity of the author or build system, and a checksum to verify 
that the object has not been modified. It can also be used to provide versioning information about an object or to store other meta data about an objec

Mitigation:
Sign your code and validate the signatures(checksums) of your code and third party
components to confirm the integrity of the deployed components.
',1);
INSERT INTO "kb_items" VALUES (10114,'Secure random generators','Description:
A cryptographically secure pseudorandom number generator (CSPRNG) or cryptographic pseudorandom
number generator (CPRNG) is a pseudorandom number generator (PRNG) with properties that make it 
suitable for use in cryptography.

Most  applications require random numbers, for example:

 key generation
 nonces
 salts 

Mitigation:
Ideally, the generation of random numbers in CSPRNGs uses entropy obtained from a highquality source. Most of the development frameworks have excellent functions for generating true secure random values.

To test the effective entropy of the generated token we can utilize the extensive analysis tool
of "Burpsuite community version". more information in how to test your tokens effective entropy is found here:

https://portswigger.net/burp/documentation/desktop/tools/sequencer
',1);
INSERT INTO "kb_items" VALUES (10115,'XSLT injections','Description:

A vulnerability occurs when an XSL file is loaded from a source controlled by an attacker.
When the attacker is given the opportunity to specify the source of the included XSL file
he could include a file which contains malicious code to be parsed on the target application.
This could lead to, code execution, reading arbitrary files and many more
vulnerabilities such as XSS.

Mitigation:

To protect against such vulnerability one needs to make sure that he does not use
usersupplied input in the XSL filename.
The best solution would be to define a list of permitted filenames and
only accept XSL filenames from that list.
',1);
INSERT INTO "kb_items" VALUES (10116,'Server side template injection','Description:

Whenever user supplied input is embeded directly into a template when the application
makes use of a templeating engine (jinja2, twig, Freemarker), a malicious attacker can inject 
and execute template expressions. More often the injection of template expressions will ultimately 
lead to RCE vulnerabilities.

This type of vulnerability is also seen a lot through applications that let the user intentionally
modify the template to provide users a more flexible way to style the applications pages like
a wiki page or CMS system.

Mitigation:

User supplied input should never be used directly into a template that uses a templating engine.
The following example is a small python flask function that renders user supplied input 
as part of the template. This allows a malicious attacker to even execute arbitrary commands when.

```
  @app.errorhandler(404)
  def page_not_found(e):
      template = """
  <html>
  <p>{0}</p>
  </html>

  """.format(request.url)
      return render_template_string(template), 404
```

The prefered way to add the user supplied input to this template would be:
```
  @app.errorhandler(404)
  def page_not_found(e):
    input = request.url
    return render_template("errorpage.html", input = input), 404
```    

Wheras the content of the errorpage.html would look like

```
  <html>
      <p>{{input}}</p>
  </html>
```
',1);
INSERT INTO "code_items" VALUES (1,'X XSS Protection Header','XXSSProtection header


 Example:


    /*
    In order to set the XXSSProtection header, you''''ll have to add the following 
    code to the head of your application, the following code could be used in your controller:
    */
    
    Response.AppendHeader("XXSSProtection:1", "mode=block"); 

	/*
	In your classes you can use the following code:
	*/
	
	HttpContext.Current.Response.AppendHeader("XXSSProtection:1", "mode=block");
	

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (2,'Session Cookies (Domain)','Session cookies (domain)


 Example:


	/*
	Setting the "Domain" attribute to a too permissive value, such as "example.com" 
	allows an attacker to launch attacks on the session IDs between different hosts and 
	web applications belonging to the same domain, known as crosssubdomain cookies.
	For example, vulnerabilities in www.example.com might allow an attacker to get access 
	to the session IDs from secure.example.com.
	*/
	
	<system.web>
		<httpCookies domain="demo.mySite.com" />
	</system.web>
	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (3,'X content type pptions header','XContentTypeOptions header


 Example:


    /*
    In order to set the "XContentTypeOptions" header you''''ll have to add the 
    following code to the head of your application, the following code could be used in your controller:
    */
    
    Response.AppendHeader("XContentTypeOptions", "nosniff"); 
    
	/*
	In your classes you can use the following code:
	*/
	
	HttpContext.Current.Response.AppendHeader("XContentTypeOptions", "nosniff"); 
	

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (4,'Enforce secure password','Enforce secure password


 Example:

	
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Text.RegularExpressions;
	using System.IO;


	namespace MvcApplication1.Controllers
	{
		public class passwordcheck
		{
			public bool checkPassword(string password)
			{
				string error = "";
				bool complete = true;

				/*
				Here we define the minimal expected value''''s for your password.
				The password must at least contain a Capital letter, a normal letter, a special character
				a number and must be at least 8 characters long
				*/
				string[] pattern = new string[3] { "[09]", "[AZ]", "[az]" };

				foreach (string validation in pattern)
				{
					//Now if the regex detects any missing character than we will set complete to false
					Regex regex = new Regex(validation);
					Match match = regex.Match(password);

					if (!match.Success)
					{
						error = "You did not enter a valid password";
						complete = false;
					}
				}

				try
				{
					/*
					Also very important is the fact that you have to take into consideration that
					Password1! is a valid password according to password standards. This however is not the case since
					this password is included in almost every dictionary attack system. So we have to prevent 
					the user from using these weak passwords, this we do by defining these bad passwords in a text 
					file and compare the user''''s password with the bad passwords defined in the text file.
					*/

					StreamReader sr = new StreamReader(@"C:\Users\Public\xml\test.txt", true);
					String FileText = sr.ReadToEnd().ToString();

					string[] strTemp = FileText.Split('''','''');

					foreach (string value in strTemp)
					{
						if (value == password)
						{
							error = "Your password was a bad password!";
							complete = false;
						}
					}

					sr.Close();
				}
				catch{
					HttpContext.Current.Response.Write("catching file failed");
					throw;
				}

				//The last step is checking the password length to see if it is 8 characters or bigger
				if (password.Length < 8)
				{
					error = "The password was to short";
					complete = false;
				}

				if (complete == true)
				{
					//Do further operation
					HttpContext.Current.Response.Write("Good job password was ok!");
					return true;
				}else{
					HttpContext.Current.Response.Write(error);
					return false;
				}
			}
		}
	}

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (5,'RFD File Download Injection Prevention','RFD and file download injections


 Example:
	

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Net;
	using System.Data.SqlClient;

	namespace MvcApplication1.Controllers
	{
		public class downloadFiles
		{
			//Here we connect to the database by means of a connection string as configured in the web.config
			SqlConnection conn = new
			SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["download"].ConnectionString);

			private string fileName;
			private bool proceed = true;
			private string mimeType;

			validation validate = new validation();
			whitelist whitelist = new whitelist();

			public void downloadUserFiles(int fileID)
			{
				/*
				For the sake of example we only allow the users to download their own files
				by identifier based sql query''''s. As you can see we select the filename
				by its id. in this case we prevent direct userinput into the disposition header.
				*/

				//Since we only expect an integer back from the user we validate the userinput for integers
				if (validate.validateInput(Convert.ToString(fileID), "numeric", "invalid input", "HIGH") == false) { proceed = false; }

				if (proceed == true)
				{
					conn.Open();
					string query = string.Format("SELECT * FROM downloads WHERE userID=@userID and fileID=@fileID");
					SqlCommand cmd = new SqlCommand(query, conn);

					//We bind the parameter in order to prevent sql injections
					cmd.Parameters.AddWithValue("@userID", Session["userID"]);
					cmd.Parameters.AddWithValue("@fileID", fileID);

					//Next we read the value from the database and put it into a variable
					using (SqlDataReader oReader = cmd.ExecuteReader())
					{
						while (oReader.Read())
						{
							fileName = Convert.ToString(oReader["fileName"]);
							mimeType = Convert.ToString(oReader["mimeType"]);
						}
					}
					if (fileName != null)
					{
						try
						{
							/*
							We also define the mimetype per download file.
							This is because whenever a user can only download images it is not necessary to set
							an uncommon contenttype header for it.
							NOTE: These mimetypes should not be stored based upon the mimetype which was send 
							the response header when the user uploaded the file. This value can be easily 
							manipulated with an intercepting proxy. You should get the mimetype from the file
							itself after it was stored on the server.
							*/
							System.Web.HttpResponse response = System.Web.HttpContext.Current.Response;
							response.ClearContent();
							response.Clear();
							response.ContentType = mimeType;
							response.AppendHeader("CacheControl", "nocache");
							response.AddHeader("ContentDisposition", "attachment; filename=" + fileName + ";");
							response.WriteFile(@"\\servername\folder1\folder2\folder3\" + fileName + "");
							response.Flush();
							response.End();
						}
						catch (NullReferenceException e){
							if (e.Source != null)
							{
								HttpContext.Current.Response.Write("error!");
							}
						}
					}
				}
			}

			public void fixedDownloads(string download)
			{
				/*
				The second example is for whenever you are providing users with fixed downloads
				such as manuals etc. We do not only check if the file just exists, because that would
				allow an attacker to also download important other files from your server, so instead
				we whitelist them.
				*/
				if (whitelist.whitelisting("file1.txt,file2.txt", download) != false)
				{
					System.Web.HttpResponse response = System.Web.HttpContext.Current.Response;
					response.ClearContent();
					response.Clear();
					response.ContentType = "text/plain";
					response.AppendHeader("CacheControl", "nocache");
					response.AddHeader("ContentDisposition", "attachment; filename=" + download + ";");
					response.WriteFile(@"\\servername\folder1\folder2\folder3\" + download + "");
					response.Flush();
					response.End();
				}
			}
		}
	}
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (6,'Audit Logs','Audit logs


 Example:


   	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.IO;
	using System.Data.SqlClient;
	using System.ComponentModel.DataAnnotations.Schema;
	using System.ComponentModel.DataAnnotations;

	namespace MvcApplication1.Controllers
	{
		[Table("counter")]
		public class auditLogs
		{

			//Getters and setters for our user method
			[Key]
			public int countID { get; set; }
			public int userID  { get; set; }
			public int count   { get; set; }
			public int blocker { get; set; }

			//Here we connect to the database by means of a connection string as configured in the web.config
			SqlConnection conn = new 
			SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

			public void SetLog(string session, string message, string state, string threat)
			{
				using (StreamWriter writer = new StreamWriter(@"C:\Users\Public\xml\logs.txt", true))
				{
                    writer.WriteLine(session + "  " + message + "  " + HttpContext.Current.Request.ServerVariables["REMOTE_ADDR"] +
                    "  " + state + "  " + DateTime.Now + "  " + threat);
				}
			}

			public void counter(int counting)
			{
				/*
				First we select the counts from the count table in order to verify if the user session should be terminated
				or that the user should be locked out.
				*/
				conn.Open();

				string query = string.Format("SELECT * from counter WHERE userID = @userID ");
				SqlCommand cmd = new SqlCommand(query, conn);

				//We bind the parameter in order to prevent sql injections
				cmd.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

				//Next we read the value from the database and put it into a variable
				using (SqlDataReader oReader = cmd.ExecuteReader())
				{
					while (oReader.Read())
					{
						count   = Convert.ToInt32(oReader["count"]);
						blocker = Convert.ToInt32(oReader["blocker"]);
					}
				}

				//We add the counting to the database results for the final value
				int finalCount = counting += count;
				int finalBlock = counting += blocker;

				/*
				then we update the count table in order to keep track of the number of counts
				*/
				try
				{
					using (SqlCommand command = conn.CreateCommand())
					{
						command.CommandText = "UPDATE counter set count = @count, blocker = @blocker WHERE userID = @userID";

						//Again we bind the parameters in order to prevent SQL injections
						command.Parameters.AddWithValue("@count", finalCount);
						command.Parameters.AddWithValue("@blocker", finalCount);
						command.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

						command.ExecuteNonQuery();
					}
				}
				catch (SqlException e){
					if (e.Source != null)
					{
						System.Web.HttpContext.Current.Response.Write("SQL insert query error in update counter");
						throw;
					}
				}
				conn.Close();


				/*
				After these steps we check whether the user should be blocked, whenever the count is equal to 12 we take
				further actions by means of blocking the users account and terminating his session
				*/

				if (finalBlock >= 12)
				{
					try
					{
						using (SqlCommand command = conn.CreateCommand())
						{
							conn.Open();
							string access = "FALSE";
							command.CommandText = "UPDATE users set access = @access WHERE userID = @userID";

							//Again we bind the parameters in order to prevent SQL injections
							command.Parameters.AddWithValue("@access", access);
							command.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

							command.ExecuteNonQuery();

							HttpContext.Current.Session["authenticateUser"] = "";
							HttpContext.Current.Session.Abandon();
							HttpContext.Current.Response.Redirect("/login", true);
						}
					}
					catch (SqlException e){
						if (e.Source != null)
						{
							System.Web.HttpContext.Current.Response.Write("SQL insert query error");
							System.Web.HttpContext.Current.Response.Write(e);
						}
					}
				}
				
				/*
				If the count hit three, the user gets a warning by means of a session termination.
				Whenever this termination occurs three times he will lock out his account.
				*/
				if (finalCount >= 3)
				{
					HttpContext.Current.Session["authenticateUser"] = "";
					HttpContext.Current.Session.Abandon();
					HttpContext.Current.Response.Redirect("/login", true);
				}
			}
		}
	}
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (7,'CSRF Tokens','CSRF tokens


 Example:
    
	
    /*
    For CSRF tokens we used a separate class outside of the normal controller, since
    it must be reused on several locations throughout the application
    
	First after a successful validation of a user login, the application must also start a session
	which contains the "cross site request forgery" token.
    */
    
	/*
	For generating the token we want to use a secure cryptographic function
	in order to use RNGCryptoServiceProvider we must first add :
	using System.Security.Cryptography;
	*/
	RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();

	//Then we generate a long value token containing a high entropy
	byte[] buffer = new byte[128];

	rng.GetBytes(buffer);

	//Then we base64 encode the string
	string csrftoken = System.Convert.ToBase64String(buffer);

	System.Web.HttpContext.Current.Session["CSRF"] = csrftoken; 

	/*
	The next step is implementing this random token in each form field as a hidden input parameter
	and send it to a function which checks if the submitted token is equal to the one set after successful validation.
	*/

	<form method="post" action="/Home/csrf">
    <input type="text" name="testValue" />
    <input type="hidden" name="csrftoken" value="@Session["CSRF"];" />
    <input type="submit" value="submit the form" />
    </form>
	
	//here we are sending the token towards the function which does the token validation    
	public void checkCSRF(string token)
	{
		string Sessiontoken = Convert.ToString(System.Web.HttpContext.Current.Session["CSRF"]);
	
		//We compare the incoming token with the current session Token which was assigned on login
		if(Sessiontoken != token)
		{	
			/*
			If there was no match the authentication session will be emptied and sessions
			Will be abandoned, we redirect the user towards the login page.
			*/
		
			HttpContext.Current.Session["authenticateUser"] = "";
			HttpContext.Current.Session.Abandon();
			HttpContext.Current.Response.Redirect("/login", true);            
		}           
	
	}     
	


	','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (8,'Logout','Logout functionality


 Example:
	

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;

	namespace MvcApplication1.Controllers
	{
		public class logout
		{
			public void logOut()
			{   
				//We clear abandon and remove all sessions before we start
				HttpContext.Current.Session.Clear();
				HttpContext.Current.Session.Abandon();
				HttpContext.Current.Session.RemoveAll();
		   
				//Double check this and empty your session manually
				HttpContext.Current.Session["Authenticated"] = "";

				//Clear the aspsessionID
				if (HttpContext.Current.Request.Cookies["ASP.NET_SessionId"] != null)
				{
					HttpContext.Current.Response.Cookies["ASP.NET_SessionId"].Value = string.Empty;
					HttpContext.Current.Response.Cookies["ASP.NET_SessionId"].Expires = DateTime.Now.AddMonths(20);
				}

				//Clear our custom set cookie.
				if (HttpContext.Current.Request.Cookies["AuthToken"] != null)
				{
					HttpContext.Current.Response.Cookies["AuthToken"].Value = string.Empty;
					HttpContext.Current.Response.Cookies["AuthToken"].Expires = DateTime.Now.AddMonths(20);
				}
				HttpContext.Current.Response.Redirect("/login", true);
			}
		}
	}','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (9,'Timeout a Session','Timeout a session


 Example:


	/*
	Within your web.config you can configure your session idle timeout.
	The default time is set to 20 minutes.
	*/
		
	<configuration>
	   <system.web>
		  <sessionState mode="InProc"
				cookieless="true"
				timeout="20"/> < Here is where we set the timeout by minutes
		  </sessionState>
	   </system.web>
	</configuration>','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (10,'White listing',' Whitelisting


 Example:
	

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;

	namespace MvcApplication1.Controllers
	{
		public class whitelist
		{
			//Include auditlog class
			auditLogs Log = new auditLogs();

			public bool whitelisting(string allowed, string input)
			{
				/*
				Here we define a whitelist of pages we want the user allow to be redirected to, all 
				patterns are terminated whenever they not comply with the predefined withelist
				*/

				string[] pattern = allowed.Split('''','''');

				//For validation if the file returned true
				bool validated = false;

				//To catch the user submitting evil requests we count the number of times the foreach hits false
				int count = 0;
				int countArray = 0;

				int counter = allowed.Length;

				foreach (string item in pattern)
				{
					//If filename is equal to the predefined items
					if (input == item)
					{
						validated = true;
						count = 1;
					}

					//Here we add up the counts, if they are equal we know the function did not hit a valid filename
					count++;
					countArray++;
				}
			
				if (countArray == count)
				{
					//this breach has to be reported into the log files
					Log.setLog(HttpContext.Current.Session["userID"], "Audit log message!", "FAIL", "HIGH");
					Log.setCounter.count(3);
				}
				return validated;
			}
		}
	}','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (11,'Random Password Token Generation','Random password/token generation


 Example:


	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Security.Cryptography;

	namespace MvcApplication1.Controllers
	{
		public class randomizer
		{
			public string generate(int numberOfBytes)
			{
				/*
				For generating the password we want to use a secure cryptographic function
				*/
				RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();

				//Then set the size of the password
				byte[] buffer = new byte[numberOfBytes];
				rng.GetBytes(buffer);

				//Then we base64 encode the string in order to prevent null bytes
				string randomString = System.Convert.ToBase64String(buffer);

				return randomString;
			}
		}
	}

	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (12,'Directory Path Traversal','Path traversal


 Example:

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Text.RegularExpressions;
	using System.IO;

	namespace MvcApplication1.Controllers
	{
		public class rewrite
		{
			auditLogs Log = new auditLogs();
			inputvalidation validate = new inputvalidation();
			whitelist listme = new whitelist();

			public void getFiles(string getFile)
			{
				/*
				First, we want to filter the filenames for expected values. For this example we use only use 09
				Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.           
				*/
				bool validated = true;

				//see the "input validation" code example for more detailed information about this function
				if (validate.validateInput(getFile, "numeric", "Failed to get file", "HIGH") == false) { validated = false;}

				/*
				see the "whitelisting" code example for more detailed information about this function
				Let''''s assume there are three files named 1,2,3
				*/
				
				if (listme.whitelisting("1,2,3", getFile) == false) { validated = false; }

				//Only if the pattern was true we allow the variable into the streamreader function
				if (validated == true)
				{
					try
					{
						StreamReader sr = new StreamReader(@"C:\Users\Public\xml\" + getFile + ".txt", true);
						String FileText = sr.ReadToEnd().ToString();

						sr.Close();
					}
					catch(DirectoryNotFoundException e){
						if (e.Source != null)
						{
							HttpContext.Current.Response.Write("catching file failed");
						}
					}
				}else{
					HttpContext.Current.Response.Write("invalid userinput was detected!");
				}
			}
		}
	}
	

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (13,'Session Cookies HttpOnly','Session cookies HttpOnly


 Example:

	/*
	Whenever a session is started, the "httpOnly" option should always be set
	in order to prevent session data to be stolen by attackers.
	
    By default, .NET 2.0 sets the HttpOnly attribute for:
    Session ID,
    Forms Authentication cookie

    In .NET 2.0, HttpOnly can also be set via the HttpCookie object for all custom application 
    cookies via web.config in the system.web/httpCookies element
	*/
	
	<httpCookies httpOnlyCookies="true"> 

    //Or programmatically
	//C Code:

	HttpCookie myCookie = new HttpCookie("AuthToken", guid);
	HttpContext.Current.Response.Cookies.Add(myCookie);
	myCookie.HttpOnly = true;

	

	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (14,'SQL Query','SQL query


 Example:


	/*
	In c MVC there are a lot of different methods in order to process your SQL query''''s to 
	the database. Most of them are already secure by design and leave little to no room for
	error such as SQL to LinQ or doing your database handling by the entity framework.

	However if you want to use the sql command method you must use this functionality by
	means of prepared statements in order to prevent sql injections.
	*/


	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.ComponentModel.DataAnnotations.Schema;
	using System.ComponentModel.DataAnnotations;
	using System.Data.SqlClient;
	using System.Web.SessionState;


	namespace MvcApplication1.Models
	{
		[Table("users")]
		public class users
		{
			//Getters and setters for our user method
			[Key]
		
			public int userID      { get; set; }
			public string username { get; set; }
			public string email    { get; set; }

			//First we include the audit log class.
			//AuditLog Log = new AuditLog();

			//Here we connect to the database by means of a connection string as configured in the web.config
			SqlConnection conn = new 
			SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

			public void selectStatement()
			{   
				//Open the database connection
				conn.Open();

				try
				{   
					string query = string.Format("SELECT * from users WHERE userId = @userID ");
					SqlCommand cmd = new SqlCommand(query, conn);

					//We bind the parameter in order to prevent sql injections
					cmd.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

					//Next we read the value from the database and put it into a variable
					using (SqlDataReader oReader = cmd.ExecuteReader())
					{
						while (oReader.Read())
						{
							username = oReader["username"].ToString();
							email    = oReader["email"].ToString();

						}
					}
					//close the connection again
					conn.Close();
				}
				catch(SqlException e){
					if (e.Source != null)
					{
						System.Web.HttpContext.Current.Response.Write("Invalid select query");
						throw;
					}
				}
			}

			public void insertStatement()
			{   
				//We open the connection towards the database
				conn.Open();

				try
				{
					using (SqlCommand command = conn.CreateCommand())
					{ 
					
						command.CommandText = "INSERT INTO users(username,email) VALUES(@param1,@param2)";  
					
						//Again we bind the parameters in order to prevent SQL injections
						command.Parameters.AddWithValue("@param1", username);  
						command.Parameters.AddWithValue("@param2", email);   

						command.ExecuteNonQuery(); 
					}
				}
				catch(SqlException e){
					if(e.Source != null)
					{
						System.Web.HttpContext.Current.Response.Write("SQL insert query error");
						throw;
					}
				}

				//we close the connection again
				conn.Close();
			}
		}
	}
	
	



	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (15,'Re Authentication','Reauthentication


 Example:
	

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Data.SqlClient;
	using System.ComponentModel.DataAnnotations;
	using System.Web.SessionState;

	namespace MvcApplication1.Controllers
	{
		public class reauth
		{
			//Getters and setters for our user method
			[Key]
			public int userID { get; set; }
			public string username { get; set; }
			public string password { get; set; }
			public string access { get; set; }
			public string salt { get; set; }
			public int privilege { get; set; }

			//First we include the audit log class.
			auditLogs Log = new auditLogs();

			//Second we include the password hash.
			hashing hash = new hashing();

			//Third we include the random password/token class.
			randomizer CSRF = new randomizer();

			//Add the logout class
			logout logoff = new logout();

			public bool reAuthentication()
			{
				//Here we connect to the database by means of a connection string as configured in the web.config
				SqlConnection conn = new SqlConnection
				(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

				bool loggedin = false;
				string passwordHash = "";
				conn.Open();

				//Here we select the user from the users table by the sessionID
				string query = string.Format("SELECT * from users WHERE userID = @userID ");
				SqlCommand cmd = new SqlCommand(query, conn);

				//We bind the parameter in order to prevent sql injections
				cmd.Parameters.AddWithValue("@userID", 1);

				//Next we read the value from the database and put it into a variable
				using (SqlDataReader oReader = cmd.ExecuteReader())
				{
					while (oReader.Read())
					{
						passwordHash = Convert.ToString(oReader["password"]);
						salt = Convert.ToString(oReader["salt"]);
					}
				}

				/*
				We validate the password see "Password storage(salting stretching hashing)" in the code examples
				for more detailed information:
				*/
				if (hash.Validate(passwordHash, salt, password) == true)
				{
					//the connection has to be reported into the log files
					Log.SetLog("Null", "login was OK!", "SUCCESS", "NULL");

					/*
					This is is to prevent session fixation, after login we create a new cookie which
					we than use to authenticate. This value can not be fixated since it is set after 
					login.
				 
					create a new GUID and save into the session:
					*/

					//Al the random tokens will now be changed
					string guid = Guid.NewGuid().ToString();
					HttpContext.Current.Session["AuthToken"] = guid;

					// now create a new cookie with this guid value
					HttpContext.Current.Response.Cookies.Add(new HttpCookie("AuthToken", guid));

					/*
					Now we create a random value for our CSRF tokens. See "Random password/token generation" in
					the code examples for more detailed information:
					*/
					string CSRftoken = CSRF.generate(25);
					System.Web.HttpContext.Current.Session["CSRF"] = CSRftoken;

					HttpContext.Current.Session["Authenticated"] = "access";
					loggedin = true;
				}else{
					//If things went wrong we destroy the entire session. see "logout" code example for more info:
					logoff.logOut();
				}
				return loggedin;
			}
		}
	}

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (16,'Open Forwards & Redirects','Open forwards & redirects


 Example:

	
	/*
	When using forwards & redirects you should make sure the URL is being explicitly 
	declared in the code and cannot be manipulated by an attacker like:
	*/
	
	HttpContext.Current.Response.Redirect("/login", true);
	
	/*
	Generally you should avoid getting input into the redirect which could contain
	userinput by any means. if for any reason this may not be feasible than you 
	should make a whitelist input validation for the redirect like so:
	*/
	
	     
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;


	namespace MvcApplication1.Controllers
	{

		public class OpenForwards
		{
			public void openForwards(string redirect)
			{
				whitelist listMe = new whitelist();

				bool validated = true;
			
				//For more information about whitelisting see the "Whitelisting" code example:
				if (listMe.whitelisting("page1,page2,page3", redirect) == false) { validated = false; }
			
				//Only if the pattern was true we allow the variable into the streamreader function
				if (validated == true)
				{
					try
					{
						HttpContext.Current.Response.Redirect(redirect, true);
					}
					catch
					{
						HttpContext.Current.Response.Write("redirect failed");
					}
				}
			}
		}
	}
	

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (17,'Anti clickjacking header','Anti clickjacking headers


 Example:

	/*
    One way to defend against clickjacking is to include a "framebreaker" script in each 
	page that should not be framed. The following methodology will prevent a webpage from 
	being framed even in legacy browsers, that do not support the XFrameOptionsHeader.

	In the document HEAD element, add the following:
	
	First apply an ID to the style element itself:
	*/
	
	<style id="antiClickjack">body{display:none !important;}</style>

    //And then delete that style by its ID immediately after in the script:

    <script type="text/javascript">
	   if (self === top) {
		   var antiClickjack = document.getElementById("antiClickjack");
		   antiClickjack.parentNode.removeChild(antiClickjack);
	   } else {
		   top.location = self.location;
	   }
    </script>

	
	/*
	The second option is to use "security headers".
	There are two options for setting the "anticlickjacking" headers in your application:
	*/

	//this will completely prevent your page from being displayed in an iframe.
	Response.AddHeader("XFrameOptions", "deny")


	//this will completely prevent your page from being displayed in an iframe on other sites.
	Response.AddHeader("XFrameOptions", "SAMEORIGIN")
	




	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (18,'X Path Query','Xpath query


 Example:

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Diagnostics;
	using System.Xml;
	using System.Xml.XPath;
	namespace MvcApplication1.Controllers
	{
		public  class Class1
		{
			public string selectPath(string employeeID)
			{
			    /*
				In order to prevent xpath injections we have to treat these query''''s similar as 
				to the sql query''''s. An option would be to use a precompiled XPath query.
				But since this is a third party library I consider it untrustworthy and would
				rather use our own crafted escaping function.
			 
				NOTE: if you want to look into the precompiled xpath library you can find more
				detailed information about it on: http://www.tkachenko.com/blog/archives/000385.html
				*/

				/*
				As with every injection prevention we first focus on the expected user values
				in this case we expect an integer we use our single input validation method for integers
				See the "input validation" code example for more detailed information.
			    */

				bool continueFunction = true;
				string foo = "";

				inputvalidation validate = new inputvalidation();

				//Here we put the variable in our inputvalidation method in order to prevent untrustworthy userinput from parsing
				//NOTE: logging and countering is also done in your validation method
				if (validate.validateInput(Convert.ToString(employeeID), "numeric", "xpath input validation", "HIGH") == false) 
				{ continueFunction = false; }

				//Only if our validation function returned true we put the userinput in the function
				if (continueFunction == true)
				{
					XmlDocument xmldoc = new XmlDocument();
					try
					{
						xmldoc.Load(@"C:\Users\Public\xml\register.xml");
						foo = xmldoc.SelectSingleNode("/Employees/Employee[ID=" + employeeID + "]").InnerText;
					}
					catch (Exception e){
						if (e.Source != null)
						{
							System.Web.HttpContext.Current.Response.Write("Oops something went wrong");
							throw;
						}
					}
				}else{
					System.Web.HttpContext.Current.Response.Write("unexpected userinput detected!");
				}
					return foo;
			}
		}
	}

	/* 
	The same principle as seen in the example applies for whenever you expect alphanumeric values or even names. 
	The only difference is that you take another validation type from the input validation function 
	i.e whenever you must accept names like O''''Reilly you must encode the quotes.See the "input validation" code example
	for more detailed information about these escape methods.
	*/','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (19,'Encoding','Encoding


 Example:
	
	
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Text.RegularExpressions;

	namespace MvcApplication1.Controllers
	{
		public class encoding
		{
			public string encoder(string input, string allowed)
			{
				/*
				We can specify also special characters which where allowed in order to keep
				track of any unwanted special characters, even though they will be encoded
				violations of your system must have consequences!
				*/
				Regex regex = new Regex("^[azAZ09" + allowed + "]+$");
				Match match = regex.Match(input);
				if (!match.Success)
				{
					Log.SetLog(Session[''''userID''''], logMessage, date, "FAIL", threatLevel);
					Log.count(1);
					input = "Error";
				}
				//We return the userinput encoded
				return HttpUtility.HtmlEncode(input);
			}
		}
	}','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (20,'Secure Session Cookies','Secure session cookies


 Example:

    
	/*
	Whenever  a cookie is sent over a secured connection, the cookie should be set
	with the secure flag, in order to guarantee the integrity of the data it contains.

	in the <system.web> element, add the following element:

	<httpCookies requireSSL="true" />

	whenever you have a <forms> element in your system.web block, this setting will 
	override the setting in httpCookies, changing it''''s value back to false.

	In that case, you need to add the requireSSL="true" attribute to the forms element as well.
	*/
	
	<system.web>
		<authentication mode="Forms">
			<forms requireSSL="true"> < secure flag
				/* forms content */
			</forms>
		</authentication>
	</system.web>
	
	
	//Or programmatically
	//C Code:
	
	HttpCookie myCookie = new HttpCookie("AuthToken", guid);
	HttpContext.Current.Response.Cookies.Add(myCookie);
	myCookie.Secure = true;



	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (21,'Crossdomain.xml ','Crossdomain.xml 


 Example:

    
		A bad example of a crossdomain.xml would be:

		<?xml version="1.0" ?>
		<crossdomainpolicy>
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowaccessfrom domain="*"/>
			<allowhttprequestheadersfrom domain="*" headers="*"/>
		</crossdomainpolicy>

		Because it allows access from all other domains.

		Instead of this approach you might want to use the following restrictions. 
		Example by twitter''''s crossdomain.xml:

		<?xml version="1.0" encoding="UTF8"?>
		<crossdomainpolicy xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance" 
		xsi:noNamespaceSchemaLocation="http://www.adobe.com/xml/schemas/PolicyFile.xsd">
			<allowaccessfrom domain="twitter.com" />
			<allowaccessfrom domain="api.twitter.com" />
			<allowaccessfrom domain="search.twitter.com" />
			<allowaccessfrom domain="static.twitter.com" />
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowhttprequestheadersfrom domain="*.twitter.com" headers="*" secure="true"/>
		</crossdomainpolicy>


	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (22,'XML External Entities','XML External entities


 Example:


	/*
	The overall prevention method for loading external entities is adding the following line of code:
	This line of code function tells the underlying libxml parsing to not try to interpret the values 
	of the entities in the incoming XML and leave the entity references intact.
	*/

	/*
	In .NET Framework versions 3.5 and earlier, DTD parsing behavior is controlled by the 
	Boolean ProhibitDtd property found in the System.Xml.XmlTextReader and System.Xml.XmlReaderSettings
	classes. Set this value to true to disable inline DTDs completely:
	*/
	
	XmlTextReader reader = new XmlTextReader(stream);
	reader.ProhibitDtd = true;

	//or

	XmlReaderSettings settings = new XmlReaderSettings();
	settings.ProhibitDtd = true;
	XmlReader reader = XmlReader.Create(stream, settings);

	/*
	The default value of ProhibitDtd in XmlReaderSettings is true, but the default value 
	of ProhibitDtd in XmlTextReader is false, which means that you have to explicitly set 
	it to true to disable inline DTDs (NOT RECOMMENDED).
	*/
	
	/*
	In .NET Framework version 4.0, DTD parsing 
	behavior has been changed. The ProhibitDtd property has been deprecated in favor of 
	the new DtdProcessing property. You can set this property to Prohibit (the default value) 
	to cause the runtime to throw an exception if a <!DOCTYPE> element is present in the XML:
	
	At this point, we have hardened this code so that it is much less vulnerable to XML bombs, 
	but we haven''''t yet addressed the dangers posed by malicious external entities. 
	You can improve your resilience against these attacks if you customize the behavior 
	of XmlReader by changing its XmlResolver. XmlResolver objects are used to resolve external 
	references, including external entities. XmlTextReader instances, as well as XmlReader 
	instances returned from calls to XmlReader.Create, are prepopulated with default 
	XmlResolvers (actually XmlUrlResolvers). You can prevent XmlReader from resolving 
	external entities while still allowing it to resolve inline entities by setting the 
	XmlResolver property of XmlReaderSettings to null. This is attack surface reduction 
	at work again; if you don''''t need the capability, turn it off:
	*/
	
	XmlReaderSettings settings = new XmlReaderSettings();
	settings.ProhibitDtd = false;
	settings.MaxCharactersFromEntities = 1024;
	settings.XmlResolver = null;
	XmlReader reader = XmlReader.Create(stream, settings);

	/*
	Alternatively, you can set the DtdProcessing property to Ignore, which will not throw 
	an exception on encountering a <!DOCTYPE> element but will simply skip over it and not 
	process it. Finally, you can set DtdProcessing to Parse if you do want to allow and process inline DTDs.
	
	For extra detailed information please visit:
	https://msdn.microsoft.com/enus/magazine/ee335713.aspx 

	*/
	



	','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (23,'Anti caching header','Anticaching header


 Example:

	    
	/*
	Add the following headers to your application head in order to prevent the browser from caching
	the following code could be used in your controller:
	*/

	Response.AppendHeader("CacheControl", "nocache, nostore, mustrevalidate"); // HTTP 1.1.
	Response.AppendHeader("Pragma", "nocache"); // HTTP 1.0.
	Response.AppendHeader("Expires", "0"); // Proxies.

	
	/*
	In your classes you can use the following code:
	*/

	HttpContext.Current.Response.AppendHeader("Expires", "0");
	HttpContext.Current.Response.AppendHeader("CacheControl", "nocache, nostore, mustrevalidate");
	HttpContext.Current.Response.AppendHeader("Pragma", "nocache");
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (24,'Aggregate User Controls','Aggregate user controls


 Example:

   	
	/*
	In order to enforce Aggregate access control protection the best method would be to 
	define your rules by means of a database structure rather than sessions or logs.
	This is due to the fact that if the user drops his session the rating would start
	al over again. 

	TABLE users
	   
	| userID | userName | password | privilegeID |    access    | AggregateControl	|
	  
	|   1    | Admin    | Csdar323 |      1      |     TRUE     |		2322		|
	   
	|   2    | User     | Adf4fsv  |      2      |     FALSE    |		  0			|
	  
	|   3    | Guest    | dff4fKr  |      3      |     TRUE     |	     125		|	
	

	TABLE privileges
	   
	| privilegeID | privilege        | 
	
	|     1       | edit:read:delete |
	
	|     2       | edit:read        |
	
	|     3       | read             |
	
	*/
		
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.ComponentModel.DataAnnotations.Schema;
	using System.ComponentModel.DataAnnotations;
	using System.Data.SqlClient;


	namespace MvcApplication1.Models
	{
		[Table("users")]
		public class Aggregate
		{
			//Getters and setters for our user method
			[Key]
			public int userID { get; set; }
			public string userName { get; set; }
			public string password { get; set; }
			public string access { get; set; }
			public int aggregate { get; set; }
			public int privilege { get; set; }		

			//Here we connect to the database by means of a connection string as configured in the web.config
			SqlConnection conn = new SqlConnection
			(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

			//The count integer is set every time the user connects to the database to process data
			public void aggregateControl(int count)
			{
				//First we include the audit log class.
				AuditLog Log = new AuditLog();
			
				conn.Open();

				int control = 0;

				//the connection has to be reported into the log files
				Log.SetLog(Session[''''userID''''], "Connection to the database was made successfully", "SUCCESS", "NULL" ");

				//Here we select the number of counts from aggregate column in order to verify the number of connections:
				string query = string.Format("SELECT aggregate from users WHERE userID = @userID ");
				SqlCommand cmd = new SqlCommand(query, conn);

				//We bind the parameter in order to prevent sql injections
				cmd.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

				//Next we read the value from the database and put it into a variable
				using (SqlDataReader oReader = cmd.ExecuteReader())
				{
					while (oReader.Read())
					{
						control = Convert.ToInt32(oReader["aggregate"]);
					}
				}

				using (SqlCommand command = conn.CreateCommand())
				{
					//We update the aggregate table in the database in order to 
					//keep track of the number of connections the user made
					count += control;
				
					command.CommandText = "UPDATE users SET aggregate = @count WHERE userID = @userID";
					//Again we bind the parameters in order to prevent sql injections
					command.Parameters.AddWithValue("@count", count);
					command.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

					command.ExecuteNonQuery();
				}

				/*
				Each time the user accesses the database we keep track of the number of times he
				connected. Whenever the user passes a reasonable number he should be rejected 
				since he could be an attacker scraping your table contents and stealing company information
				You could a CRON job or stored procedure in your system in order to 
				clean the Aggregate column within certain time frames
				*/
				HttpContext.Current.Response.Write(control);
				if (control > 5000)
				{
					using (SqlCommand command = conn.CreateCommand())
					{

						//this breach has to be reported into the log files
						Log.SetLog(Session[''''userID''''], 
						"User account was locked out due to aggregate user control system", date, FAIL, HIGH");

						/*
						Whenever te reasonable number of connections the user made was surpassed we destroy all the 
						sessions to deny the user any further access to the system
						*
						HttpContext.Current.Session["authenticateUser"] = "";
						HttpContext.Current.Session.Abandon();
						HttpContext.Current.Response.Redirect("/login", true);

						/*
						Than we set his access level on his account to FALSE in order to prevent 
						him from logging in again til you did your forensics on the log files
						*/
						string access = "FALSE";
						command.CommandText = "UPDATE users SET access = @access WHERE userID = @userID";
						command.Parameters.AddWithValue("@access", access);
						command.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

						command.ExecuteNonQuery();
					}
				}
				conn.Close();
			}
		}
	}
    
	','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (25,'Password Storage(salting stretching hashing)','Password storage(salting/stretching/hashing)


 Example:


	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Security.Cryptography;

	namespace MvcApplication1.Controllers
	{
		public class hashing
		{
			public string createSalt(string password)
			{
				/*
				For generating the random salt we want to use a secure cryptographic function
				*/
				RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();

				//Then we generate a random salt
				byte[] buffer = new byte[128];
				rng.GetBytes(buffer);

				Rfc2898DeriveBytes hasher = new Rfc2898DeriveBytes(password + "ALongPepperValue", buffer, 10000);
				return Convert.ToBase64String(hasher.GetBytes(25));
			}
			
			//The salt in this function is the return value of the createSalt function
			public string hashPassword(string Salt, string Password)
			{
				Rfc2898DeriveBytes Hasher = new Rfc2898DeriveBytes(Password + "ALongPepperValue",
					System.Text.Encoding.Default.GetBytes(Salt), 10000);
				return Convert.ToBase64String(Hasher.GetBytes(25));
			}
			
			//With this function we validate the password hash
			public bool Validate(string passwordHash, string saltHash, string enteredPassword)
			{
				Rfc2898DeriveBytes Hasher = new Rfc2898DeriveBytes(enteredPassword + "ALongPepperValue",
						System.Text.Encoding.Default.GetBytes(saltHash), 10000);
				return Convert.ToBase64String(Hasher.GetBytes(25)) == passwordHash;
			}
		}
	}','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (26,'Sandboxing','Sandboxing


 Example:
    

    <iframe sandbox="value"> 
	
	/*
	sandbox=""  Applies all restrictions
	allowforms  Reenables form submission
	allowpointerlock  Reenables APIs
	allowpopups  Reenables popups
	allowsameorigin  Allows the iframe content to be treated as being from the same origin
	allowscripts  Reenables scripts
	allowtopnavigation  Allows the iframe content to navigate its toplevel browsing context
	*/

	','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (27,'Privilege Based Authentication',' Privilege based authentication


 Example:


   	/*
    For privilege based authentication we need an extra table in your database in order to write the users privileges to.

    TABLE users
        
    | userID | userName | password | privilegeID |    access	| AggregateControl	|
       
    |   1	 | Admin	| Csdar323 |	  1		 | 	   TRUE		|		2336		|
       	
    |	2	 | User		| Adf4fsv  |	  2		 |	   FALSE	|		 0			|
       
    |	3	 | Guest	| dff4fKr  |	  3		 |	   TRUE		|		135			|
       

    TABLE privileges
       
    | privilegeID | privilege 		 | 
    
    |     1	 	  | edit:read:delete |
    
    |	  2	 	  | edit:read		 |
    
    |	  3	 	  | read			 |
    

    Now instead of using roles in sessions we rather want to assign privileges to users 
    by means of a DatabaseBased Authentication system. 
    Now we can easily assign a user certain privileges for him to access.
    */
    
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Data.SqlClient;
	using System.ComponentModel.DataAnnotations;
	using System.Web.SessionState;
	using System.Text.RegularExpressions;

	namespace MvcApplication1.Controllers
	{
		public class privilegeBasedAuthentication
		{
			//Getters and setters for our user method
			[Key]
			public int userID { get; set; }
			public string username { get; set; }
			public string password { get; set; }
			public string access { get; set; }
			public string salt { get; set; }
			public int privilege { get; set; }

			//First we include the audit log class.
			auditLogs Log = new auditLogs();

			//Here we connect to the database by means of a connection string as configured in the web.config
			SqlConnection conn = 
			new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

			public string privileges()
			{
				string privileges = "";

				conn.Open();

				//the connection has to be reported into the log files
				Log.SetLog("Null", "Connection to the database was made successfully", "SUCCESS", "NULL");

				/*
				Here we select the users privilege level from the users table
				NOTE: query has to be in one line but could not fit screen otherwise
				*/
				string query = string.Format("
				SELECT a.username, a.password, a.privilegeID, b.privilegeID, 
				b.privilege FROM users as a JOIN privileges as b ON a.privilegeID = b.privilegeID 
				WHERE a.userID =@userID and a.access=''''TRUE''''");
				
				SqlCommand cmd = new SqlCommand(query, conn);

				//We bind the parameter in order to prevent sql injections
				cmd.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

				//Next we read the value from the database and put it into a variable
				using (SqlDataReader oReader = cmd.ExecuteReader())
				{
					while (oReader.Read())
					{
						privileges = Convert.ToString(oReader["privilege"]);
					}
				}
				return privileges;
			}

			//Here we check the privileges string against the permissions needed to perform the actions
			public bool validator(string privileges, string ispermitted)
			{

				bool privileged = false;
				string[] privDB = privileges.Split('''':'''');
				string[] permission = ispermitted.Split('''':'''');

				int count = permission.Length;
				int countsuccess = 0;

				foreach (string priv in privDB)
				{
					//We count the number of times the regex hits your privilege
					Regex regex = new Regex(priv);
					if (priv != "")
					{
						Match match = regex.Match(ispermitted);
						if (match.Success)
						{
							countsuccess += 1;
						}
					}
				}

				//Whenever the count is bigger or equal to the results we know the user was permitted
				if (countsuccess >= count)
				{
					privileged = true;
					//the connection has to be reported into the log files
					Log.SetLog(Convert.ToString(System.Web.HttpContext.Current.Session["userID"]), 
					"User did have the right privileges!", "SUCCESS", "NULL");
				}else{
					//the connection has to be reported into the log files
					Log.SetLog("Null", "User did not have the right privileges!", "FAIL", "NULL");

					//Terminate session since the user tries to tamper his privileges
					Log.setCounter(3);
					privileged = false;
				}
				return privileged;
			}
		}
	}

	/*
    if ever there are new ''''roles'''' added to the system you can easily assign them the needed privileges without 
    having to add new roles throughout your entire system. This system takes a little more planning up ahead but 
    it enforces higher level of security.
    */
    
    
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (28,'Identifier Based Authorization','Identifierbased authorization


 Example:
   

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.ComponentModel.DataAnnotations.Schema;
	using System.ComponentModel.DataAnnotations;
	using System.Data.SqlClient;


	namespace MvcApplication1.Models
	{
		[Table("profile")]
		public class users
		{
			//Getters and setters for our user method
			[Key]
			public int userID   { get; set; }
			public string name  { get; set; }
			public string email { get; set; }
			public string phone { get; set; }

			/*
			First we include the audit log class.
			For more detailed information see the Auditlog code example
			*/
			AuditLog Log = new AuditLog();

			/*
			We then do the same for aggregate user controls.
			For more detailed information see the Aggregate user control code example
			*/
			Aggregate aggregate =  new Aggregate();

			//Here we connect to the database by means of a connection string as configured in the web.config
			SqlConnection conn = new 
			SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

			//The count integer is set every time the user connects to the database to process data
			public void IdentifierBasedAuthentication(int pageID)
			{
				conn.Open();
				bool doFunction = true;

				/*
				First we validate if the incoming value is in fact an integer since we expect a page id number.
				If the incoming value is not a number we lockout the users since he tries to manipulate application operation.
				*/
				
				//see the "input validation" code example for more detailed information about this function
				if (validate.validateInput(pageID, "numeric", "Failed to get file", "HIGH") == false) { doFunction = false; }

				if (doFunction == false)
				{
					//First we log the fact we detected a tampering in the application operation
					Log.SetLog(Session[''''userID''''], "User tried to manipulate application operation", date, FAIL, HIGH");

					/*
					Set counter; if counter hits 3, the user''''s session must be terminated.
					After 3 session terminations the user''''s account must be blocked. 
					Given the high threat level, there will be immediate session termination.
					*/
					Log.Counter(3);
				}

				if (doFunction == true)
				{
					//the page retrieval has to be reported into the log files
					Log.SetLog(Session[''''userID''''], "Connection to the database was made successfully", date, SUCCESS, NULL");

					//We also count the connection to the database.
					aggregate.aggregateControl(1);

					/* 
					Whenever you are checking whether a user is restricted to review certain data,
					the access restrictions should be processed server side.
					The userID could be stored inside a session variable on login, and should
					be used to retrieve user data from the database when requested
					in order to verify if the user is allowed to look into that data:
					*/
					string query = string.Format("SELECT * from profile WHERE userID = @userID ");
					SqlCommand cmd = new SqlCommand(query, conn);

					//We bind the parameter in order to prevent sql injections
					cmd.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);

					//Next we read the value from the database and put it into a variable
					using (SqlDataReader oReader = cmd.ExecuteReader())
					{
						while (oReader.Read())
						{
							name  = oReader["name"].ToString();
							email = oReader["email"].ToString();
							phone = oReader["phone"].ToString();
						}
					}
				}
			}
		}
	}
	
	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (29,'Enforce sequential step order wizzard','Enforce sequential step order (Wizzard)


 Example:
	

	//Example as used in your controller:
	bool next = true;

	//We check for form submit
	if (Request.Form["submit"] != null)
	{   
		//If values are empty we return false and destroy session in else
		if (Request.Form["value1"] == "") { next = false; }
		if (Request.Form["value2"] == "") { next = false; }

		if (next == true)
		{   
			//If all went good the session can be set for step2
			Session["stepOrder"] = "step2";
		}else{
		   Session["stepOrder"] = "";
		   Session.Abandon();
		   Response.Redirect("/Home/Index", true);
		}
	}

	//If the second form was submitted and the session was successfully set to step 2 we proceed
	if ((Request.Form["submit2"] != null) && (Session["stepOrder"] == "step2"))
	{
		if (Request.Form["value3"] == "") { next = false; }

		if (next == true)
		{
			Session["stepOrder"] = "final";
		}else{
			Session["stepOrder"] = "";
			Session.Abandon();
			Response.Redirect("/Home/Index", true);
		}
	}

	//Again we check for the new valid session for doing the final operation
	if ((Request.Form["final"] != null) && (Session["stepOrder"] == "final")) { /* Do final operation! */ }
	return View();

	/*
	If the user drops his session, he has to start over again, and since we assign different values to the same session
	we force the user to follow the sequential order because else he does not get the sessions needed to proceed. 
	*/

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (30,'Preventing Session Hijacking','Session hijacking


 Example:


	/*
	As soon as a user logs into your application you must store his session id as wel as his
	IP address along with his userID. This information will be used later on in your application in order to
	identify possible session hijacking.

	TABLE track_sessions
	
	| TrackID | userID |		   	   SESSION 		            |     Ip address	    | 
	
	|   1     | 1      | 	79dcd529c0f5e01a9bfb2425c52036c6    |	123.45.67.89	|   
	
	|   2     | 1      | 	79dcd529c0f5e01a9bfb2425c52036c6    |	123.45.67.81	|
	
	|   3     | 2      | 	c80959d3ea4c166413774e45375ac2a1    |	987.65.43.21	|
	

	In order to prevent session hijacking there are a couple of defense strategies
	which combined are a hardened defense.  
	*/

	/*
	First we implement the strict transport security header, this is in order to prevent
	users from accessing your application over an unprotected connection.
	*/

	//Example of the strict transport security header:
	Response.AppendHeader("StrictTransportSecurity", "maxage=31536000");


	//If all present and future subdomains will be HTTPS:
	Response.AppendHeader("StrictTransportSecurity" maxage=31536000, "includeSubDomains");

	/*
	Recommended: If the site owner would like their domain to be included in the HSTS preload 
	list maintained by Chrome (and used by Firefox and Safari), then use:
	*/

	Response.AppendHeader("StrictTransportSecurity", "maxage=31536000", "includeSubDomains" ,"preload");

	/*
	The `preload` flag indicates the site owner''''s consent to have their domain preloaded. 
	The site owner still needs to then go and submit the domain to the list. the preload list
	enforces the browser to always present your application on HTTPS even on the first time
	the user hits your application
	*/

	/*
	Then we set the httpOnly flag
	(see "HttpOnly" in the code examples for more details about implementation)
	*/
	
	/*
	Then we set the flag for session timeout
	(see "Timeout" in the code examples for more details about implementation)
	*/
	
	/*
	Then we set the session secure flag 
	(see "Secure flag" in the code examples for more details about implementation)
	*/
	
	/*
	On login we also add another cookie with a random value to the application in order to
	prevent an attacker to fixate an ASPSESSION id on your users and hijack their sessions
	(This code example can be found in the "Login functionality" for more detailed information)
	*/
	
	
	/*
	NOTE: On applications that require high level security, there should never be an
	remember me functionality implemented.
	*/


	/*
	Now imagine the scenario after the login of the user (see the "login functionality" in
	the code examples for more details). Whenever the user is logged in, the users ip address 
	and session id are also stored in the database these values are used in order to verify 
	if there are multiple users active on the same session. 
	If so, we can let the user decide to terminate the session and terminate the
	other assigned sessions.
	*/
	
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.ComponentModel.DataAnnotations.Schema;
	using System.ComponentModel.DataAnnotations;
	using System.Data.SqlClient;
	using System.Web.SessionState;


	namespace MvcApplication1.Models
	{
		[Table("users")]
		public class users
		{
			//Getters and setters for our user method
			[Key]
			public int trackingID  { get; set; }
			public int userID      { get; set; }
			public string token    { get; set; }
			public string ipaddress { get; set; }

			//First we include the audit log class.
			AuditLog Log = new AuditLog();

			//Here we connect to the database by means of a connection string as configured in the web.config
			SqlConnection conn = new 
			SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

			//The count integer is set every time the user connects to the database to process data
			public void checkSession()
			{
				if ((System.Web.HttpContext.Current.Session["authenticateUser"] != "isLoggedin") || 
				(System.Web.HttpContext.Current.Session["authenticateUser"] == ""))
				{
					HttpContext.Current.Response.Redirect("/login", true);
				}

				conn.Open();

				string query = string.Format("SELECT * from tracking WHERE userId = @userID ");
				SqlCommand cmd = new SqlCommand(query, conn);

				//We bind the parameter in order to prevent sql injections
				cmd.Parameters.AddWithValue("@userID", System.Web.HttpContext.Current.Session["userID"]);
			
				//Next we read the value from the database and put it into a variable
				using (SqlDataReader oReader = cmd.ExecuteReader())
				{
					while (oReader.Read())
					{
						session  = oReader["session"].ToString();
						ipaddress = oReader["ipaddress"].ToString();

						if ((System.Web.HttpContext.Current.Session["ASPsessionID"].ToString() != session) && 
						(ipaddress != HttpContext.Current.Request.ServerVariables["REMOTE_ADDR"]))
						{   
							//We log the multiple users on the system 
							Log.SetLog(Session[''''userID''''], "Multiple users with same session id detected", date, FAIL, MOD");

							/*
							We redirect the user to a page which alerts him as well as gives him the option to destroy the 
							multiple sessions if he does not trust them
							*/
							HttpContext.Current.Response.Redirect("/Home/multipleUsers", true);
						}
					}
				}
			}
		}
	}    

	/*
	the only thing left to do now is to update your track_sessions table by inserting
	the ipaddress, sessionID and userID if you want to accept the other sessions as valid.
	Otherwise the user just has to terminate his current session in order to lock out the
	other sessions.
	*/



','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (31,'Charsets','Charsets


 Example:


	/*
    In order to set the "Charsets" header you''''ll have to add the 
    following code to the head of your application, the following code could be used in your controller 
    for by example, text/html:
    */
    
    Response.AppendHeader("ContentType: text/html", "charset=utf8"); 
    
	/*
	In your classes you can use the following code:
	*/
	
	HttpContext.Current.Response.AppendHeader("ContentType: text/html", "charset=utf8"); 
	

	/*
	Or directly into your html markup:
	*/
	
	<meta httpequiv="ContentType" content="text/html; charset=utf8">
	


	','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (32,'Content Type Headers','Content type headers


 Example:


    /*
    In order to set the Contenttype header, you''''ll have to add the following 
    code to the head of your application, the following code could be used in your controller:
    */
    
    Response.AppendHeader("ContentType:text/html", "charset=UTF8"); 

	/*
	In your classes you can use the following code:
	*/
	
	HttpContext.Current.Response.AppendHeader("ContentType:text/html", "charset=UTF8");
	

	


	','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (33,'XML Injection Prevention','XML injection prevention 


 Example:

   		
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Text.RegularExpressions;
	using System.IO;
	using System.Xml;

	namespace MvcApplication1.Controllers
	{
		public class storeXML
		{
			public void storeFunction(string name, string lastName, string gender)
			{
				/*
				First we import our inputvalidation control class. for more detailed information about 
				input validation check the code examples for "Input validation" & "Single input validation".
				*/
				inputValidationControl validate = new inputValidationControl();

				bool doFunction = true;
				//If the function returns false, we do not execute the function
				//see the "input validation" code example for more detailed information about this function
				if (validate.validateInput(name, "alphanumeric", "Invalid userinput name", "HIGH") == false)     { doFunction = false; }
				if (validate.validateInput(lastName, "alphanumeric", "Invalid userinput name", "HIGH") == false) { doFunction = false; }
				if (validate.validateInput(gender, "alphanumeric", "Invalid userinput name", "HIGH") == false)    { doFunction = false; }

				if (doFunction == true)
				{
					//Only after validation we proceed to the XMLwriter class where we insert the parameters
					using (XmlWriter writer = XmlWriter.Create(@"C:\Users\Public\xml\register.xml"))
					{
						writer.WriteStartElement("person");
						writer.WriteElementString("name", name);
						writer.WriteElementString("lastname", lastName);
						writer.WriteElementString("gender", gender);
						writer.WriteEndElement();
						writer.Flush();
					}
				}
			}
		}
	}

	/*
	Now we prevented malicious userinput from coming into your XML file.
	NOTE: Do not forget to also properly encode your input as a last line of defense, 
		  also In this example the XmlReader disables external entities by default.
		  If you should choose another parser make sure your parser disables these entities 
		  in order to prevent XXE injections.
	*/
          

    


','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (34,'Single input validation control','Single input validation control


 Example:
	

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Text.RegularExpressions;

	namespace MvcApplication1.Controllers
	{
		public class inputvalidation
		{

			public bool validateInput(string input, string type, string logMessage, string threatLevel)
			{
				/*
				Than we want to filter the filenames for expected values. For this example we use only az/09
				Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.           
				*/

				string validator = "";
		   
				switch (type)
				{
					case "alphanumeric":
						validator = "^[azAZ09]+$";                  
						break;
					case "numeric":
						validator = "^[09]*$";
						break;
				}
			
				Regex regex = new Regex(validator);
				bool validate = false;

				Match match = regex.Match(input);
				if (match.Success)
				{
					//If there was a match this function returns false
					validate = true;

					//this breach has to be reported into the log files
					Log.SetLog(Session[''''userID''''], logMessage, date, "FAIL", threatLevel);

					/*
					Set counter; if counter hits 3, the user''''s session must be terminated.
					After 3 session terminations the user''''s account must be blocked.
					For detailed information see the "Audit logs" in code examples.
					*/

					Log.count(1);
				}else{
					Log.SetLog(Session[''''userID''''], logMessage, date(), "SUCCESS", "NULL");
				}
				return validate;
			}
		}
	}

	//Usage:
	if(validate.validateInput(Convert.ToString(employeeID), "numeric", "input validation", "HIGH") == false) 
	{ 
		continueFunction = false; 
	}
	','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (35,'File Upload','File upload


 Example:
	
	
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Text.RegularExpressions;
	using System.IO;
	using System.Xml;

	namespace MvcApplication1.Controllers
	{ 
		public class auditLogs
		{
			private bool continueFunction = true;
			validation validate = new validation();

			//We check for form submit
			public void upload(HttpPostedFileBase file)
			{
				//We get the filename for doing different types of tests on it
				string test = file.FileName;

				/*
				First we check if the value is alphanumeric only to prevent uploading out of intended directory, 
				as wel as other injections
				*/
				if (validate.validateInput(test, "alphanumeric", "validation failed", "HIGH") == false)
				{
					continueFunction = false;
				}

				/*
				The next step would be checking if the file contains the right extension in order to prevent
				a user from uploading files which could be used to harm your system. in this example 
				we check if the last extension found in the file name is a jpg or a png. whenever
				an application just regexes for the extension an attacker could
				bypass the check by uploading an file like: "filename.jpg.php".
				*/
				string[] StrSpli = test.Split(''''.'''');
				int count = StrSpli.Count()  1;

				if ((StrSpli[count] != "png") && (StrSpli[count] != "jpg"))
				{
					continueFunction = false;
					HttpContext.Current.Response.Write("end of function");
				}

				/*
				 If the file came through all the different checks, it is time to upload the file to your system. 
				 */
				if (continueFunction == true)
				{
					if (file != null && file.ContentLength > 0)
					{

						try
						{
							// extract only the filename
							var fileName = Path.GetFileName(file.FileName);

							// The location of stored files should always be outside of your root
							var path = Path.Combine(@"C:\Users\Public\xml", fileName);
							file.SaveAs(path);
						}
						catch{
							HttpContext.Current.Response.Write("File did not upload!");
						}
					}
				}else{
					HttpContext.Current.Response.Write("end of function we returned false");
				}

				/*
				Now we check the uploaded file for the right mimetype
				We do this after the upload instead of checking the content type header since that header 
				can easily manipulated by an attacker. 
				*/

				string mimeType = "application/unknown";
				string ext = System.IO.Path.GetExtension(@"C:\Users\Public\xml\"+test+"").ToLower();

				Microsoft.Win32.RegistryKey regKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(ext);

				if (regKey != null && regKey.GetValue("Content Type") != null)
				{
					mimeType = regKey.GetValue("Content Type").ToString();
				}

				if (mimeType != "image/jpeg") 
				{   
					//If the mimetype is not valid we delete the file from the system.
					System.IO.File.Delete(@"C:\Users\Public\xml\"+test+"");
				}
			}
		}
	}
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (36,'Login functionality','Login functionality


 Example:
	

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Data.SqlClient;
	using System.ComponentModel.DataAnnotations;
	using System.Web.SessionState;

	namespace MvcApplication1.Controllers
	{
		public class login
		{
			//Getters and setters for our user method
		    [Key]
			public int userID { get; set; }
			public string username { get; set; }
			public string password { get; set; }
			public string access { get; set; }
			public string salt { get; set; }
			public int privilege { get; set; }

			//First we include the audit log class.
			auditLogs Log = new auditLogs();

			//Second we include the password hash.
			hashing hash = new hashing();

			//Third we include the random password/token class.
			randomizer CSRF = new randomizer();

			//Last we include the random inputvalidation class.
			inputvalidation validate = new inputvalidation();

			public bool loginUser()
			{
				//Here we connect to the database by means of a connection string as configured in the web.config
				SqlConnection conn = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["users"].ConnectionString);

				bool loggedin = false;
            	string passwordHash = "";
            	string userId = "";
				conn.Open();

				//we also validate the username input, if it was bad we empty the string:
				if (validate.validateInput(username, "alphanumeric", "Error in username", "LOW", 0) != true) { username = ""; }

				//Here we select the user from the users table
				string query = string.Format("SELECT * from users WHERE username = @name ");
				SqlCommand cmd = new SqlCommand(query, conn);

				//We bind the parameter in order to prevent sql injections
				cmd.Parameters.AddWithValue("@name", username);

				//Next we read the value from the database and put it into a variable
				using (SqlDataReader oReader = cmd.ExecuteReader())
				{
					while (oReader.Read())
					{
						username = Convert.ToString(oReader["username"]);
						passwordHash = Convert.ToString(oReader["password"]);
						salt = Convert.ToString(oReader["salt"]);
						userId = Convert.ToString(oReader["userID"]);
					}
				}

				/*
				We validate the password see "Password storage(salting stretching hashing)" in the code examples
				for more detailed information:
				*/
				if (hash.Validate(passwordHash, salt, password) == true)
				{
					/*
					This is is to prevent session fixation, after login we create a new cookie which
					we than use to authenticate. This value can not be fixated since it is set after 
					login.
				 
					create a a new GUID and save into the session:
					*/

					string guid = Guid.NewGuid().ToString();
					HttpContext.Current.Session["AuthToken"] = guid;

					// now create a new cookie with this guid value
					HttpContext.Current.Response.Cookies.Add(new HttpCookie("AuthToken", guid));

					//the connection has to be reported into the log files
					Log.SetLog("Null", "login was OK!", "SUCCESS", "NULL");

					/*
					Now we create a random value for our CSRF tokens. See "Random password/token generation" in
					the code examples for more detailed information:
					*/
					string CSRftoken = CSRF.generate(25);
					System.Web.HttpContext.Current.Session["CSRF"] = CSRftoken;

					//Set an accessor session.
					System.Web.HttpContext.Current.Session["Authenticated"] = "access";

					/*
					Put id in a session for query identifier based authentication
					See "identifier based authentication" code example for more information
					 */
					System.Web.HttpContext.Current.Session["userID"] = userId;

					loggedin = true;
				}else{
					//the connection has to be repported into the log files
					Log.SetLog("null", "Login failed!", "FAIL", "NULL");
					loggedin = false;
					HttpContext.Current.Response.Redirect("/login", true);
				}
				return loggedin;
			}

			//In this method we do a check if the sessions are ok
			public void checkSession()
			{
				//We use this try catch for whenever the cookie is dropped
				try
				{   
					//Check sessions and cookies to see if they match
					if (!HttpContext.Current.Session["AuthToken"].ToString().Equals(
						HttpContext.Current.Request.Cookies["AuthToken"].Value)
						|| (HttpContext.Current.Session["Authenticated"] != "access"))
					{
						HttpContext.Current.Response.Redirect("/login", true);
					}
				}
				catch (NullReferenceException e){
					if (e.Source != null)
					{   
						HttpContext.Current.Response.Redirect("/login", true);
						HttpContext.Current.Session["Authenticated"] = "";
						HttpContext.Current.Session.Clear();
						HttpContext.Current.Session.Abandon();
						HttpContext.Current.Session.RemoveAll();
					}
				}
			}
		}
	}

','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (37,'Disable Directory Listing','Disable directory listing


 Example:


		<configuration>
			<location path="Secured">
			<system.webServer>
				<directoryBrowse enabled="false" />
			</system.webServer>
			</location>
		</configuration>

		this example applies to IIS 7+, for IIS 6 you''''ll have to do it from IIS Manager




	
','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (38,'HTML Output','HTML output


 Example:


	/*
	Whenever user input is displayed in the application all user input should be properly escaped 
	to prevent XSS injections.

	The C razor engine encodes userinput by default whenever this is not disabled in the web.config
	when outputted on screen, BUT you should get used to putting your variables in encoding functions
	and make this a habit simply "assuming" your input will be encoded properly is a jack in the box waiting to
	pop out and bite you in the ....as you will find out when you read on
	*/

	/*
	This escaping is used whenever you put the code straight into the html like:
	<span>YOUR USERINPUT</span>
	The attack bellow will now be outputted as,
	&lt;script&gt;alert(1337);&lt;/script&gt;
	*/
	ViewBag.html = HttpUtility.HtmlEncode("<script>alert(1337);</script>");

	/*
	This next encoding method is used for whenever you are allowing userinput into 
	html attributes.
	The attack below will now be outputted as:
	onload=&amp;39;alert(1337)&amp;39;
	*/
	ViewBag.htmlatr = HttpUtility.HtmlAttributeEncode("onload=''''alert(1337);''''");

	/*
	Whenever parameters are rendered via JavaScript your application will detect normal injections
	in the first instant. But your application still remains vulnerable to JavaScript encoding which will not
	be detected by the ASP.NET encoder. You MUST use the JavaScriptStringEncode function, any other 
	escaping function still leaves your code vulnerable
	*/
	ViewBag.java = HttpUtility.JavaScriptStringEncode(@"""\x3Cscript\x3Ealert(12);\x3C\x2Fscript\x3E""");
   
	/*
	Whenever a user can submit an link/AHREF in your application you must solely depend upon the
	"HttpUtility.UrlEncode" method since an attacker could otherwise inject the href with an XSS
	that looks like this "javascript:alert("XSS");" whenever a victim now clicks the link this XSS
	will be executed in his browser.
	*/ 
	ViewBag.url = HttpUtility.UrlEncode("JavaScript:alert(234);");

	/*
	Security consists of different layers of protection in order to guarantee the integrity
	of your application. This means that the value displayed from the database/user should
	already be sanitized before being processed in order to prevent XSS.
	
	As an example, what do you do when you expect a numeric value from your application?
	
	EXACTLY you first sanitize the userinput by means of an input validation method like:
	See the "input validation" class for the entire example!
	*/

	inputvalidation validate = new inputvalidation();
	string userinput = "when this string is evil the application will block operation!";
	if(validate.validateInput(userinput, "numeric", "Unexpected userinput", "HIGH", 3)== false)
	{ /* Cancel operation of your application */ }

	/*
	In this example the application cancelled the request by means of simple validation.
	*/','asp-needs-reviewing',1);
INSERT INTO "code_items" VALUES (39,'Disable Directory Listing',' Disable Directory Listing 


 Example:


    // Directory Listing configuration in web.xml 

    <servlet>
        <servletname>default</servletname>
        <servletclass>
        org.apache.catalina.servlets.DefaultServlet
        </servletclass>
        <initparam>
            <paramname>debug</paramname>
            <paramvalue>0</paramvalue>
        </initparam>
        <initparam>
            <paramname>listings</paramname>
            <paramvalue>false</paramvalue>    <! This setting enables/disables directory listings >
        </initparam>
        <loadonstartup>1</loadonstartup>
    </servlet>

    ','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (40,'Password forget and disallow old passwords',' Password forget and disallow old passwords


 Example:


	/*
	Whenever you are developing a password forget function, these are the steps to follow
	in order to create hardened defenses.

	TABLE users
	
	| userID | userName | password |   EmailAddress   |    access    |
	   
	|   1    | Admin    | Csdar323 | info@admin.com  |     TRUE     |
	       
	|   2    | User     | Adf4fsv  | info@user.com   |     FALSE    |
	    
	|   3    | Guest    | dff4fKr  | info@guest.com  |     TRUE     |
	


	TABLE passwordForget
	   
	| forgotPasswordID |        Token            |  UserID |   Active   |     olPasswords   |
	
	|        1         |    c3ab8ff13720e....    |    1    |    YES     |      Csdar323     |
	
	|        2         |    7dd39466b3c89....    |    1    |    NO      |       ef0c4f2     |
	
	|        3         |    83d4a3960714c....    |    3    |    NO      |       dff4fKr     |
	


	As you can see we also store the old passwords into the password forget table, this
	we do in order to prevent the user from using old passwords later on in the process.

	Also use a CRON job to make sure the generated tokens for the password reset are
	expire after a certain amount of time like 20 minutes.
	*/


	package com.edw;

	import java.io.UnsupportedEncodingException;
	import java.security.InvalidKeyException;
	import java.security.NoSuchAlgorithmException;
	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	public final class PasswordForget {

		final static Logger logger = Logger.getLogger(PasswordForget.class);
		private String password = "" ; 
		public int userID; 
		private Randomizer rand = new Randomizer();
		private String active = "";
		public String token = ""; 
		
		
		public String checkValidity(String email)
		{
			boolean emptyrows = false;
			String message = ""; 
			
			//Here we connect to the database by means of a connection string as configured in the web.xml and /METAINF/context.xml 
			Connection conn = null;
			try {
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();	

				//Here we select the number of counts from aggregate column in order to verify the number of connections:
				String query = "SELECT * FROM members WHERE email = ?";
			
				//We bind the parameter in order to prevent sql injections
				PreparedStatement st = conn.prepareStatement(query);
				st.setString(1, email);
				
				// execute the query, and get a java result set
				ResultSet rs = st.executeQuery();
				
				while (rs.next())
				{
					password  = rs.getString("password");
					userID 	= rs.getInt("userID");
					email 	= rs.getString("email");
				}
				
				//If the select was not empty we will be sending an email to the user as well as
				//preparing the password forget function
				if (rs.next() == false)
				{
					emptyrows = true; 	    	  
				}
				rs.close();
				
				if (emptyrows == true)
				{ 	  
					message = "An email was sent to reset your password";
					/*
					Before we do anything we first set all other possible active statuses to NO
					in order to prevent an attacker creating a whole lot of tokens than FUZZING 
					the password reset token. 
					*/
					active  = "NO";   
					String query2 = "UPDATE forgetPassword SET active= ? WHERE userID= ?";
					//We bind the parameter in order to prevent SQL injections
					PreparedStatement st2 = conn.prepareStatement(query2);    
					st2.setString(1, active);
					st2.setInt(2, userID);
					
					// execute the query, and get a java result set
					st2.executeQuery();
					st2.close();
					
					String query3 = "INSERT INTO forgetPassword"
							+ " (token, userID, active, oldPasswords)"
							+ " VALUES"
							+ " (?, ?, ?, ?)";

					//We bind the parameter in order to prevent SQL injections
					PreparedStatement st3 = conn.prepareStatement(query3);  
					//Here we generate the password forget token
					String token = rand.generateToken(30);
					st3.setInt(1, userID);
					st3.setString(2, token);
					st3.setInt(3, 1);
					st3.setString(4, password);
					
					// execute the query, and get a java result set
					st3.executeQuery();
					st3.close();
					//Here we send an email to the user with the needed reset function
					String msg = "follow this link to reset your password http://example.com/index.jsp?resetLink=$token";
					SendEmail mail = new SendEmail();
					mail.sendmail(email, "Password reset", msg);   
				}else{
					/*
					We show the user the same message in order to prevent the enumeration of
					valid email addresses.
					*/
					message = "An email was sent to reset your password";  
				}
				
				rs.close();
				st.close();
				conn.close();
			
			} catch (SQLException | NamingException e) {
				logger.error("cannot search database. check query" + e.toString() );
			}
			return message; 
			//this return value can be used from SERVLETs in order to manipulate HTTP responses to send messages back to JSP pages  
		}

		public String resetPassword(String resetlink, String Password) throws InvalidKeyException, NoSuchAlgorithmException, UnsupportedEncodingException{
			Hashing hasher = new Hashing();
			String message = ""; 		
			/*
			Imagine the user clicked on his link with the token included and is redirected towards
			the page where he can enter his new password.
			
			Now we select the information from the forgot password function where the
			forgot tokens matches the token in the database.
			*/
			active = "YES"; 
			//Here we connect to the database by means of a connection string as configured in the web.xml and /METAINF/context.xml 
			Connection conn = null;
			try {
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();	

				//Here we select the number of counts from aggregate column in order to verify the number of connections:
				String query = "SELECT  a.userID, a.token, b.id"
						+ " FROM forgetPassword as a "
						+ "JOIN members as b"
						+ " ON a.userID = b.id WHERE token=? and Active=? ";
			
				//We bind the parameter in order to prevent SQL injections
				PreparedStatement st = conn.prepareStatement(query);
				st.setString(1, resetlink);
				st.setString(2, active);
				
				// execute the query, and get a java result set
				ResultSet rs = st.executeQuery();
				
				while (rs.next())
				{
					token     = rs.getString("token");
					userID 	= rs.getInt("userID");
				}
				
				if (resetlink.equals(token))
				{
					/*
					First we pull the password through createSalt function which enforces the input of
					secure passwords.
					*/
					String oldpassword = ""; 	
					String salt = hasher.createSalt(Password);    	
					/*
					Then we encrypt the password 
					*/	    	
					String newpassword = hasher.hashPassword(salt, Password);
					
					/*
					Finally we compare the password against other old passwords from the 
					password reset database in order to prevent the user from using old passwords 
					which could already be compromised by any means.
					*/

					//Here we select the number of counts from aggregate column in order to verify the number of connections:
					String query2 = "SELECT oldPasswords FROM forgetPassword where userID = ?";
				
					//We bind the parameter in order to prevent SQL injections
					PreparedStatement st2 = conn.prepareStatement(query2);
					st2.setInt(1, userID);
					// execute the query, and get a java result set
					ResultSet rs2 = st2.executeQuery(); 
					while (rs2.next())
					{
						oldpassword = rs2.getString("oldPasswords");
					}
					
					if (newpassword.equals(oldpassword))
					{
						message = "This was an old password please do not use this password";	
					}else{
						active = "NO";
						
						//First we update the new password for the user
						String query3 ="UPDATE members SET password=? WHERE userID=?";
						
						//We bind the parameter in order to prevent SQL injections
						PreparedStatement st3 = conn.prepareStatement(query3);	
						st3.setInt(1, userID);
						
						// execute the query, and get a java result set
						st3.executeQuery();
						
						//First we update the new password for the user
						String query4 ="UPDATE forgetPassword SET active=? WHERE userID=?";
						
						//Then we destroy the reset token by setting it''''s value to NO
						PreparedStatement st4 = conn.prepareStatement(query4);
						st4.setString(1, active);
						st4.setInt(2, userID); 
						
						// execute the query, and get a java result set
						st4.executeQuery();  
						
						rs2.close();
						st2.close();
						st3.close();
						st4.close();
						conn.close();
					}
					st2.close();    
				}
				st.close();
				conn.close();   
			} catch (SQLException | NamingException e) {
				logger.error("cannot search database. check query" + e.toString() );
			}
			return message; //this return value can be used from SERVLETs in order to manipulate HTTP responses to send messages back to JSP pages 
		}	
	}

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (41,'Timeout Sessions',' Timeout Sessions 


 Example:


    /*
    Within your web.xml you can configure your session idle timeout.
    The default time is set to 20 minutes.
    */

    <webapp>
    ...
      <sessionconfig>
        <sessiontimeout>20</sessiontimeout> <! in minutes >
      </sessionconfig>
    </webapp>

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (42,'Directory path traversal attack',' Directory Path traversal


 Example:


    package com.edw;
    import java.io.File;
    import java.io.FileInputStream;
    import java.io.IOException;
    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import com.edw.InputValidation;
    import com.edw.WhiteList;
    import org.apache.log4j.Logger;

    public class Rewrite extends HttpServlet
    {

        private static final long serialVersionUID = 1L;
        private File getFile;
        /**
        * @see HttpServletHttpServlet()
        */
        public Rewrite() {
            super();
        }
        
        final static Logger logger = Logger.getLogger(Rewrite.class);
        
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 
        {
            InputValidation validate = new InputValidation();
            WhiteList listme = new WhiteList();

            /*
            First, we want to filter the filenames for expected values. For this example we use only use 09
            Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.           
            */
            boolean validated = true;

            //see the "input validation" code example for more detailed information about this function
            
            final boolean validInput = validate.validateInput(getFile.toString(), "numeric", "Failed to get file", "HIGH");
            
            if (!validInput) { 
                validated = false; 
            }
            /*
            see the "WhiteListing" code example for more detailed information about this function
            Let''''s assume there are three files named 1,2,3
            */

            if (listme.WhiteListing("1,2,3", getFile.toString()) == false) { validated = false; }

            //Only if the pattern was true we allow the variable into the streamreader function
            if (validated)
            {
                String canonicalPath = getFile.getCanonicalPath();
                if (!canonicalPath.equals("C:\\....\\WEBINF" + getFile)) 
                {
                    // Invalid file; handle error
                }            	 
                FileInputStream fis = new FileInputStream(canonicalPath);            	
            }else{
                logger.error("invalid user input was detected!");              
            }
            doGet(request,response);
        }
        
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            response.getWriter().append("Served at: ").append(request.getContextPath()).append("  OWASP Knowledge Base Code Examples");
        }
    }
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (43,'Logout',' Logout 


 Example:


	package com.edw;

	import java.io.IOException;
	import javax.servlet.ServletException;
	import javax.servlet.annotation.WebServlet;
	import javax.servlet.http.Cookie;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;

	/*
	 Servlet implementation class Logout
	*/
	@WebServlet("/Logout")
	public final class Logout extends HttpServlet {
		private static final long serialVersionUID = 1L;
		
		/**
		* @see HttpServletHttpServlet()
		*/
		public Logout() {
			super();
		}

		/**
		* @see HttpServletdoGet(HttpServletRequest request, HttpServletResponse response)
		*/
		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			response.getWriter().append("Served at: ").append(request.getContextPath());
		}

		/**
		* @see HttpServletdoPost(HttpServletRequest request, HttpServletResponse response)
		*/
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			
			request.getSession().invalidate();
			request.getSession().setAttribute("Authenticated", "");
			
			Cookie cookie = null;
			Cookie[] cookies = null;
			// Get an array of Cookies associated with this domain
			cookies = request.getCookies();
				
			for (Cookie cookie2 : cookies) {
				cookie = cookie2;
				
				if (cookie.getName().equals("JSESSIONID"))
				{        	 
					cookie.setValue("");
				}
			
				response.addCookie(null);
				request.setAttribute("msg","Session terminated!");
				request.getRequestDispatcher("/login.jsp").forward(request, response);
				return;
			}
		}
	}
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (44,'Enforce secure password',' Enforce Secure Password


 Example:


    package com.edw;

    import java.io.BufferedReader;
    import java.io.FileReader;
    import java.io.IOException;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;

    import org.apache.log4j.Logger;

    public final class PasswordCheck {
        
        final static Logger logger = Logger.getLogger(PasswordCheck.class);
        
        public boolean checkPassword(String password)
        {
            
            String error = "";
            boolean complete = true;
            
            /*
            for example here we define the expected value''''s for your password.
            
            ^                  startofstring
            (?=.*[09])        a digit must occur at least once
            (?=.*[az])        a lower case letter must occur at least once
            (?=.*[AZ])        an upper case letter must occur at least once
            (?=.*[@$%^&+=])   a special character must occur at least once
            (?=\S+$)           no whitespace allowed in the entire string
            .{8,}              anything, at least eight places though
            $                  endofstring
            */
            
            String validation = "^(?=.*[09])(?=.*[az])(?=.*[AZ])(?=.*[@$%^&+=])(?=\S+$).{8,}$";    

            // Create a Pattern object
            Pattern reg = Pattern.compile(validation);
            // Now create matcher object.
            Matcher match = reg.matcher(password);
            if (!match.find()) {	
                error = "You did not enter a valid password";
                complete = false;  
            }

            /*
            Also we have to take into consideration that Password1! is a valid password according to password standards. This however is not the case since this password is included in almost every dictionary attack mechanisms. So we have to prevent the user from using these weak passwords. In such case we will define these bad passwords in a text 
            file in order to compare the user''''s password with the list of bad passwords inside that file.
            */
            
            try {
                BufferedReader in = new BufferedReader(new FileReader("C:\\Users\\Public\\xml\\test.txt"));
                String[] strTemp = null ;
                String line;
                
                while((line = in.readLine()) != null)
                {                
                    strTemp = line.split(",");
                }
                
                for (String value : strTemp)
                {	 
                    if (value.equals(password))
                    {
                        error = "Your password was a bad password!";
                        complete = false;
                    }          
                }
                in.close();
            }
            catch(IOException e) {
                logger.error(e.toString());
            }
        
            //The last step is checking the password length to see if it is 8 characters or bigger
            if (password.length() < 8)
            {
                error = "The password was to short";
                complete = false;
            }

            if (complete)
            {
                //Do further operation
                return true;
            }else{
                return false;
            }
        }
    }

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (45,'File uploading',' File Uploading 


 Example:


    /*
    In this example we show the steps that must be taken in order to upload a file securely. The main steps are input validation ,file extension checks and mime type checks. 
    the following code snipet shows the jsp page that performs the post action to upload a certain file to destination 
    */

    <%@ page language="java" contentType="text/html; charset=ISO88591" pageEncoding="ISO88591"%>
    <!DOCTYPE html PUBLIC "//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    <html>
        <head>
            <title>File Upload</title>
            <meta httpequiv="ContentType" content="text/html; charset=UTF8">
        </head>
        <body>
            <form method="post" action="FileUpload" enctype="multipart/formdata" >
                File:
                <input type="file" name="file" id="file" /> <br/>
                Destination:
                <input type="text" value="C:\Users\someuser\Desktop\test" name="destination"/>
                </br>
                <input type="submit" value="Upload" name="upload" id="upload" />
            </form>
            <%
            String message =  " "; 
            message = (String) request.getAttribute("msg");
            if (message == null)
            {
                message = " ";
            }
            out.println(" " + message);
            %> 
        </body>
    </html>


    // The following code snippet performs the file uploading functionality from the post action performed at the jsp page showed above


    package com.edw;
    import java.io.File;
    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.io.IOException;
    import java.io.InputStream;
    import java.io.OutputStream;
    import java.io.PrintWriter;
    import java.lang.reflect.InvocationTargetException;
    import java.time.LocalDateTime;
    import java.util.List;
    import org.apache.log4j.Logger;

    import javax.servlet.RequestDispatcher;
    import javax.servlet.ServletException;
    import javax.servlet.annotation.MultipartConfig;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import javax.servlet.http.Part;
    import com.Lib.AuditLog;
    import com.Lib.WinRegistry;
    import com.Lib.InputValidation;

    import org.apache.commons.io.FilenameUtils;

    @MultipartConfig
    public final class FileUpload extends HttpServlet {
        
        /**
        * 
        */
        private static final long serialVersionUID = 1L;
        final static Logger logger = Logger.getLogger(FileUpload.class);
        private AuditLog Log = new AuditLog(); 
        InputValidation validate = new InputValidation();

        //We check for form submit
    
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
        {
            response.setContentType("text/html;charset=UTF8");
            String userID = request.getSession().getAttribute("userID");
            boolean continueFunction = true;
            boolean sessionTermination = false;
            boolean blockAccess = false ;
            
            // Create path components to save the file
            // The location of stored files should always be outside of your root
            
            // the destination path used to store the file gotten from the POST parameter
            
            final String path = request.getParameter("destination");
            final File f = new File(path);
            final Part filePart = request.getPart("file");
            //We get the filename for doing different types of tests on it
            final String fileName = getFileName(filePart);
        
            /*
            First we check if the value is alphanumeric only to prevent uploading out of intended directory, 
            as wel as other injections
            */
            
            if (validate.validateInput(userID, fileName, "alphanumeric", "validation failed",request.getRemoteAddr(),"HIGH").equals("validation failed"))
            {
                continueFunction = false;
            }
            
            else if (validate.validateInput(userID, fileName, "alphanumeric", "Session Termination",request.getRemoteAddr(),"HIGH").equals("terminate"))
            {
                request.getSession().invalidate();
                continueFunction = false;
                sessionTermination=true;
            }   
            
            else if (validate.validateInput(userID, fileName, "alphanumeric", "Block access",request.getRemoteAddr(),"HIGH").equals("block"))
            {
                continueFunction = false;
                blockAccess=true;
            }else{
                Log.SetLog(userID, "Validated Successfully" , "SUCCESS", LocalDateTime.now(),request.getRemoteAddr(),  "");           
            }
            
            /*
            The next step would be checking if the file contains the right extension in order to prevent
            a user from uploading files which could be used to harm your system. in this example 
            we check if the last extension found in the file name is a jpg or a png. whenever
            an application just regexes for the extension an attacker could
            bypass the check by uploading an file like: "filename.jpg.php".
            */       
            
            String  fileExtension = FilenameUtils.getExtension(fileName);

            if (!fileExtension.equals("jpg") && !fileExtension.equals("png") )
            {
                continueFunction = false;
            }

            /*
            If the file came through all the different checks, it is time to upload the file to your system. 
            */
            if (continueFunction == true)
            {       
                OutputStream out = null;
                InputStream filecontent = null;

                //start uploading the file
                try {
                    out = new FileOutputStream(new File(path + File.separator + fileName));
                    filecontent = filePart.getInputStream();

                    int read = 0;
                    final byte[] bytes = new byte[1024];

                    while ((read = filecontent.read(bytes)) != 1) {
                        out.write(bytes, 0, read);
                    }
                            
                    logger.info("File" + fileName + "has been uploaded to" + path); 
                    
                } catch (FileNotFoundException fne) {

                    logger.error("Problems during file upload. Error:" + fne.toString());
                
                } finally {
                    if (out != null) {
                        out.close();
                    }
                    if (filecontent != null) {
                        filecontent.close();
                    }
                }
            }
            
            /*
            Now we check the uploaded file for the right mimetype
            We do this after the upload instead of checking the content type header since that header 
            can easily manipulated by an attacker. 
            */
                    
            List<String> ls = null;
            String key = null;
            try {
                ls = WinRegistry.readStringSubKeys(WinRegistry.HKEY_LOCAL_MACHINE,"SOFTWARE\\Classes\\");
                key = ls.stream().filter(st > st.matches("."+StrSpli)).findAny().orElse(null);
                
            } catch (IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {
                logger.error("Problems during file upload. Error: " + e.toString());
            }
            
            
            String mimeType = "application/unknown";
            try {
                mimeType = WinRegistry.readString(WinRegistry.HKEY_LOCAL_MACHINE, "SOFTWARE\\Classes\\"+key, "Content Type");
            } catch (IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {
                logger.error("Problems reading the extension value on Windows registry. Error: " + e.toString());
            }

            if (mimeType == null || !mimeType.equals("image/jpeg"))
            {
                //If the mimetype is not valid we delete the file from the system.
                f.delete();
                continueFunction = false;                
            }  

            if (continueFunction == false && sessionTermination == false && blockAccess == false)
            {    
                request.setAttribute("msg","FAIL! file has not been uploaded");	
                RequestDispatcher dd = request.getRequestDispatcher("/FileUpload.jsp");
                dd.forward(request, response);			    
                return;		   
            }
            
            if (continueFunction == true && sessionTermination == false && blockAccess == false)
            {
                request.setAttribute("msg","SUCCESS! file uploaded");
                request.getRequestDispatcher("/FileUpload.jsp").forward(request, response);
                return;
            }      
                    
            if (continueFunction == false && sessionTermination == false && blockAccess == true)
            {  
                request.setAttribute("msg","Access Blocked!");
                request.getRequestDispatcher("/error.jsp").forward(request, response);
                return;
            }
            
            if (continueFunction == false && sessionTermination == true && blockAccess == false)
            {  
                request.getSession().invalidate();
                request.setAttribute("msg","Session terminated!");
                request.getRequestDispatcher("/error.jsp").forward(request, response);
                return;
            }       
        }

    @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

            super.doGet(req, resp);
        }

        /*
        reading from headers 
        ...
        POST /fileupload/upload HTTP/1.1
        Host: localhost:8080
        ContentType: multipart/formdata; 
        boundary=263081694432439
        ContentLength: 441
        263081694432439
        ContentDisposition: formdata; name="file"; filename="sample.txt"
        ContentType: text/plain
        [ ..... ]
        */

        private String getFileName(final Part part)
        {
            final String partHeader = part.getHeader("contentdisposition");
            logger.info("Part Header = " + partHeader)
            
            for (String content : part.getHeader("contentdisposition").split(";"))
            {
                if (content.trim().startsWith("filename"))
                {
                    return content.substring(content.indexOf(''''='''') + 1).trim().replace("\"", "");
                }
            }
            return null;
        }   
    }


','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (46,'CSRF Token JSF',' CSRF Tokens  JSF


 Example:


	/*

	For CSRF tokens we used a separate class outside of the normal controller, since
	it must be reused on several locations throughout the application

	After a successful validation of a user login, the application must also start a session
	which contains the "cross site request forgery" token.

	From the Randomizer class we are generating the token we want by using a secure cryptographic function
	SecureRandom csprng = new SecureRandom();

	Then we generate a long value token containing a high entropy
	byte[] randomBytes  = new byte[128];

	prng.nextBytes(randombytes);

	Then we base64 encode the string
	String csrfToken = Base64.getEncoder().encodeToString(randomBytes);

	Then we set the session attribute.

	origRequest.getSession(false);
	origRequest.getSession().setAttribute("CSRF", csrfToken);

	The next step is to implement this random token in each form field as a hidden input parameter
	and send it to a function which checks if the submitted token is equal to the one set after successful validation.

	The following .xhtml snippet shows the code used to place the antiCSRF token inside the page.
	When the page renders, the <cu:antiCSRF/> is created as a viewstate encoded html input tag
	which then carries the antiCSRF token.
	While in process of rendering the page, a new token is generated
	and added into the existing session.
	When the user press the commandButton
	then CSRF token parameter is compared with the CSRF session parameter. 

	*/


	/*
	<f:view contentType="text/html">    
	<f:event listener="{userLoginView.isAuthenticated}" type="preRenderView" />
	[ .... ]

	<p:commandButton action="password?facesredirect=true" value="Add User" ajax="false">
	<cu:antiCSRF/>
	</p:commandButton>
	</h:form>

	[ .... ]

	/* 

	the following function used to generate the new Session which then is added to the already existing session. 

	*/


	public void generateToken(){
			
			HttpServletRequest origRequest = (HttpServletRequest)FacesContext.getCurrentInstance().getExternalContext().getRequest();

			//we include the random password/token class.
			Randomizer CSRF = new Randomizer();
			/*
			Now we create a random value for our CSRF tokens. See "Random password token generation" in
			the code examples for more detailed information:
			*/
			String CSRftoken = CSRF.generate(25);
					
			//Set an accessor session.
			origRequest.getSession(false);
			origRequest.getSession().setAttribute("CSRF", CSRftoken);
		}

	/* 
	the following function used to destroy the cookie and invalidate the session when the CSRF tokens dont match 
	*/

		public void antiCSRF() throws IOException
		{	

			ExternalContext externalContext = FacesContext.getCurrentInstance().getExternalContext();
			HttpServletRequest origRequest = (HttpServletRequest)externalContext.getRequest();
			HttpServletResponse origResponse = (HttpServletResponse)externalContext.getResponse();
			String AUTH_KEY =  (String) externalContext.getSessionMap().get("AUTH_KEY");
			externalContext.getSessionMap().remove(AUTH_KEY);
			externalContext.invalidateSession();
			
			// Get an array of Cookies associated with this domain
			Cookie[] cookies = origRequest.getCookies();		         
			for (Cookie cookie : cookies) 
			{	         
					if ("JSSESIONID".equalsIgnoreCase(cookie.getName()))
					{        	 
						cookie.setValue(null);	       		
						origResponse.addCookie(cookie);
					
						Log.SetLog("", "", "Cookie has been destroyed!", LocalDateTime.now(), "", "");    
					} 
			}		     
		}

	/* 
	This function used to decode the viewstate and get the token value from the html input tag. Also it performs token comparison between the antiCSRF token values of the html component and the session attribute. If the comparison fails then the session must be invalid.

	*/ 
			public void decode(FacesContext context) {
				FacesContext fc = FacesContext.getCurrentInstance();

				// access the hidden input field value
				ExternalContext external = context.getExternalContext();
				Map<?, ?> requestMap = external.getRequestParameterMap();
				String value = String.valueOf(requestMap.get("_CSRFToken"));

				// access the session and get the token
				HttpSession session = (HttpSession) external.getSession(false);
				String token = (String) session.getAttribute("CSRF");

				// check if the token exists
				if (value == null || "".equals(value)) {
					try {
						this.antiCSRF();
					} catch (IOException e) {
						logger.error(e.toString());
					}
					Log.SetLog("", "", "antiCSRF token doesn''''t match! Failed attempt", "", "NULL"); 
					logger.info("antiCSRF token doesn''''t match! Failed attempt");
					ConfigurableNavigationHandler nav = (ConfigurableNavigationHandler) fc.getApplication().getNavigationHandler(); 
					nav.performNavigation("csrf");
				}

				// check the values for equality
				if (!value.equalsIgnoreCase(token)) {
					try {
						this.antiCSRF();
					} catch (IOException e) {
						logger.error(e.toString());
					}
					Log.SetLog("", "", "antiCSRF token doesn''''t match! Failed attempt", "", "NULL"); 
					logger.info("antiCSRF token doesn''''t match! Failed attempt");
					ConfigurableNavigationHandler nav = (ConfigurableNavigationHandler) fc.getApplication().getNavigationHandler(); 
					nav.performNavigation("UserLogin");
				}
			}

	/*
	the following function used to encode the viewstate with the html tag into a jsf component 
	*/ 

	@Override public void encodeEnd(FacesContext context) throws IOException 
	{
		//generate new token in every request
		this.generateToken();
		// get the session (don''''t create a new one!)
		HttpSession session = (HttpSession) context.getExternalContext().getSession(false);
		// get the token from the session
		String token = (String) session.getAttribute("CSRF");
		// write the component HTML to the response
		ResponseWriter responseWriter = context.getResponseWriter();
		responseWriter.startElement("input", null);
		responseWriter.writeAttribute("type", "hidden", null);
		responseWriter.writeAttribute("name", "_CSRFToken", "");
		responseWriter.writeAttribute("value", token, "CSRF");
		responseWriter.endElement("input");
	}

	*/
    
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (47,'Sandboxing',' Sandboxing


 Example:


    <iframe sandbox="value">

    /*
    sandbox=""  Applies all restrictions
    allowforms  Reenables form submission
    allowpointerlock  Reenables APIs
    allowpopups  Reenables popups
    allowsameorigin  Allows the iframe content to be treated as being from the same origin
    allowscripts  Reenables scripts
    allowtopnavigation  Allows the iframe content to navigate its toplevel browsing context
    */
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (48,'Hashing',' Hashing


 Example:


	package com.Lib;

	import java.io.UnsupportedEncodingException;
	import java.security.InvalidKeyException;
	import java.security.NoSuchAlgorithmException;
	import java.security.SecureRandom;
	import org.apache.commons.codec.binary.Base64;
	import org.apache.log4j.Logger;

	public class Hashing {

		final static Logger logger = Logger.getLogger(Hashing.class);
		
		public String createSalt(String password) throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException
		{
			/*
			For generating the random salt we want to use a secure cryptographic function
			*/
			
			SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
			//Create array for salt
			byte[] salt = new byte[128];
			//Get a random salt
			sr.nextBytes(salt);
			//return salt		
			
			/**
			* RFC 2898 password derivation compatible with .NET Rfc2898DeriveBytes class.
			*/
			Rfc2898DeriveBytes hasher = new Rfc2898DeriveBytes(password, salt, 10000);
			String bencoded = new String(Base64.encodeBase64(hasher.GetBytes(25)));
			return bencoded;	
		}
		
		//The salt in this function is the return value of the createSalt function
		public String hashPassword(String Salt, String Password)
		{
			Rfc2898DeriveBytes Hasher = null;
			try {
				Hasher = new Rfc2898DeriveBytes(Password + "ALongPepperValue",Salt.getBytes(), 10000);
			} catch (InvalidKeyException | NoSuchAlgorithmException | UnsupportedEncodingException e) {
				logger.error("error in hashing password!" + e.toString());
			}
			String bencoded = new String(Base64.encodeBase64(Hasher.GetBytes(25)));
			return bencoded;
		}

		//With this function we validate the password hash
		public boolean Validate(String passwordHash, String saltHash, String enteredPassword)
		{
			Rfc2898DeriveBytes Hasher = null;
			try {
				Hasher = new Rfc2898DeriveBytes(enteredPassword + "ALongPepperValue",saltHash.getBytes(), 10000);
			} catch (InvalidKeyException | NoSuchAlgorithmException | UnsupportedEncodingException e) 
				logger.error("Validation error in hashing password!" + e.toString());
			}
			String bencoded = new String(Base64.encodeBase64(Hasher.GetBytes(25)));
			if (bencoded.equals(passwordHash))
				return true;
			return false;
		}
	}

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (49,'HTML encoding',' HTML encoding


 Example:

				
	/*
	Whenever user input is displayed in the application all user input should be properly escaped 
	to prevent XSS injections.
	*/

	/*
	This escaping is used whenever you put the code straight into the html like:
	<span>YOUR USER INPUT</span>
	The attack bellow will now be outputted as,
	&lt;script&gt;alert(1337);&lt;/script&gt;
	*/

	import org.owasp.esapi.ESAPI;
	import org.owasp.esapi.errors.EncodingException;

	String htmlbug = ESAPI.encoder().encodeForHTML("<script>alert(1337);</script>");

	/*
	This next encoding method is used whenever you are allowing user input into 
	html attributes.
	The attack below will now be outputted as:
	onload=&amp;39;alert(1337)&amp;39;
	*/
			
	String htmlatr = ESAPI.encoder().encodeForHTMLAttribute("onload=''''alert(1337);''''");
			
	/*
	Whenever parameters are rendered via javascript your application will detect normal injections
	in the first instant. in order for the application not to be vulnerable to javascrpt encoding you MUST use the encodeForJavaScript function, any other escaping function still leaves your code vulnerable
	*/	      

	ESAPI.encoder().encodeForJavaScript("\\x3Cscript\\x3Ealert(12);\\x3C\\x2Fscript\\x3E");
			
	/*
	Whenever a user can submit an link/AHREF in your application you must solely depend upon the
	"ESAPI.encoder().encodeForURL" method since an attacker could otherwise inject the href with an XSS
	that looks like this "javacript:alert("XSS");" whenever a victim now clicks the link this XSS
	will be executed in his browser.
	*/ 

	try {
		ESAPI.encoder().encodeForURL("javascript:alert(234);");
	} catch (EncodingException e) {
		logger.error("Error encoding characters : " + e.toString() + " Time : " + LocalDateTime.now());
	}

	/*
	Security consists of different layers of protection in order to guarantee the integrity
	of your application. This means that the value displayed from the database/user should
	already be sanitized before being processed in order to prevent XSS.

	As an example, what do you do when you expect a numeric value from your application?

	you first sanitize the user input by means of an input validation method like:
	See the "input validation" class for the entire example!
	*/
	InputValidation validate = new InputValidation();
	String userinput = "when this string is evil the application will block operation!";
	if(validate.validateInput(userinput, "numeric", "Unexpected user input", "HIGH", 3)== false)
	{ /* Cancel operation of your application */ }
			
	/*
	In this example the application cancelled the request by means of simple validation.
	*/
    
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (50,'Anti clickjacking',' Anticlickjacking


 Example:


    /*
    One way to defend against clickjacking is to include a "framebreaker" script in each 
    page that should not be framed. The following methodology will prevent a webpage from 
    being framed even in legacy browsers, that do not support the XFrameOptionsHeader.

    In the document HEAD element, add the following:

    First apply an ID to the style element itself:
    */

    <style id="antiClickjack">body{display:none !important;}</style>

    //And then delete that style by its ID immediately after in the script:

    <script type="text/javascript">
    if (self === top) {
        var antiClickjack = document.getElementById("antiClickjack");
        antiClickjack.parentNode.removeChild(antiClickjack);
    } else {
        top.location = self.location;
    }
    </script>



    /*
    The second option is to use "security headers".
    There are two options for setting the "anticlickjacking" headers in your application:
    */

    //this will completely prevent your page from being displayed in an iframe.
    response.addHeader("XFrameOptions", "deny")


    //this will completely prevent your page from being displayed in an iframe on other sites.
    response.addHeader("XFrameOptions", "SAMEORIGIN")

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (51,'XMLPrevention',' XML Injection Prevention 


 Example:


	package com.edw;

	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.util.ArrayList;
	import javax.xml.parsers.DocumentBuilder;
	import javax.xml.parsers.DocumentBuilderFactory;
	import javax.xml.parsers.ParserConfigurationException;
	import javax.xml.transform.OutputKeys;
	import javax.xml.transform.Transformer;
	import javax.xml.transform.TransformerException;
	import javax.xml.transform.TransformerFactory;
	import javax.xml.transform.dom.DOMSource;
	import javax.xml.transform.stream.StreamResult;
	import com.edw.InputValidation; 

	import org.w3c.dom.Document;
	import org.w3c.dom.Element;

	public final class XMLPrevention {

		public void storeFunction(String name, String lastName, String gender)
		{
			/*
			First we import our InputValidation class. for more detailed information about 
			input validation check the code examples for "Input validation" & "Single input validation".
			*/
			InputValidation validate = new InputValidation();
			boolean  doFunction = true;
			//If the function returns false, we do not execute the function
			//see the "input validation" code example for more detailed information about this function
			if (validate.validateInput(name, "alphanumeric", "Invalid userinput name", "HIGH") == false)     { doFunction = false; }
			if (validate.validateInput(lastName, "alphanumeric", "Invalid userinput name", "HIGH") == false) { doFunction = false; }
			if (validate.validateInput(gender, "alphanumeric", "Invalid userinput name", "HIGH") == false)    { doFunction = false; }

			if (doFunction == true)
			{
				Document dom;
				Element e = null;
				String xml = null;

				// instance of a DocumentBuilderFactory
				DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
				try {
					// use factory to get an instance of document builder
					DocumentBuilder db = dbf.newDocumentBuilder();
					// create instance of DOM
					dom = db.newDocument();

					// create the root element
					Element rootEle = dom.createElement("roles");

					// create data elements and place them under root
					e = dom.createElement("name");
					e.appendChild(dom.createTextNode(name));
					rootEle.appendChild(e);

					e = dom.createElement("lastName");
					e.appendChild(dom.createTextNode(lastName));
					rootEle.appendChild(e);

					e = dom.createElement("gender");
					e.appendChild(dom.createTextNode(gender));
					rootEle.appendChild(e);

					dom.appendChild(rootEle);

					try {
						Transformer tr = TransformerFactory.newInstance().newTransformer();
						tr.setOutputProperty(OutputKeys.INDENT, "yes");
						tr.setOutputProperty(OutputKeys.METHOD, "xml");
						tr.setOutputProperty(OutputKeys.ENCODING, "UTF8");
						tr.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "roles.dtd");
						tr.setOutputProperty("{http://xml.apache.org/xslt}indentamount", "4");

						// send DOM to file
						tr.transform(new DOMSource(dom),new StreamResult(new FileOutputStream(xml)));

					} catch (TransformerException te) {
						System.out.println(te.getMessage());
					} catch (IOException ioe) {
						System.out.println(ioe.getMessage());
					}
				} catch (ParserConfigurationException pce) {
					System.out.println("UsersXML: Error trying to instantiate DocumentBuilder " + pce);
				}
			}
		}
	}

	/*
	Now we prevented malicious user input from coming into your XML file.
	NOTE: Do not forget to also properly encode your input as a last line of defense, 
	 	  also In this example the XmlReader disables external entities by default.
		  If you should choose another parser make sure your parser disables these entities 
		  in order to prevent XXE injections.
	*/

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (52,'X Path query',' XPathQuery


 Example:


	package prime.com.beans;

	import java.io.File;
	import java.io.FileInputStream;
	import java.io.IOException;
	import java.io.Serializable;
	import java.time.LocalDateTime;
	import java.util.UUID;

	import javax.faces.application.FacesMessage;
	import javax.faces.bean.ManagedBean;
	import javax.faces.bean.SessionScoped;
	import javax.faces.context.FacesContext;
	import javax.faces.event.ActionEvent;
	import javax.servlet.http.Cookie;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import javax.xml.parsers.DocumentBuilder;
	import javax.xml.parsers.DocumentBuilderFactory;
	import javax.xml.xpath.XPath;
	import javax.xml.xpath.XPathConstants;
	import javax.xml.xpath.XPathExpression;
	import javax.xml.xpath.XPathFactory;

	import org.apache.log4j.Logger;
	import org.primefaces.context.RequestContext;
	import org.w3c.dom.Document;
	import org.xml.sax.InputSource;

	import com.Lib.AuditLog;
	import com.Lib.Hashing;
	import com.Lib.InputValidation; 

	@ManagedBean
	@SessionScoped
	public class Xpath  implements Serializable {
		
		private static final long serialVersionUID = 1L;
		//First we include the audit log class.
		AuditLog Log = new AuditLog();
			
		//Second we include the password hash.
		Hashing hash = new Hashing();
		
		final static Logger logger = Logger.getLogger(Xpath.class);
		public static String AUTH_KEY = "User: ";
		private String employeeID;
		private String employeeRole;
		private String username;
		private String password; 
		private String userID_result;
		private String userID;

		public String getUserID_result() {
			return userID_result;
		}

		public void setUserID_result(String userID_result) {
			this.userID_result = userID_result;
		}

		public String getUserID() {
			return userID;
		}

		public void setUserID(String userID) {
			this.userID = userID;
		}

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}

		public String getPassword() {
			return password;
		}

		public void setPassword(String password) {
			this.password = password;
		}

		public String getEmployeeRole() {
			return employeeRole;
		}

		public void setEmployeeRole(String employeeRole) {
			this.employeeRole = employeeRole;
		}

		public String getEmployeeID() {
			return employeeID;
		}
	
		public void setEmployeeID(String employeeID) {
			this.employeeID = employeeID;
		}
		
		public void loginAction(String userId){
				
			//we include the random input validation class.
			HttpServletRequest origRequest = (HttpServletRequest)FacesContext.getCurrentInstance().getExternalContext().getRequest();
			HttpServletResponse origResponse = (HttpServletResponse)FacesContext.getCurrentInstance().getExternalContext().getResponse();
			FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(AUTH_KEY, username);
			
			String uname = this.getUsername(); 
	
			/*
			This is is to prevent session fixation, after login we create a new cookie which
			we then use to authenticate. This value can not be fixated since it is set after 
			login.

			create a new UUID and save into the session:
			*/
			UUID uuid = UUID.randomUUID();
			String randomUUIDString = uuid.toString();
			//initiate a session
			origRequest.getSession(true);
			origRequest.getSession().setAttribute("AuthToken", randomUUIDString);     	
			// now create a new cookie with this UUID value
			Cookie newCookie = new Cookie("AuthToken", randomUUIDString);   
			
			origResponse.addCookie(newCookie);
			
			//the connection has to be reported into the log files
			Log.SetLog("", "", "login was OK!", null, "SUCCESS", "NULL");    
				
			/*
			Put id in a session for query identifier based authentication
			See "identifier based authentication" code example for more information
			*/

			origRequest.getSession().setAttribute("userID", userId);
			FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(AUTH_KEY, uname);
		}
		
		//the following function used to check if the user exists 
		public String checkuser(File fXmlFile,String usrname){
			
			String type_result = null;
							
				try { 
					//The evaluate methods in the XPath and XPathExpression interfaces 
					//are used to parse an XML document with XPath expressions.					
					DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
					DocumentBuilder builder = factory.newDocumentBuilder();
					//Create an InputSource for the example XML document.
					//An InputSource is a input class for an XML entity.	        	    
					Document document = builder.parse(new InputSource(new FileInputStream(fXmlFile)));
					//The XPathFactory class is used to create an XPath object.
					//Create an XPathFactory object with the static newInstance method of the XPathFactory class.
					XPathFactory xPathfactory = XPathFactory.newInstance();
					//Create an XPath object from the XPathFactory object with the newXPath method.  
					XPath xpath = xPathfactory.newXPath();
					//Create and compile an XPath expression with the compile method of the XPath object. 
					//As an example, select the user ID attribute.
					//An attribute in an XPath expression is specified with an @ symbol. 
					//For further reference on XPath expressions, 
					//see the XPath specification for examples on creating an XPath expression.
					
					//The evaluate method of the XPathExpression interface evaluates
					//either an InputSource or a node/node list of the types org.w3c.dom.
					//Node, org.w3c.dom.NodeList, or org.w3c.dom.Document.
					//Evaluate the XPath expression with the InputSource of the example XML document to evaluate over.
	
					String type= "/Employees/Employee[UserName=''''" + usrname + "'''']/Type";
					XPathExpression salt_expr = xpath.compile(type);	              	    
					type_result = salt_expr.evaluate(document, XPathConstants.STRING).toString();  
		
					} catch (Exception e) {
						logger.error(" General error in executing xpath query :" + e.toString()); 
					}  		
				return type_result;	
		}
		
		public String xpathconnect(File fXmlFile,String usrname){
			
			String login_result = null;
							
				try { 
					//The evaluate methods in the XPath and XPathExpression interfaces 
					//are used to parse an XML document with XPath expressions.					
					DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
					DocumentBuilder builder = factory.newDocumentBuilder();
					//Create an InputSource for the example XML document.
					//An InputSource is a input class for an XML entity.	        	    
					Document document = builder.parse(new InputSource(new FileInputStream(fXmlFile)));
					//The XPathFactory class is used to create an XPath object.
					//Create an XPathFactory object with the static newInstance method of the XPathFactory class.
					XPathFactory xPathfactory = XPathFactory.newInstance();
					//Create an XPath object from the XPathFactory object with the newXPath method.  
					XPath xpath = xPathfactory.newXPath();
					//Create and compile an XPath expression with the compile method of the XPath object. 
					//As an example, select the user ID attribute.
					//An attribute in an XPath expression is specified with an @ symbol. 
					//For further reference on XPath expressions, 
					//see the XPath specification for examples on creating an XPath expression.
					
					//The evaluate method of the XPathExpression interface evaluates
					//either an InputSource or a node/node list of the types org.w3c.dom.
					//Node, org.w3c.dom.NodeList, or org.w3c.dom.Document.
					//Evaluate the XPath expression with the InputSource of the example XML document to evaluate over.	
														
					String salt= "/Employees/Employee[UserName=''''" + usrname + "'''']/salt";
					XPathExpression salt_expr = xpath.compile(salt);	              	    
					String Salt_result = salt_expr.evaluate(document, XPathConstants.STRING).toString();         	 
				
					String Password = hash.hashPassword(Salt_result, password);
					
					userID= "/Employees/Employee[UserName=''''" + username + "'''' and  Password=''''" + Password + "'''']/id";
					XPathExpression userID_expr = xpath.compile(userID);
					userID_result = userID_expr.evaluate(document, XPathConstants.STRING).toString();
					
					String login = "/Employees/Employee[UserName=''''" + username + "'''' and  Password=''''" + Password + "'''']/Type";   	    	        	    	        	 
					XPathExpression login_expr = xpath.compile(login);
					login_result = login_expr.evaluate(document, XPathConstants.STRING).toString(); 
					
				} catch (Exception e) {
					logger.error(" General error in executing xpath query :" + e.toString());
				}  
			return login_result;	
		}

		public void xpathLogin(ActionEvent event) throws IOException 
		{
			/*
			In order to prevent xpath injections we have to treat these query''''s similar as 
			to the SQL query''''s. An option would be to use a precompiled XPath query.
			But since this is a third party library i consider it untrusted and would
			rather use our own crafted escaping function.

			NOTE: if you want to look into the precompiled xpath library you can find more
			detailed information about it on: http://www.onjava.com/pub/a/onjava/2005/01/12/xpath.html
			*/

			/*
			As with every injection prevention we first focus on the expected user values
			in this case we expect an integer we use our single input validation method for integers
			See the "input validation" code example for more detailed information.

			For the purpose of this example we use the following XML snippet 
			
			<?xml version="1.0" encoding="utf8"?>
					<Employees>
					<Employee ID="1">
						<FirstName>Arnold</FirstName>
						<LastName>Baker</LastName>
						<UserName>ABaker</UserName>
						<id>1</id>
						<Password>Hv3KPG906xBBhE1z3k5QRD9SArIYLeiSFA==</Password>  <! SoSecure >
						<salt>+yoY1sPd+V6SC+0aEiA9lHjV9EC8zOCw+A==</salt>
						<Type>Admin</Type>
					</Employee>
					<Employee ID="2">
						<FirstName>Peter</FirstName>
						<LastName>Pan</LastName>
						<UserName>PPan</UserName>
						<id>2</id>
						<Password>Cftv1ip25PJdmf8DdfU5NM/K/cjEqEAthw==</Password>  <! NoTelling >
						<salt>/KAMdM09RVNZ8nOWHAsqKzrfyY6VEZgRQA==</salt>
						<Type>User</Type>
					</Employee>
					</Employees>
							
							
			How to exploit : 
			
			With a normal username and password this XPath would work, but an attacker may send a bad username and password and get an XML node selected without knowing the username or password, like this:
			
			Username: blah'''' or 1=1 or ''''a''''=''''a
			Password: blah

			or if the following exploit used, it matches the first letter of the username which is A. In such case it just ignores the password and permits login. 
			
			username : '''' or substring((//Employee[position()=1]/child::node()[position()=2]),1,1)="A" or ''''''''=''''
			password : blah
			
			another exploitation example is using the following query which will be true if the second string (password) of the first node (user ''''Arnold'''') 
			consists of 36 characters (hash).
			
			stringlength(//user[position()=1]/child::node()[position()=2])=36 or ''''''''=''''
			
			in order to test any of the above exploit cases just comment out the input validation lines 207 and 210 below.
			
			*/
			RequestContext context = RequestContext.getCurrentInstance();
			FacesMessage message = null;
			boolean loggedIn = false;
			boolean continueFunction = true;         
			InputValidation validate = new InputValidation();
	
			//Here we put the variable in our input validation method in order to prevent untrusted user input from parsing
			//NOTE: logging and countering is also done in your validation method
			
			//Input used into an XPATH expression must not contains any of the characters below:

			//	 ( ) = '''' [ ] : , * / WHITESPACE
			
			//Another method of avoiding XPath injections is by using variable into XPATH expression with a variable resolver enabled evaluator. 
			//See XPath parameterization example
			
			if (validate.validateInput(username,username,"symbols", "xpath input validation for username", "HIGH") == false) 
			{ continueFunction = false; }
			
			if (validate.validateInput(username,password,"symbols", "xpath input validation for password", "HIGH") == false) 
			{ continueFunction = false; }
		
			//Only if our validation function returned true we put the user input in the function
			//fXmlFile is the java.io.File object of the example XML document.
			
			File fXmlFile = new File("C:\\xmldb\\users.xml");
			
			if (continueFunction == true)
			{     	     	 
				String login_result = this.xpathconnect(fXmlFile,username);
				if (login_result.equals(""))
				{
					//the connection has to be reported into the log files
					Log.SetLog(username, "", "Login failed!", LocalDateTime.now(), "FAIL", "NULL");
					message = new FacesMessage(FacesMessage.SEVERITY_WARN, "Logging Error", "Invalid credentials"); 
					FacesContext.getCurrentInstance().getExternalContext().redirect("xpath.xhtml");
				}
				else if (login_result.equals("Admin"))
				{
					this.loginAction(userID_result);
					//the connection has to be reported into the log files
					Log.SetLog(username, "", "Login successfully!", LocalDateTime.now(), "SUCCESS", "");
					loggedIn = true;
					message = new FacesMessage(FacesMessage.SEVERITY_INFO, "Welcome", username);
					FacesContext.getCurrentInstance().getExternalContext().redirect("admin_page.xhtml");
				}
				else if (login_result.equals("User"))
				{
					this.loginAction(userID_result);
					Log.SetLog(username, "", "Login successfully!", LocalDateTime.now(), "SUCCESS", "");
					loggedIn = true;
					message = new FacesMessage(FacesMessage.SEVERITY_INFO, "Welcome", username);
					FacesContext.getCurrentInstance().getExternalContext().redirect("user_page.xhtml");
				}	
				FacesContext.getCurrentInstance().addMessage(null, message);
				context.addCallbackParam("loggedIn", loggedIn);
			}         
		}
	}

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (53,'Encoder SQL ESAPI',' Encoder (SQL  ESAPI)


 Example:


	package com.edw;

	import java.time.LocalDateTime;
	import java.util.regex.Matcher;
	import java.util.regex.Pattern;
	import org.owasp.esapi.ESAPI;
	import org.owasp.esapi.codecs.MySQLCodec;

	public final class Encoding {
		
		AuditLog Log = new AuditLog(); 
		
		public String encoder(String input , String allowed, String user_id)
		{	
		    /*
			We can specify also special characters which allowed in order to keep
			track of any unwanted special characters
			
			Example :
			
			To keep malicious inputs contained, any inputs written to the database need to be encoded.
			SQL encoding: '''' OR 1=1 '''' is encoded to \'''' OR 1\=1 \\\''''
			
			*/
			String pattern = "^[azAZ09" + allowed + "]+$";
			// Create a Pattern object
			Pattern reg = Pattern.compile(pattern);
			// Now create matcher object.
			Matcher match = reg.matcher(input);
			if (!match.find()) {	
			    Log.SetLog(user_id, "Illegal characters", "FAIL", LocalDateTime.now(),  "HIGH");
			}		
			//We return the user input encoded	      
			return ESAPI.encoder().encodeForSQL(new MySQLCodec(MySQLCodec.MYSQL_MODE), input);
		}
	}
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (54,'Single input validation control',' Single input validation control 


 Example:


	import java.time.LocalDateTime;
	import java.util.regex.Matcher;
	import java.util.regex.Pattern;

	public final class InputValidation {
		
		private AuditLog Log = new AuditLog(); 
		private String validate = "pass"; 
		
		public String validateInput(String user_id,String input, String type, String logMessage, String remote_address, String threatLevel)
		{
			/*
			we want to filter the filenames for expected values. For this example we use only az/09
			Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.           
			*/
			String validator = "";
			if(type.equals("symbols"))
			{
				//Characters that may be used to interfere with the XPath query should be blocked, including ( ) = ‘ [ ] : , * / and all whitespace. 
				// Any input that does not match the white list should be rejected, not sanitized.
				
				validator = "(.*)(\\W+)(\\D+)(\\s+)(.*)";
			}
			else if (type.equals("alphanumeric"))		 
					validator = "^[azAZ09]";
			else if (type.equals("numeric"))
				//"^[09]*$";
				validator = "(\\d+)";
			else
				validator = "";

			// Create a Pattern object
			Pattern reg = Pattern.compile(validator);
			// Now create matcher object.
			Matcher match = reg.matcher(input);
			if (!match.find()) 
			{	
				//If there was a match this function returns "pass"
				validate = "validation failed"; 
			
				//this breach has to be reported into the log files
				Log.SetLog(user_id, logMessage , "FAIL", LocalDateTime.now(), remote_address, rLevel);
				
				/*
				Set counter; if counter hits 3, the user''''s session must be terminated.
				After 3 hits the user''''s account must be blocked.
				For detailed information see the "Audit logs" in code examples.
				*/
				
				String result = Log.counter(1,Integer.parseInt(user_id));
				
				if (result.equals("SQL insert query error in update access" ))
				{
					Log.SetLog(user_id, logMessage , "SQL insert query error in update access", LocalDateTime.now(),remote_address,  "");
				}
				if (result.equals("block"))
				{
					Log.SetLog(user_id, logMessage , "block", LocalDateTime.now(), remote_address,  "HIGH");
					validate = "block";
				}
				if (result.equals("terminate"))
				{
					Log.SetLog(user_id, logMessage , "terminate", LocalDateTime.now(), remote_address,  "HIGH");
					validate = "terminate";
				}
				else if (validate.equals("validation failed"))
				{
					Log.SetLog(user_id, logMessage , "validation failed", LocalDateTime.now(), remote_address,  "HIGH");
				}
			}		
			return validate;
		}	 
		
		public boolean validateInput(String username, String input, String type, String logMessage, String threatLevel)
		{
			/*
			we want to filter the filenames for expected values. For this example we use only az/09
			Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.           
			*/
			String validator = "";
			
			if(type.equals("symbols"))
			{
				//Characters that may be used to interfere with the XPath query should be blocked, including ( ) = ‘ [ ] : , * / and all whitespace. 
				// Any input that does not match the white list should be rejected, not sanitized.
				//validator = "^()=''''\\[\\]:,\\*/ $";
				validator = "(.*)(\\W+)(\\D+)(\\s+)(.*)";
				
			}
			else if (type.equals("alphanumeric"))		  
			validator = "^[azAZ09]";
			else if (type.equals("numeric"))
				//"^[09]*$";
				validator = "(\\d+)";
			else
				validator = "";

			// Create a Pattern object
			Pattern reg = Pattern.compile(validator);
			boolean validate = false ; 
			// Now create matcher object.
			Matcher match = reg.matcher(input);
			if (!match.find()) 
			{	
				//If there was a match this function returns false
				validate = true; 
			
				//this breach has to be reported into the log files
				Log.SetLog(username, logMessage , "SUCCESS", LocalDateTime.now(),  threatLevel);   
			}else{
					Log.SetLog(username, logMessage , "FAIL", LocalDateTime.now(), "NULL");
			}        
			return validate;
		}	 
	}

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (55,'Anti caching headers',' Anticashing headers 


 Example:


    /*
    Add the following headers to your application head in order to prevent the browser from caching
    the following code could be used in your controller:
    */

    response.appendHeader("CacheControl", "nocache, nostore, mustrevalidate"); // HTTP 1.1.
    response.appendHeader("Pragma", "nocache"); // HTTP 1.0.
    response.appendHeader("Expires", "0"); // Proxies.
    
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (56,'WinRegistry',' Reading from Windows Registry 


 Example:


    package com.edw;

    import java.lang.reflect.InvocationTargetException;
    import java.lang.reflect.Method;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.prefs.Preferences;

    public final class WinRegistry {

      public static final int HKEY_CURRENT_USER = 0x80000001;
      public static final int HKEY_LOCAL_MACHINE = 0x80000002;
      public static final int HKEY_CLASSES_ROOT = 0x80000003;  
      public static final int REG_SUCCESS = 0;
      public static final int REG_NOTFOUND = 2;
      public static final int REG_ACCESSDENIED = 5;

      private static final int KEY_ALL_ACCESS = 0xf003f;
      private static final int KEY_READ = 0x20019;
      private static final Preferences userRoot = Preferences.userRoot();
      private static final Preferences systemRoot = Preferences.systemRoot();
      private static final Class<? extends Preferences> userClass = userRoot.getClass();
      private static final Method regOpenKey;
      private static final Method regCloseKey;
      private static final Method regQueryValueEx;
      private static final Method regEnumValue;
      private static final Method regQueryInfoKey;
      private static final Method regEnumKeyEx;
      private static final Method regCreateKeyEx;
      private static final Method regSetValueEx;
      private static final Method regDeleteKey;
      private static final Method regDeleteValue;

      static {
          try {
              regOpenKey = userClass.getDeclaredMethod("WindowsRegOpenKey",
                  new Class[] { int.class, byte[].class, int.class });
              regOpenKey.setAccessible(true);
              regCloseKey = userClass.getDeclaredMethod("WindowsRegCloseKey",
                  new Class[] { int.class });
              regCloseKey.setAccessible(true);
              regQueryValueEx = userClass.getDeclaredMethod("WindowsRegQueryValueEx",
                  new Class[] { int.class, byte[].class });
              regQueryValueEx.setAccessible(true);
              regEnumValue = userClass.getDeclaredMethod("WindowsRegEnumValue",
                  new Class[] { int.class, int.class, int.class });
              regEnumValue.setAccessible(true);
              regQueryInfoKey = userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",
                  new Class[] { int.class });
              regQueryInfoKey.setAccessible(true);
              regEnumKeyEx = userClass.getDeclaredMethod(  
                  "WindowsRegEnumKeyEx", new Class[] { int.class, int.class, int.class });  
              regEnumKeyEx.setAccessible(true);
              regCreateKeyEx = userClass.getDeclaredMethod(  
                  "WindowsRegCreateKeyEx", new Class[] { int.class, byte[].class });  
              regCreateKeyEx.setAccessible(true);  
              regSetValueEx = userClass.getDeclaredMethod(  
                  "WindowsRegSetValueEx", new Class[] { int.class, byte[].class, byte[].class });  
              regSetValueEx.setAccessible(true); 
              regDeleteValue = userClass.getDeclaredMethod(  
                  "WindowsRegDeleteValue", new Class[] { int.class, byte[].class });  
              regDeleteValue.setAccessible(true); 
              regDeleteKey = userClass.getDeclaredMethod(  
                  "WindowsRegDeleteKey", new Class[] { int.class, byte[].class });  
              regDeleteKey.setAccessible(true); 
          }
          catch (Exception e) {
              throw new RuntimeException(e);
          }
      }

      private WinRegistry() {  }

      /**
      * Read a value from key and value name
      * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
      * @param key
      * @param valueName
      * @return the value
      * @throws IllegalArgumentException
      * @throws IllegalAccessException
      * @throws InvocationTargetException
      */
      public static String readString(int hkey, String key, String valueName) 
          throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          if (hkey == HKEY_LOCAL_MACHINE) 
          {
              return readString(systemRoot, hkey, key, valueName);
          }
          else if (hkey == HKEY_CURRENT_USER) 
          {
              return readString(userRoot, hkey, key, valueName);
          }
          else if (hkey == HKEY_CLASSES_ROOT) 
          {
              return readString(userRoot, hkey, key, valueName);
          }else{
              throw new IllegalArgumentException("hkey=" + hkey);
          }
      }

      /**
      * Read value(s) and value name(s) form given key 
      * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
      * @param key
      * @return the value name(s) plus the value(s)
      * @throws IllegalArgumentException
      * @throws IllegalAccessException
      * @throws InvocationTargetException
      */
      public static Map<String, String> readStringValues(int hkey, String key) 
        throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          if (hkey == HKEY_LOCAL_MACHINE) 
          {
              return readStringValues(systemRoot, hkey, key);
          }
          else if (hkey == HKEY_CURRENT_USER) 
          {
              return readStringValues(userRoot, hkey, key);
          }
          else if (hkey == HKEY_CLASSES_ROOT) 
          {
              return readStringValues(userRoot, hkey, key);
          }else{
              throw new IllegalArgumentException("hkey=" + hkey);
          }
      }

      /**
      * Read the value name(s) from a given key
      * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE/HKEY_CLASSES_ROOT
      * @param key
      * @return the value name(s)
      * @throws IllegalArgumentException
      * @throws IllegalAccessException
      * @throws InvocationTargetException
      */
      public static List<String> readStringSubKeys(int hkey, String key) 
          throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          if (hkey == HKEY_LOCAL_MACHINE) 
          {
              return readStringSubKeys(systemRoot, hkey, key);
          }
          else if (hkey == HKEY_CURRENT_USER) 
          {
              return readStringSubKeys(userRoot, hkey, key);
          }
          else if (hkey == HKEY_CLASSES_ROOT) 
          {
              return readStringSubKeys(userRoot, hkey, key);
          }else{
              throw new IllegalArgumentException("hkey=" + hkey);
          }
      }

      /**
      * Create a key
      * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
      * @param key
      * @throws IllegalArgumentException
      * @throws IllegalAccessException
      * @throws InvocationTargetException
      */
      public static void createKey(int hkey, String key) 
        throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          int [] ret;
          if (hkey == HKEY_LOCAL_MACHINE) 
          {
              ret = createKey(systemRoot, hkey, key);
              regCloseKey.invoke(systemRoot, new Object[] { new Integer(ret[0]) });
          }
          else if (hkey == HKEY_CURRENT_USER) 
          {
              ret = createKey(userRoot, hkey, key);
              regCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) });
          }
          else if (hkey == HKEY_CLASSES_ROOT) 
          {
              ret = createKey(userRoot, hkey, key);
              regCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) });
          }else{
              throw new IllegalArgumentException("hkey=" + hkey);
          }
          if (ret[1] != REG_SUCCESS) 
          {
              throw new IllegalArgumentException("rc=" + ret[1] + "  key=" + key);
          }
      }

      /**
      * Write a value in a given key/value name
      * @param hkey
      * @param key
      * @param valueName
      * @param value
      * @throws IllegalArgumentException
      * @throws IllegalAccessException
      * @throws InvocationTargetException
      */
      public static void writeStringValue
        (int hkey, String key, String valueName, String value) 
          throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          if (hkey == HKEY_LOCAL_MACHINE) 
          {
               writeStringValue(systemRoot, hkey, key, valueName, value);
          }
          else if (hkey == HKEY_CURRENT_USER) 
          {
               writeStringValue(userRoot, hkey, key, valueName, value);
          }
          else if (hkey == HKEY_CLASSES_ROOT) 
          {
                writeStringValue(userRoot, hkey, key, valueName, value);
          }else{
                throw new IllegalArgumentException("hkey=" + hkey);
          }
      }

      /**
      * Delete a given key
      * @param hkey
      * @param key
      * @throws IllegalArgumentException
      * @throws IllegalAccessException
      * @throws InvocationTargetException
      */
      public static void deleteKey(int hkey, String key) 
        throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          int rc = 1;
          if (hkey == HKEY_LOCAL_MACHINE) 
          {
              rc = deleteKey(systemRoot, hkey, key);
          }
          else if (hkey == HKEY_CURRENT_USER) 
          {
              rc = deleteKey(userRoot, hkey, key);
          }
          else if (hkey == HKEY_CLASSES_ROOT) 
          {
              rc = deleteKey(userRoot, hkey, key);
          }
          if (rc != REG_SUCCESS) 
          {
              throw new IllegalArgumentException("rc=" + rc + "  key=" + key);
          }
      }

      /**
      * delete a value from a given key/value name
      * @param hkey
      * @param key
      * @param value
      * @throws IllegalArgumentException
      * @throws IllegalAccessException
      * @throws InvocationTargetException
      */
      public static void deleteValue(int hkey, String key, String value) 
        throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          int rc = 1;
          if (hkey == HKEY_LOCAL_MACHINE) 
          {
              rc = deleteValue(systemRoot, hkey, key, value);
          }
          else if (hkey == HKEY_CURRENT_USER) 
          {
              rc = deleteValue(userRoot, hkey, key, value);
          }
          else if (hkey == HKEY_CLASSES_ROOT) 
          {
              rc = deleteValue(userRoot, hkey, key, value);
          }
          if (rc != REG_SUCCESS) 
          {
              throw new IllegalArgumentException("rc=" + rc + "  key=" + key + "  value=" + value);
          }
      }

      private static int deleteValue
        (Preferences root, int hkey, String key, String value)
          throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {
              new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });
          if (handles[1] != REG_SUCCESS) 
          {
              return handles[1];  // can be REG_NOTFOUND, REG_ACCESSDENIED
          }
          int rc =((Integer) regDeleteValue.invoke(root,  
              new Object[] { 
                  new Integer(handles[0]), toCstr(value) 
              })).intValue();
          regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });
          return rc;
      }

      private static int deleteKey(Preferences root, int hkey, String key) 
          throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          int rc =((Integer) regDeleteKey.invoke(root,  
              new Object[] { new Integer(hkey), toCstr(key) })).intValue();
          return rc;  // can REG_NOTFOUND, REG_ACCESSDENIED, REG_SUCCESS
      }

      private static String readString(Preferences root, int hkey, String key, String value)
          throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {
              new Integer(hkey), toCstr(key), new Integer(KEY_READ) });
          if (handles[1] != REG_SUCCESS) 
          {
              return null; 
          }
          byte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[] {
              new Integer(handles[0]), toCstr(value) });
          regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });
          return (valb != null ? new String(valb).trim() : null);
      }

      private static Map<String,String> readStringValues
        (Preferences root, int hkey, String key)
        throws IllegalArgumentException, IllegalAccessException,
        InvocationTargetException 
      {
        HashMap<String, String> results = new HashMap<String,String>();
        int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {
            new Integer(hkey), toCstr(key), new Integer(KEY_READ) });
        if (handles[1] != REG_SUCCESS) 
        {
            return null;
        }
        int[] info = (int[]) regQueryInfoKey.invoke(root,
            new Object[] { new Integer(handles[0]) });

        int count = info[0]; // count  
        int maxlen = info[3]; // value length max
        for(int index=0; index<count; index++)  {
            byte[] name = (byte[]) regEnumValue.invoke(root, new Object[] {
                new Integer
                (handles[0]), new Integer(index), new Integer(maxlen + 1)});
            String value = readString(hkey, key, new String(name));
            results.put(new String(name).trim(), value);
        }
        regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });
        return results;
      }

      private static List<String> readStringSubKeys
        (Preferences root, int hkey, String key)
        throws IllegalArgumentException, IllegalAccessException,
        InvocationTargetException 
      {
          List<String> results = new ArrayList<String>();
          int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {
              new Integer(hkey), toCstr(key), new Integer(KEY_READ) 
          });
          if (handles[1] != REG_SUCCESS) 
          {
              return null;
          }
          int[] info = (int[]) regQueryInfoKey.invoke(root,
              new Object[] { new Integer(handles[0]) });

          int count  = info[0]; // Fix: info[2] was being used here with wrong results. Suggested by davenpcj, confirmed by Petrucio
          int maxlen = info[3]; // value length max
          for(int index=0; index<count; index++)  {
              byte[] name = (byte[]) regEnumKeyEx.invoke(root, new Object[] {
                  new Integer
                    (handles[0]), new Integer(index), new Integer(maxlen + 1)
              });
              results.add(new String(name).trim());
          }
          regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });
          return results;
      }

      private static int [] createKey(Preferences root, int hkey, String key)
        throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          return  (int[]) regCreateKeyEx.invoke(root,
              new Object[] { new Integer(hkey), toCstr(key) });
      }

      private static void writeStringValue 
        (Preferences root, int hkey, String key, String valueName, String value) 
          throws IllegalArgumentException, IllegalAccessException, InvocationTargetException 
      {
          int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {
              new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });

          regSetValueEx.invoke(root,  
              new Object[] { 
                  new Integer(handles[0]), toCstr(valueName), toCstr(value) 
              }); 
          regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });
      }

      // utility
      private static byte[] toCstr(String str) {
          byte[] result = new byte[str.length() + 1];
          for (int i = 0; i < str.length(); i++) {
              result[i] = (byte) str.charAt(i);
          }
          result[str.length()] = 0;
          return result;
      }
    }
    
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (57,'Secure Database Configuration',' Secure Database Configuration


 Example:

    
    // in order for the connection to be secure, it is best practice the credentials and all the relevant sensitive information about the database to be kept at the server configuration files. For this reason the following changes have been made at tomcat''''s server.xml configuration file. 

    <Resource auth="Container" driverClassName="com.mysql.cj.jdbc.Driver" maxActive="100" maxIdle="30" maxWait="10000" name="jdbc/myJdbc" password="javadude" type="javax.sql.DataSource" url="jdbc:mysql://localhost:3306/aggregate_control" username="user"/>

    <Resource auth="Container" driverClassName="com.mysql.cj.jdbc.Driver" maxActive="100" maxIdle="30" maxWait="10000" name="jdbc/auditlogs_Jdbc" password="javadude" type="javax.sql.DataSource" url="jdbc:mysql://localhost:3306/auditlogs" username="user"/>

    the above configuration example indicates that there are two different mysql connections to the database. One refers to the auditlog database and the other refers to the aggregate_control database using the jdbc mysql connector. As you can see the mysql username and password are residing in the web application server configuration file.

    As for the server side code, in order to be informed of the existence of the databases, the following code must be located in the file /METAINF/context.xml

    <?xml version="1.0" encoding="UTF8"?>

    <Context path="/JServletSide" docBase="/JServletSide"
      crossContext="true" reloadable="true" debug="1">


    <Resource name="jdbc/myJdbc" auth="Container" type="javax.sql.DataSource"
              maxActive="100" maxIdle="30" maxWait="10000"
              username="user" password="javadude" 
              driverClassName="com.mysql.cj.jdbc.Driver"
              url="jdbc:mysql://localhost:3306/aggregate_control"/>

    <Resource name="jdbc/auditlogs_Jdbc" auth="Container" type="javax.sql.DataSource"
              maxActive="100" maxIdle="30" maxWait="10000"
              username="user" password="javadude" 
              driverClassName="com.mysql.cj.jdbc.Driver"
              url="jdbc:mysql://localhost:3306/auditlogs"/>
              </Context>

    The above snippet indicates the database  resource that will be use in the servlet in order to perform a successful connection to the database

    Afterwards the following servlet snippet will be used for the database connection. 

    Context initContext = new InitialContext();
    Context webContext  = (Context)initContext.lookup("java:/comp/env");
    DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
    Connection conn = ds.getConnection();

    the init context line refers to the database resource inside the context.xml file

    Also in order for the application to map the database reference we have to include the following lines inside the /WEBINF/web.xml 
    
    <resourceref>
        <description>DB Connection</description>
        <resrefname>jdbc/myJdbc</resrefname>
        <restype>javax.sql.DataSource</restype>
        <resauth>Container</resauth>
      </resourceref>
      <resourceref>
        <description>DB Connection</description>
        <resrefname>jdbc/auditlogs_Jdbc</resrefname>
        <restype>javax.sql.DataSource</restype>
        <resauth>Container</resauth>
      </resourceref>

      ','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (58,'Crossdomain XML',' Crossdomain XML


 Example:


    A bad example of a crossdomain.xml would be:

    <?xml version="1.0" ?>
    <crossdomainpolicy>
      <sitecontrol permittedcrossdomainpolicies="masteronly"/>
      <allowaccessfrom domain="*"/>
      <allowhttprequestheadersfrom domain="*" headers="*"/>
    </crossdomainpolicy>

    Because it allows access from all other domains.

    Instead of this approach you might want to use the following restrictions. 
    Example by twitter''''s crossdomain.xml:

    <?xml version="1.0" encoding="UTF8"?>
    <crossdomainpolicy xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance" 
    xsi:noNamespaceSchemaLocation="http://www.adobe.com/xml/schemas/PolicyFile.xsd">
      <allowaccessfrom domain="twitter.com" />
        <allowaccessfrom domain="api.twitter.com" />
        <allowaccessfrom domain="search.twitter.com" />
        <allowaccessfrom domain="static.twitter.com" />
        <sitecontrol permittedcrossdomainpolicies="masteronly"/>
      <allowhttprequestheadersfrom domain="*.twitter.com" headers="*" secure="true"/>
    </crossdomainpolicy>
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (59,'CSRF Token',' CSRF Token 


 Example:


	/*
	For CSRF tokens we used a separate class outside of the normal controller, since
	it must be reused on several locations throughout the application

	First after a successful validation of a user login, the application must also start a session
	which contains the "cross site request forgery" token.
	*/

	//For generating the token we want to use a secure cryptographic function
	SecureRandom random = new SecureRandom();

	//Then we generate a long value token containing a high entropy
	byte[] randomBytes  = new byte[128];

	random.nextBytes(randomBytes);

	//Then we base64 encode the string
	String csrftoken = Base64.getEncoder().encodeToString(randomBytes);

	HttpSession session 
	session.setAttribute( "CSRF", csrftoken);

	/*
	The next step is implementing this random token in each form field as a hidden input parameter
	and send it to a function which checks if the submitted token is equal to the one set after successful validation.
	*/

	<%
		Object token = request.getSession().getAttribute("CSRF");
		String tokenStr = "";
		if (token != null)
		{
			tokenStr = (String) token;
		}		 
	%>

	<html>
	<head>
	<meta httpequiv="ContentType" content="text/html; charset=ISO88591">
	<title>Insert title here</title>
	</head>
	<body>
		Welcome to the OWASP CSRFGuard Test Application! Where would you like to go?
	<br/>

	<form action="/Home/csrf" method="post">
		<input type="text" name="testValue" /> 
		<br/> 
		<input type="hidden" value="<%=tokenStr%>" name="token"/>
		<input type="submit" value="login">
	</form>

	*/

	package com.edw;
	import java.io.IOException;
	import javax.servlet.RequestDispatcher;
	import javax.servlet.ServletException;
	import javax.servlet.annotation.WebServlet;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;

	@WebServlet("/CheckCSRF")

	public final class CheckCSRF extends HttpServlet
	{

		private static final long serialVersionUID = 1L;

		public CheckCSRF() {
			super();
		}

		//here we are sending the token towards the function which does the token validation    
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

			String token = request.getParameter("token");
			String sessionToken = (String) request.getSession().getAttribute("CSRF")

			if(!sessionToken.equals(token))
			{ 

				/*
				If there was no match, the authentication session will be emptied and sessions will be abandoned. Then, the user must be redirected towards the login page.
				*/		
				if ("".equalsIgnoreCase(request.getSession().getAttribute("authenticateUser")))
				{
					request.getSession().invalidate();
					request.setAttribute("msg", "Served at: " + request.getContextPath());
					RequestDispatcher rd =  request.getRequestDispatcher("/login");
					rd.forward(request, response);
					return;
				}
			}	
		}

		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			super.doGet(request, response);
		}
    }

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (60,'Aggregate user contol',' Aggregate User Control 


 Example:


	/*
	In order to enforce Aggregate access control protection the best method would be to 
	define your rules by means of a database structure rather than sessions or logs.

	Verify the system can protect against aggregate or continuous access of secured functions, 
	resources, or data. For example, consider the use of a resource governor to limit the number 
	of edits per hour or to prevent the entire database from being scraped by an individual user.

	TABLE users
	   
	| userID | userName | password | privilegeID |    access    |     aggregate	    |
	  
	|   1    | Admin    | Csdar323 |      1      |     TRUE     |       2322        |
	   
	|   2    | User     | Adf4fsv  |      2      |     FALSE    |         0         |
	  
	|   3    | Guest    | dff4fKr  |      3      |     TRUE     |        125        |   
	

	TABLE privileges
	   
	| privilegeID | privilege        | 
	
	|     1       | edit:read:delete |
	
	|     2       | edit:read        |
	
	|     3       | read             |
	

	The following code snippets can be used in relation with this class in order to have a full implemented example 
	*/

	// HTML/JSP page index.jsp

	<%@page contentType="text/html" pageEncoding="UTF8"%>

	<!DOCTYPE html>
	<html>
		<head>
			<meta httpequiv="ContentType" content="text/html; charset=UTF8">
			<title>Insert Value</title>
		</head>
		<body>
			<form method="post" action="aggregateControl">
			<table>
				<tr>
					<td>Name  : </td>
					<td><input type="text" id="name" name="name" /></td>
				</tr>  
				<tr>
					<td>Surname : </td>
					<td><input type="text" id="surname" name="surname" /></td>
				</tr>
				<tr>
					<td>Password : </td>
					<td><input type="text" id="password" name="password" /></td>
				</tr>               
				<tr>
					<td><input type="hidden" id="userID" value="2" name="userID" /></td>
				</tr>         
				<tr>
					<td colspan="2"><input type="submit" /></td>               
				</tr>
				</table>
			</form>     
		</body>
	</html>


	// Servlet 

	//The following code snippet can be used in relation with the following servlet snippet


	public final class AggregateControl extends HttpServlet{
		private static final long serialVersionUID = 1L;
		public aggregateControl() {
			super();
		}
		
		final static Logger logger = Logger.getLogger(AggregateControl.class);
		private String userName;
		private String password;
		private String userID;

		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 
		{	
			userName = request.getParameter("name");
			userID = request.getParameter("userID");
			Aggregate ag = new Aggregate();
			ag.setUserName(userName);
			ag.setUserID(userID);
			boolean invalidate_sessions = ag.aggregateControl(0);
			
			if (invalidate_sessions == true)
			{
				request.getSession().invalidate();			
			}
			
			doGet(request, response);
		}

	/*		
	Output logs indicating that user has been logged out after many database connections  

	[ .... ] 

	20161124 11:17:55 INFO  Aggregate:277  Connection to the database was made successfully   User: ddd  User ID:  2 Time: 20170705T12:19:20.803
	20161124 11:18:07 INFO  Aggregate:277  Connection to the database was made successfully   User: ddd  User ID:  2 Time: 20170705T12:36:09.763
	20161124 11:18:15 INFO  Aggregate:277  Connection to the database was made successfully   User: ddd  User ID:  2 Time: 20170705T12:36:52.443
	20161124 11:18:23 INFO  Aggregate:277  Connection to the database was made successfully   User: ddd  User ID:  2 Time: 20170705T12:37:28.358
	20161124 11:18:32 INFO  Aggregate:277  Connection to the database was made successfully   User: ddd  User ID:  2 Time: 20170705T12:38:03.250
	20161124 11:18:39 INFO  Aggregate:277  Connection to the database was made successfully   User: ddd  User ID:  2 Time: 20170705T12:38:36.413
	20161124 11:18:49 INFO  Aggregate:240   User account was locked out due to aggregate user control system  User: ddd  Userid ID:  2
	20161124 11:18:49 INFO  Aggregate:277  Connection to the database was made successfully   User: ddd  User ID:  2

	[ ..... ]

	The following example gives another implementation of Aggregate class
	*/

	package com.edw;

	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	package prime.com.beans;

	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.time.LocalDateTime;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	public final class Aggregate {

		private String userName;
		private String password;
		private String userID;
		private int control = 0;		
		
		final static Logger logger = Logger.getLogger(Aggregate.class);

		public boolean aggregateControl(int count, String userName, String userID)
		{		
			boolean invalidate_sessions = false; 
				
			//Here we connect to the database by means of a connection string as configured in the web.xml and /METAINF/context.xml 
			Connection conn = null;
			try {
						
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();	

				//Here we select the number of counts from aggregate column in order to verify the number of connections:
				String query = "SELECT aggregate from users WHERE userID = ?";
			
				PreparedStatement st = conn.prepareStatement(query);
				st.setString(1, userID);
				
				// execute the query, and get a java result set
				//We bind the parameter in order to prevent SQL injections

				ResultSet rs = st.executeQuery();
				
				while (rs.next())
				{
					control  = rs.getInt("aggregate");
					userName  = rs.getString("userName");
				}

				//We update the aggregate table in the database in order to 
				//keep track of the number of connections the user made
				count = control + 1;
				
				// create the java mysql update prepared statement
				String query2 = "UPDATE users SET aggregate = ? WHERE userID = ?";
				PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
				preparedStmt2.setInt(1, count);
				preparedStmt2.setString(2, userID);

				// execute the java prepared statement
				preparedStmt2.executeUpdate();
				
				/*
				Every time the user accesses the database we keep track of the number of times he
				connected. Whenever the user passes a reasonable number he should be rejected 
				since he could be an attacker scraping your table contents and stealing company information
				You could a CRON job or stored procedure in your system in order to 
				clean the Aggregate column within certain time frames
				*/
				
				if ( control > 5000)
				{		
					//this breach has to be reported into the log files
					logger.info( " User account was locked out due to aggregate user control system" + "  User: " + userName + "  User ID:  " +  userID + "Time: " + LocalDateTime.now());

					/*
					Whenever the reasonable number of connections the user made was surpassed we destroy all the 
					sessions to deny the user any further access to the system. This session invalidation is controlled from the SERVLET 
					
					*/
					invalidate_sessions = true; 
					
					/*
					Than we set his access level on his account to FALSE in order to prevent 
					him from logging in again till you did your Forensics on the log files
					*/
					
					// create the java MySql update prepared statement
		
					int access = 0; //0 is considered as FALSE in MySQL
					String query3 = "UPDATE users SET access = ? WHERE userID = ?";
					PreparedStatement preparedStmt3 = conn.prepareStatement(query3);
					preparedStmt3.setInt(1, access);
					preparedStmt3.setString(2, userID);

					// execute the java prepared statement
					preparedStmt3.executeUpdate();
					preparedStmt3.close();
						
				}
				st.close();
				preparedStmt2.close();
				conn.close();

			} catch (SQLException | NamingException e) {
					logger.error("cannot update database. check query" + e.toString() );
			}	      
				
			//the connection has to be reported into the log files
			if(logger.isInfoEnabled()){
				logger.info("Connection to the database was made successfully " + "  User: " + userName + "  User ID:  " +  userID + "Time: " + LocalDateTime.now() );
			}else{
				logger.error("Couldnt connect to database  " +  "  User: " + userName + "  User ID:  " +  userID + "Time: " + LocalDateTime.now());
			}
			
		return invalidate_sessions;
		}

		public String getUserName() {
			return userName;
		}

		public void setUserName(String userName) {
			this.userName = userName;
		}

		public String getPassword() {
			return password;
		}

		public void setPassword(String password) {
			this.password = password;
		}

		public String getUserID() {
			return userID;
		}

		public void setUserID(String userID) {
			this.userID = userID;
		}
	}
    	','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (61,'SQL query JDBC',' SQL Query JDBC


 Example:


    /*
     The JDBC library provides an API for building SQL commands that sanitize untrusted data. Use the java.sql.PreparedStatement class properly to escape input strings and prevent SQL injection.
     This example uses a parametric query with a ? character as a placeholder for the argument, and also validates the length of the username argument, preventing an attacker from submitting an arbitrarily long user name.
    */

    public void doPrivilegedAction(
        String username, char[] password
    ) throws SQLException {
        Connection connection = getConnection();
        if (connection == null) {
            // Handle error
        }
        try {
            String pwd = hashPassword(password);
            // Validate username length
            if (username.length() > 8) {
                // Handle error
            }
        
            String sqlString = "select * from db_user where username=? and password=?";
            PreparedStatement stmt = connection.prepareStatement(sqlString);
            stmt.setString(1, username);
            stmt.setString(2, pwd);
            ResultSet rs = stmt.executeQuery();
            if (!rs.next()) {
                throw new SecurityException("User name or password incorrect");
            }
            // Authenticated; proceed
        } finally {
            try {
                connection.close();
            } catch (SQLException x) {
                // Forward to handler
            }
        }
    }


','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (62,'SQL Query',' SQL Query prepared statement and binding


 Example: 


    /*
    This example uses a prepared statement in order to insert data into the database.
    Because this method enforces the user to prepare all user input  passed into the query, it always escapes SQL injections so none could be accidentally forgotten.

    For detecting a possible attack on your application simply escaping the user input is obviously not enough.
    Therefore, you''''ll want to verify the input as submitted by the user does not contain malicious code.
    In this example the expected input is az/09:
    */

    :::java 
    String employeeId = request.getParameter(''''userId'''');
    String salary = request.getParameter(''''salary'''');
    Pattern numeric = Pattern.compile(".*[^09].*");
    if(!numeric.matcher(employeeId).find() && !numeric.matcher(salary).find()){

        /*
        Always log an action first and then perform the action:
        Set a log for whenever there is unexpected userinput with a threat level
        */
        log(userId, "Invalid expected input", "FAIL", Calendar.getInstance(), "privilege", "HIGH" );

        /*
        Set counter; if counter hits 3 the user''''s session must terminated.
        After 3 session terminations, the user''''s account must be blocked
        */
        counter++;
        if(counter > 2 ){
                blockUser(userId);
        }

        String updateQuery = "UPDATE EMPLOYEES SET SALARY = ? WHERE ID = ?";
        PreparedStatement preparedStatement = connection.prepareStatement(updateQuery);
        preparedStatement.setInt(1, salary);
        preparedStatement.setInt(2, employeeId);
    }

    // Always use parameterized queries with prepared statements.
    // For example, with Hibernate (HQL) named parameters

    :::java
    Query query = session.createQuery("UPDATE EMPLOYEES SET SALARY = :salary WHERE ID = :employeeId");
    query.setParameter("salary", salary);
    query.setParameter("employeeId", employeeId);

    // Or with JPA:

    :::java
    Query query = entityManager.createQuery("UPDATE EMPLOYEES SET SALARY = :salary WHERE ID = :employeeId");
    query.setParameter("salary", salary);
    query.setParameter("employeeId", employeeId);

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (63,'session hijacking and fixation',' Session hijacking and fixation 


 Example:


	/*
	As soon as a user logs into your application you must store his session id as wel as his
	IP address along with his userID. This information will be used later on in your application in order to
	identify possible session hijacking.

	TABLE track_sessions
	
	| TrackID | userID |               session                  |     ipaddress     | 
	
	|   1     | 1      |    79dcd529c0f5e01a9bfb2425c52036c6    |   123.45.67.89    |   
	
	|   2     | 1      |    79dcd529c0f5e01a9bfb2425c52036c6    |   123.45.67.81    |
	
	|   3     | 2      |    c80959d3ea4c166413774e45375ac2a1    |   987.65.43.21    |
	

	In order to prevent session hijacking there are a couple of defense strategies
	which combined are a hardened defense.  
	*/

	/*
	First we implement the strict transport security header, this is in order to prevent
	users from accessing your application over an unprotected connection.
	*/

	//Example of the strict transport security header:
	// response.setHeader("StrictTransportSecurity", "maxage=31536000");


	//If all present and future subdomains will be HTTPS:
	//response.setHeader("StrictTransportSecurity", "maxage=31536000; includeSubdomains;");


	/*
	Recommended: If the site owner would like their domain to be included in the HSTS preload 
	list maintained by Chrome (and used by Firefox and Safari), then use:
	*/

	// response.setHeader("StrictTransportSecurity", "maxage=31536000; includeSubdomains; preload");


	/*
	The `preload` flag indicates the site owner''''s consent to have their domain preloaded. The preload list
	enforces the browser to always present your application on HTTPS even on the first time
	the user hits your application
	*/

	/*
	Then we set the httpOnly flag
	(see "HttpOnly" in the code examples for more details about implementation)
	*/

	/*
	Then we set the flag for session timeout
	(see "Timeout" in the code examples for more details about implementation)
	*/

	/*
	Then we set the session secure flag 
	(see "Secure flag" in the code examples for more details about implementation)
	*/

	/*
	On login we also add another cookie with a random value to the application in order to
	prevent an attacker to fixate an JSSESSION id on your users and hijack their sessions
	(This code example can be found in the "Login functionality" for more detailed information)
	*/

	/*
	NOTE: On applications that require high level security, there should never be a
	remember me functionality implemented.
	*/

	/*
	Now imagine the scenario after the login of the user (see the "login functionality" in
	the code examples for more details). Whenever the user is logged in, the users ip address 
	and session id are also stored in the database these values are used in order to verify 
	if there are multiple users active on the same session. 
	If so, we can let the user decide to terminate the session and terminate the
	other assigned sessions.
	*/

	package com.edw;

	import java.io.IOException;
	import java.sql.*;
	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.servlet.RequestDispatcher;
	import javax.servlet.ServletException;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import javax.servlet.http.HttpSession;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	public final class SessionHijack extends HttpServlet{
		
		private static final long serialVersionUID = 1L;
		
		public SessionHijack() {
			super();
		}
		
		//First we include the audit log class.
		final static Logger logger = Logger.getLogger(SessionHijack.class);
			
		private int userID;
		private String ipaddress;
		private String sess ;
		private String user_ID ;
		private String trackID ;

		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 
		{
			user_ID = request.getSession().getId(); 	
			//Here we connect to the database
			Connection conn = null;
			
			if ((request.getSession().getAttribute("authenticateUser") != "isLoggedin") || 
				(request.getSession().getAttribute("authenticateUser") == ""))
				{			
					RequestDispatcher rd =
					request.getRequestDispatcher("/login");
					rd.forward(request, response);							
				}

			try {
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();	
				
				String query = "SELECT * from tracking WHERE userId = ?";
				PreparedStatement st = conn.prepareStatement(query);
				st.setString(1, user_ID);
				
				// execute the query, and get a java resultset
				//We bind the parameter in order to prevent sql injections
				ResultSet rs = st.executeQuery();
				
				//Next we read the value from the database and put it into a variable
				while (rs.next())
				{
					sess  = rs.getString("session");
					ipaddress = rs.getString("ipaddress");
					trackID =  rs.getString("TrackID");
					
					if ((request.getSession().getAttribute("JSSESSIONID").toString() != sess) && 
						(ipaddress != request.getRemoteAddr()))
						{   
						
							//We log the multiple users on the system 
							logger.info("Multiple users with same session id detected" + "  User ID:  " +  userID);
							/*
							We redirect the user to a page which alerts him as well as gives him the option to destroy the 
							multiple sessions if he does not trust them
							*/

							RequestDispatcher rd =
							request.getRequestDispatcher("/Home/multipleUsers");
							rd.forward(request, response);
						}		        
				}		      
				st.close();
				conn.close();		
			} catch (SQLException | NamingException e) {
				logger.error("cannot search database. check query" + e.toString() );
			}
			doGet(request, response);
		}	
		
		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			response.getWriter().append("Served at: ").append(request.getContextPath()).append("  OWASP Knowledge Base Code Examples");
		}

	}
	/*
	the only thing left to do now is to update your track_sessions table by inserting
	the ipaddress, sessionID and userID if you want to accept the other sessions as valid.
	Otherwise the user just has to terminate the current session in order to lock out the
	other sessions.
	*/
		','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (64,'AuditLog',' AuditLogs


 Example:


	package com.edw;
	import java.io.BufferedWriter;
	import java.io.FileWriter;
	import java.io.IOException;
	import java.io.PrintWriter;
	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.time.LocalDateTime;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	public final class AuditLog {
	
		private int countID;
		private int userID; 
		private int count; 
		private int blocker; 
		public static String validation = "pass"; 
		
		final static Logger logger = Logger.getLogger(AuditLog.class);
		
		
		public void SetLog(String userid, String message, String state, LocalDateTime localDateTime, String ThreatLevel, String remote_address)
		{

			try(FileWriter fw = new FileWriter("C:\\log.txt", true);
					BufferedWriter bw = new BufferedWriter(fw);
					PrintWriter out = new PrintWriter(bw))
				{
					out.println(userid + "  " + message + "  " + remote_address /*REMOTE_ADDR from servlet*/ + "  " + state + "  " + LocalDateTime.now()
					+ "  " +  localDateTime);

				} catch (IOException e) {
					logger.error("cannot write to file : "  + e.toString());
				}		
		}
		
		public void SetLog(String userid, String message, String state, LocalDateTime localDateTime, String ThreatLevel)
		{
			
			try(FileWriter fw = new FileWriter("C:\\log.txt", true);
					BufferedWriter bw = new BufferedWriter(fw);
					PrintWriter out = new PrintWriter(bw))
				{
					out.println(userid + "  " + message + "  " + state + "  " + LocalDateTime.now()
					+ "  " +  localDateTime);

				} catch (IOException e) {
					logger.error("cannot write to file : "  + e.toString());
				}		
		}
		
		public String counter(int counting)
		{

			Connection connect = null;
			try {
				
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				connect = ds.getConnection();			
				
				/*
				First we select the counts from the count table in order to verify if the user session should be terminated
				or that the user should be locked out.
				*/
				String sqlquery = "SELECT * from counter";
			
				//We bind the parameter in order to prevent sql injections
				PreparedStatement state = connect.prepareStatement(sqlquery);
				
				// execute the query, and get a java resultset
				ResultSet res = state.executeQuery();
				
				//Next we read the value from the database and put it into a variable
				while (res.next())
				{
					userID = res.getInt("userID");
					count  = res.getInt("count");
					blocker = res.getInt("blocker");
				}
				
				state.close();
				connect.close();
				
			} catch (SQLException | NamingException e) {
					logger.error("cannot search database. check query" + e.toString() );
					return "cannot search database. check query"; 
			}
			
			Connection conn = null;
			try {
				
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();			
				
				/*
				First we select the counts from the count table in order to verify if the user session should be terminated
				or that the user should be locked out.
				*/
				String query = "SELECT * from counter WHERE userID = ?";
			
				//We bind the parameter in order to prevent sql injections
				PreparedStatement st = conn.prepareStatement(query);
				st.setInt(1, userID);
				
				// execute the query, and get a java resultset
				ResultSet rs = st.executeQuery();
				
				//Next we read the value from the database and put it into a variable
				while (rs.next())
				{
					count  = rs.getInt("count");
					blocker = rs.getInt("blocker");
				}
				
				st.close();
				conn.close();
			
			} catch (SQLException | NamingException e) {
				logger.error("cannot search database. check query" + e.toString() );
				return "cannot search database. check query"; 
			}
			
			
			//We add the counting to the database results for the final value
			count  = count + counting; 
			int finalCount = count;
			blocker = blocker + counting;
			int finalBlock = blocker;
			
			//Here we connect to the database  
			Connection conn2 = null;
			try {
			Context initContext2 = new InitialContext();
			Context webContext2  = (Context)initContext2.lookup("java:/comp/env");
			DataSource ds2 = (DataSource)webContext2.lookup("jdbc/myJdbc");
			conn2 = ds2.getConnection();	
			
			// create the java mysql update preparedstatement
			String query2 = "UPDATE counter SET count = ?, blocker = ? WHERE userID = ?";
			PreparedStatement preparedStmt2 = conn2.prepareStatement(query2);
			preparedStmt2.setInt(1, count);
			preparedStmt2.setInt(2, blocker);
			preparedStmt2.setInt(3, userID);

			// execute the java preparedstatement
			preparedStmt2.executeUpdate();
			
			
			conn2.close();
			} catch (SQLException | NamingException e) {
				logger.error("SQL insert query error in update counter" + e.toString() );
				return "SQL insert query error in update counter";  // this can be used to dispatch the response back to the client showing a corresponding message
				} 
			
			
			if (finalCount == 3)
			{
				validation = "terminate";        	
			}

			if (finalBlock > 3)
			{        	
				int access = 0; //0 is considered as FALSE in MySQL
				
				//Here we connect to the database  
				Connection conn3 = null;
				try {
					Context initContext3 = new InitialContext();
					Context webContext3  = (Context)initContext3.lookup("java:/comp/env");
					DataSource ds3 = (DataSource)webContext3.lookup("jdbc/myJdbc");
					conn3 = ds3.getConnection();	
					
					// create the java mysql update prepared statement
					String query3 = "UPDATE users set access = ? WHERE userID = ?";
					PreparedStatement preparedStmt3 = conn3.prepareStatement(query3);
					preparedStmt3.setInt(1, access);
					preparedStmt3.setInt(3, userID);

					// execute the java preparedstatement
					preparedStmt3.executeUpdate();
					
					validation = "block";
					
					conn3.close();
				} catch (SQLException | NamingException e) {    					    			
					logger.error("SQL insert query error in update access" + e.toString() );
					return "SQL insert query error in update access" ;  // this can be used to dispatch the response back to the client showing a corresponding message   		    		
				}	
			}
			
			return validation;    		
		}		
	}

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (65,'Randomizer function',' Randomizer function


 Example:


    package com.edw;

    import java.security.SecureRandom;
    import java.util.ArrayList;
    import java.util.Base64;
    import java.util.List;
    import org.apache.log4j.Logger;

    public final class Randomizer {
        
        private List<Integer> bytes = new ArrayList<>();
        private int address = 0;
        final static Logger logger = Logger.getLogger(Randomizer.class);
        
        public String randomize()
        {		
            SecureRandom csprng = new SecureRandom();
            byte[] randomBytes = new byte[128];
            csprng.nextBytes(randomBytes);
            String csrftoken = Base64.getEncoder().encodeToString(randomBytes);
            
            return csrftoken;		
        }
        
        public String generateToken(int numberOfBytes)
        {		
            SecureRandom csprng = new SecureRandom();
            byte[] randomBytes = new byte[numberOfBytes];
            csprng.nextBytes(randomBytes);
            String csrftoken = null;
            try {
                csrftoken = this.bin2hex(randomBytes[0]);
            } catch (Exception e) {
                logger.error("Randomizer error : " + e.toString());
            }
            return csrftoken;		
        }
        public String generate(int numberOfBytes)
        {		
            SecureRandom csprng = new SecureRandom();
            byte[] randomBytes = new byte[numberOfBytes];
            csprng.nextBytes(randomBytes);
            String csrftoken = Base64.getEncoder().encodeToString(randomBytes);
            return csrftoken;		
        }
        
        public String secure_password(int numberOfBytes)
        {		
            SecureRandom csprng = new SecureRandom();
            byte[] randomBytes = new byte[numberOfBytes];
            csprng.nextBytes(randomBytes);
            String token = randomBytes.toString();
            return token;		
        }
        

        public void setAddress(int address) 
        {
            this.address = address;
        }

        public String bin2hex(int byt) throws Exception 
        {
            if (bytes.size() == 0xFF) 
            {
                throw new Exception("Too many bytes");        
            }
            bytes.add(byt);
            int sum = 0;
            StringBuilder sb = new StringBuilder();
            sb.append('''':'''');
            sb.append(toHexString(bytes.size(), 2));
            sum += bytes.size();
            sb.append(toHexString(address, 4));
            sum += (address & 0xFF00) >> 8;
            sum += address & 0xFF;
            address += bytes.size();
            sb.append("00");
            for (Integer b : bytes) {
                sum += b;
                sb.append(toHexString(b, 2));
            }
            sb.append(toHexString((~(sum & 0xFF) + 1) & 0xFF, 2));
            bytes.clear();
            return sb.toString();
        }

        private String toHexString(int i, int len) 
        {
            String hex = Long.toHexString(i).toUpperCase();
            if (len == 2) 
            {
                if (hex.length() == 1) 
                {
                    return "0" + hex;
                }else{
                    return hex;
                }
            }else{
                if (hex.length() == 1) 
                {
                    return "000" + hex;
                } else if (hex.length() == 2) 
                {
                    return "00" + hex;
                } else if (hex.length() == 3) 
                {
                    return "0" + hex;
                }else{
                    return hex;
                }
            }
        }
    }

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (66,'Whitelisting function',' Whitelisting function


 Example:


    package com.edw;
    import org.apache.log4j.Logger;

    public final class WhiteList
    {   
        final static Logger logger = Logger.getLogger(WhiteList.class);
        public boolean WhiteListing(String allowed, String input)
        {
            /*
            Here we define a white list of pages we want the user to be allowed to be redirected to, all 
            patterns are terminated whenever they not comply with the predefined white list
            */
            
            String[] pattern = allowed.split(",");
            //For validation if the file returned true
            boolean validated = false;
            //To catch the user submitting evil requests we count the number of times the for loop hits false
            int count = 0;
            int countArray = 0;
                    
            for( int i = 0; i < pattern.length; i++)
            {
                String item = pattern[i];
                
                //If filename is equal to the predefined items
                if ( input == item)
                {
                    validated = true ; 
                    count = 1;
                }
                
                //Here we increase the counts, if they are equal we know the function did not hit a valid filename
                count++;
                countArray++;
            }
            
            if (countArray == count)
            { 
                //this breach has to be reported into the log files
                validated = false;
                logger.info("Audit log message!" + "FAIL" + "HIGH");   
            }
            return validated;   
        } 
    }
    

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (67,'Charsets',' Charsets 


 Example:


	/*
	In order to set the "Charsets" header you''''ll have to add the 
	following code to the head of your application, the following code could be used in your controller 
	for by example, text/html:
	*/

	response.addHeader("ContentType: text/html", "charset=utf8");

	/*
	Or directly into your html markup:
	*/

	<meta httpequiv="ContentType" content="text/html; charset=utf8">
    		','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (68,'X Content Type Options header',' XContentTypeOptions header


 Example:


    /*
    In order to set the "XContentTypeOptions" header you''''ll have to add the 
    following code to the head of your application, the following code could be used in your controller:
    */

    response.appendHeader("XContentTypeOptions", "nosniff");
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (69,'XML External Entities',' XML External Entities 


 Example:

    
    /*
    The overall prevention method for loading external entities is adding the following line of code:
    This line of code function tells the underlying libxml parsing to not try to interpret the values 
    of the entities in the incoming XML and leave the entity references intact.

    Both DocumentBuilderFactory and SAXParserFactory XML Parsers can be configured using the same techniques to protect them against XXE.The JAXP DocumentBuilderFactory setFeature method allows a developer to control which implementationspecific XML processor features are enabled or disabled. The features can either be set on the factory or the underlying XMLReader setFeature method. Each XML processor implementation has its own features that govern how DTDs and external entities are processed.
    */

    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    String FEATURE = null;

    //or

    SAXParserFactory spf = SAXParserFactory.newInstance();
    SAXParser saxParser = spf.newSAXParser();
    XMLReader reader = saxParser.getXMLReader();
      
    

    //  DocumentBuilderFactory
    import javax.xml.parsers.DocumentBuilderFactory;
    import javax.xml.parsers.ParserConfigurationException; // catching unsupported features

    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        String FEATURE = null;
        try {
            // This is the PRIMARY defense. If DTDs (doctypes) are disallowed, almost all XML entity attacks are prevented
            // Xerces 2 only  http://xerces.apache.org/xerces2j/features.htmldisallowdoctypedecl
            FEATURE = "http://apache.org/xml/features/disallowdoctypedecl";
            dbf.setFeature(FEATURE, true);

            // If you can''''t completely disable DTDs, then at least do the following:
            // Xerces 1  http://xerces.apache.org/xercesj/features.htmlexternalgeneralentities
            // Xerces 2  http://xerces.apache.org/xerces2j/features.htmlexternalgeneralentities
            // JDK7+  http://xml.org/sax/features/externalgeneralentities    
            FEATURE = "http://xml.org/sax/features/externalgeneralentities";
            dbf.setFeature(FEATURE, false);

            // Xerces 1  http://xerces.apache.org/xercesj/features.htmlexternalparameterentities
            // Xerces 2  http://xerces.apache.org/xerces2j/features.htmlexternalparameterentities
            // JDK7+  http://xml.org/sax/features/externalparameterentities    
            FEATURE = "http://xml.org/sax/features/externalparameterentities";
            dbf.setFeature(FEATURE, false);

            // Disable external DTDs as well
            FEATURE = "http://apache.org/xml/features/nonvalidating/loadexternaldtd";
            dbf.setFeature(FEATURE, false);

            // and these as well, per Timothy Morgan''''s 2014 paper: "XML Schema, DTD, and Entity Attacks" (see reference below)
            dbf.setXIncludeAware(false);
            dbf.setExpandEntityReferences(false);
    
            // And, per Timothy Morgan: "If for some reason support for inline DOCTYPEs are a requirement, then 
            // ensure the entity settings are disabled (as shown above) and beware that SSRF attacks
            // (http://cwe.mitre.org/data/definitions/918.html) and denial 
            // of service attacks (such as billion laughs or decompression bombs via "jar:") are a risk."

            // remaining parser logic
            ...
    
            } catch (ParserConfigurationException e) {
                // This should catch a failed setFeature feature
                logger.info("ParserConfigurationException was thrown. The feature ''''" +
                            FEATURE +
                            "'''' is probably not supported by your XML processor.");
                ...
            }
            catch (SAXException e) {
                // On Apache, this should be thrown when disallowing DOCTYPE
                logger.warning("A DOCTYPE was passed into the XML document");
                ...
            }
            catch (IOException e) {
                // XXE that points to a file that doesn''''t exist
                logger.error("IOException occurred, XXE may still possible: " + e.getMessage());
                ...
            }
        
        
        
    
        
    // SAXParserFactory
        
    import javax.xml.parsers.ParserConfigurationException;  // catching unsupported features
    import javax.xml.parsers.SAXParser;
    import javax.xml.parsers.SAXParserFactory;
    
    import org.xml.sax.SAXNotRecognizedException;  // catching unknown features
    import org.xml.sax.SAXNotSupportedException;  // catching known but unsupported features
    import org.xml.sax.XMLReader;
    
    ...
    
        SAXParserFactory spf = SAXParserFactory.newInstance();
        SAXParser saxParser = spf.newSAXParser();
        XMLReader reader = saxParser.getXMLReader();
    
        try {
            // Xerces 1  http://xerces.apache.org/xercesj/features.htmlexternalgeneralentities
            // Xerces 2  http://xerces.apache.org/xerces2j/features.htmlexternalgeneralentities
    
            // Using the SAXParserFactory''''s setFeature
            spf.setFeature("http://xml.org/sax/features/externalgeneralentities", false);
            // Using the XMLReader''''s setFeature
            reader.setFeature("http://xml.org/sax/features/externalgeneralentities", false);
    
            // Xerces 2 only  http://xerces.apache.org/xercesj/features.htmlexternalgeneralentities
            spf.setFeature("http://apache.org/xml/features/disallowdoctypedecl", true);
    
            // remaining parser logic
          ...
    
        } catch (ParserConfigurationException e) {
          // Tried an unsupported feature.
    
        } catch (SAXNotRecognizedException e) {
          // Tried an unknown feature.
    
        } catch (SAXNotSupportedException e) {
          // Tried a feature known to the parser but unsupported.
    
        } catch ... {
          
        }
    ...
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (70,'XSL Injection Prevention',' XSL Injection Prevention 


 Example:


    /*
    In order to prevent XSL injections you must enforce strict policy''''s whenever the
    files are loaded from a source controlled by a possible attacker.

    Let''''s say for example that the user can choose from several XSL files on your application.

    ABC.xsl arranges your employee names on alphabetical order
    CBA.xsl just shows the input by order of your XML file.

    Before attaching the XSL files to the style sheet we first want to 
    do validation on the request to make sure the included file was one of our own predefined files
    */

    package com.edw;

    import java.io.File;
    import java.io.IOException;

    import javax.xml.parsers.DocumentBuilder;
    import javax.xml.parsers.DocumentBuilderFactory;
    import javax.xml.parsers.FactoryConfigurationError;
    import javax.xml.parsers.ParserConfigurationException;
    import javax.xml.transform.OutputKeys;
    import javax.xml.transform.Source;
    import javax.xml.transform.Transformer;
    import javax.xml.transform.TransformerException;
    import javax.xml.transform.TransformerFactory;
    import javax.xml.transform.dom.DOMResult;
    import javax.xml.transform.dom.DOMSource;
    import org.w3c.dom.ls.LSSerializer;
    import org.w3c.dom.Document;
    import org.xml.sax.SAXException;
    import org.w3c.dom.ls.DOMImplementationLS;

    public class IncludeXSL {

        private WhiteList wt = new WhiteList();
        
        public String includeXSL(String WhiteListing, String input)
        {
            LSSerializer serializer = null ;
            boolean continue_ = true;
            Document result = null;
            
            /*
            We want to WhiteList the paged for expected values, in this example they are,
            page1,page2 etc.. for more information about WhiteListing see "whitelisting" in the code examples:
            */
            
            if (wt.WhiteListing(WhiteListing, input) == false) { continue_ = false; }
            
            //If all went good we do the function
            if(continue_)
            {
                //LOAD XML FILE
                //Load the XML source
                Document xslt = null; 
                Document xml = null; 
                try {
                    File fXmlFile = new File(input);
                    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
                    DocumentBuilder db = dbFactory.newDocumentBuilder();      
                    xml  = db.newDocument();
                    xslt = db.parse(fXmlFile);
                } catch (SAXException | IOException | ParserConfigurationException e) {
                    
                }
                
                xml.appendChild(xml.createElementNS(null, "root"));
                try {
                    result = transformXML(xml, xslt);
                } catch (TransformerException | ParserConfigurationException | FactoryConfigurationError e) {
                    
                }
                serializer = ((DOMImplementationLS) xml.getImplementation()).createLSSerializer();
            }
            return serializer.writeToString(result); 
        }
        
        //Configure the transformer
        public static Document transformXML(Document xml, Document xslt) throws TransformerException, ParserConfigurationException, FactoryConfigurationError {

            Source xmlSource = new DOMSource(xml);
            Source xsltSource = new DOMSource(xslt);
            DOMResult result = new DOMResult();

            // the factory pattern supports different XSLT processors
            TransformerFactory transFact = TransformerFactory.newInstance();
            Transformer trans = transFact.newTransformer(xsltSource);
            trans.setOutputProperty(OutputKeys.ENCODING, "UTF8");
            trans.transform(xmlSource, result);
            Document resultDoc = (Document) result.getNode();

            return resultDoc;
        }
    }

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (71,'XSS Filtering',' XSS filtering


 Example:


		package com.edw;

		import org.owasp.esapi.ESAPI;
		import org.jsoup.Jsoup;
		import org.jsoup.safety.Whitelist;

		public final class XssFilter {

			/**
			* Strips any potential XSS threats out of the value
			* @param value
			* @return
			*/
			public String filter( String value ) {
			    if( value == null )
							return null;
			
				// Use the ESAPI library to avoid encoded attacks.
				value = ESAPI.encoder().canonicalize( value );
			
				// Avoid null characters
				value = value.replaceAll("\0", "");
			
				// Clean out HTML
				value = Jsoup.clean( value, Whitelist.none() );
			
				return value;
			}	
		}

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (72,'User Registration SQL truncation prevention',' User registration SQL truncation prevention


 Example:


	/*
	In order to prevent Column truncation SQL injection Solution we have to make sure the
	applications structural logic does not mismatches with the database structural logic.
	To achieve this imagine the follow example of a database structure of a users table

	TABLE users
	
	|        *Name*        |    *Type*        |    *Extra*     |
	
	|        userID        |    Int(11)       | AUTO_INCREMENT |
	
	|       Username       |    char(21)      |                |
	
	|       Password       |  Varchar(255)    |                |
	
	|      PrivilegeID     |    Int(11)       |                |
	
	*/


	package com.edw;

	import java.io.UnsupportedEncodingException;
	import java.security.InvalidKeyException;
	import java.security.NoSuchAlgorithmException;
	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.time.LocalDateTime;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	public final class RegisterUser {
		
		private AuditLog Log = new AuditLog();
		private Hashing hash = new Hashing();
		final static Logger logger = Logger.getLogger(RegisterUser.class);
		
		public boolean userCheck(String username){
			
			boolean isTrue = false; 
			//Here we connect to the database by means of a connection configured in the web.xml and /METAINF/context.xml 
			Connection conn = null;
			try {
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();	

				//Here we select the number of counts from aggregate column in order to verify the number of connections:
				String query = "SELECT * FROM members WHERE username = ?";
			
				//We bind the parameter in order to prevent SQL injections
				PreparedStatement st = conn.prepareStatement(query);
				st.setString(1, username);
				
				// execute the query, and get a java result set

				ResultSet rs = st.executeQuery();
				
				if (!rs.isBeforeFirst() && !rs.next())
				{
					isTrue = true;
				}
				
				st.close();
				conn.close();
				
			} catch (SQLException | NamingException e) {
				logger.error("cannot search database. check query" + e.toString() );
			}
			return isTrue;
		}
		
		public boolean userRegister(String username, String password, int privID){

			boolean isTrue = false;
			
			/*
			Whenever the user gains the ability to register himself or change his user
			credentials you must always enforce the application to compare the length of the
			submitted string against the length of the allowed string length in your database
			structure in order to prevent SQL column truncation.
			*/
			
			int length = username.length(); 
			/*
			We now compare the length of the username against the allowed string length in
			The database structure
			*/
			if(length >= 21){
				//If length is to large the function must return false and the result must be logged.
				Log.SetLog(username, "Username was to long!", "FAIL!", LocalDateTime.now(), null);
			}
			
			//If true then register the user!       
			if(this.userCheck(username) == true){
				isTrue = true;
				
				//Then we encrypt the password
				String salt = "";
				String passhash = "";
				try {
					salt = hash.createSalt(password);	    	 
					passhash = hash.hashPassword(salt, password);
				} catch (InvalidKeyException | NoSuchAlgorithmException | UnsupportedEncodingException e) {
					logger.error("Error in hashing algorithm " + e.toString();
				}   
				
				//Here we connect to the database by means of a connection string as configured in the web.xml and /METAINF/context.xml 
				Connection conn = null;
				try {	
					Context initContext = new InitialContext();
					Context webContext  = (Context)initContext.lookup("java:/comp/env");
					DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
					conn = ds.getConnection();	
					
					//After successful validation we enter the new user into the database
					String query = "INSERT INTO users"
							+ " (Username, Password, PrivilegeID)"
							+ " VALUES"
							+ " (?, ?, ?)";
						
					PreparedStatement st = conn.prepareStatement(query);
					
					st.setString(1, username);
					st.setString(2, passhash);
					st.setInt(3, privID);

					ResultSet rs = st.executeQuery();
							
					rs.close();
					st.close();
					conn.close();
					
				} catch (SQLException | NamingException e) {
						logger.error("cannot search database. check query" + e.toString() );
				}
			}else{
				Log.SetLog("", "Username" + username + " already exists!", "FAIL!", LocalDateTime.now(), null);
				isTrue = false ;
			}
			return isTrue;
		}	
	}
    ','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (73,'Reauthentication',' Reauthentication 


 Example:


	package com.edw;

	import java.io.IOException;
	import java.net.HttpCookie;
	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.time.LocalDateTime;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.servlet.ServletException;
	import javax.servlet.annotation.WebServlet;
	import javax.servlet.http.Cookie;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import javax.sql.DataSource;
	import java.util.UUID;

	import org.apache.log4j.Logger;

	import com.ning.http.client.Request;

	/**
	* Servlet implementation class Reauth
	*/
	@WebServlet("/Reauth")
	public final class Reauth extends HttpServlet {
		private static final long serialVersionUID = 1L;
		private int userID; 
		private String username; 
		private String password; 
		private String access; 
		private String salt; 
		private int privilege; 
		private boolean loggedin = false;
		final static Logger logger = Logger.getLogger(Reauth.class);
		
		AuditLog Log = new AuditLog();

		//Second we include the password hash.
		Hashing hash = new Hashing();

		//Third we include the random password/token class.
		Randomizer CSRF = new Randomizer();
		
		/**
		* @see HttpServletHttpServlet()
		*/
		public Reauth() {
			super();
		}

		/**
		* @see HttpServletdoGet(HttpServletRequest request, HttpServletResponse response)
		*/
		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			response.getWriter().append("Served at: ").append(request.getContextPath());
		}

		/**
		* @see HttpServletdoPost(HttpServletRequest request, HttpServletResponse response)
		*/
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			
			loggedin = reAuthentication(request,response);
			
			if (loggedin == false)
			{
				request.getSession().invalidate();
				request.getSession().setAttribute("Authenticated", "");
				
				Cookie cookie = null;
				Cookie[] cookies = null;
				// Get an array of Cookies associated with this domain
				cookies = request.getCookies();
					
				for (Cookie cookie2 : cookies) {
					cookie = cookie2;
						
					if (cookie.getName().equals("JSESSIONID"))
					{        	 
						cookie.setValue("");
					}         
					response.addCookie(null);
					request.setAttribute("msg","Session terminated!");
					request.getRequestDispatcher("/login.jsp").forward(request, response);
					return;
				}
			}
			doGet(request, response);
		}
		
		public boolean reAuthentication(HttpServletRequest request, HttpServletResponse response)
		{
			String passwordHash = "";
			//Here we connect to the database by means of a connection string as configured in the web.xml and /METAINF/context.xml 
			Connection conn = null;
			try {		
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();	

				//Here we select the number of counts from aggregate column in order to verify the number of connections:
				String query = "SELECT * from users WHERE userID = ?";
			
				PreparedStatement st = conn.prepareStatement(query);
				st.setInt(1, userID);
				
				// execute the query, and get a java result set
				//We bind the parameter in order to prevent SQL injections
				ResultSet rs = st.executeQuery();
				while (rs.next())
				{
					passwordHash  = rs.getString("password");
					salt = rs.getString("password");
				}
				
				st.close();
				conn.close();
			
			} catch (SQLException | NamingException e) {
				logger.error("cannot search database. check query" + e.toString() );
			}
			
			/*
			We validate the password see "Password storage(salting stretching Hashing)" in the code examples
			for more detailed information:
			*/
			if (hash.Validate(passwordHash, salt, password) == true)
			{
				//the connection has to be reported into the log files	
				Log.SetLog("Null", "login was OK!", "SUCCESS", LocalDateTime.now(), "NULL");

				/*
				This is is to prevent session fixation, after login we create a new cookie which
				we than use to authenticate. This value can not be fixated since it is set after 
				login.

				create a new UUID and save into the session:
				*/
		
				//All the random tokens will now be changed
				UUID uid = UUID.randomUUID();          
				String AuthToken = uid.toString();
				request.getSession().setAttribute("AuthToken", AuthToken);
				
				// now create a new cookie with this UUID value
				Cookie cookie = new Cookie("AuthToken",AuthToken);
				response.addCookie(cookie);

				/*
				Now we create a random value for our CSRF tokens. See "Random password/token generation" in
				the code examples for more detailed information:
				*/
				
				String CSRftoken = CSRF.generate(25);
				request.getSession().setAttribute("CSRF", CSRftoken);
				request.getSession().setAttribute("access", "Authenticated");

				loggedin = true;
			}else{
				//If things went wrong we destroy the entire session. see "logout" code example for more info:
				loggedin = false ;
			}
			return loggedin;
		}
	}
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (74,'Open Forwards and redirects',' Open Forwards and Redirects 


 Example:


    /*
    When using forwards & redirects you should make sure the URL is being explicitly 
    declared in the code and cannot be manipulated by an attacker like:
    */

    //response.Redirect("/login");

    /*
    Generally you should avoid getting input into the redirect which could contain
    userinput by any means. if for any reason this may not be feasible than you 
    should make a WhiteList input validation for the redirect like so:
    */

    package com.edw;

    public class OpenForwards {

        public boolean openForwards(String redirect)
        {
            WhiteList listMe = new WhiteList();
            boolean validated = true;

            //For more information about whitelisting see the "WhiteListing" code example:
            if (listMe.WhiteListing("page1,page2,page3", redirect) == false) { validated = false; }

            //return the value back to the servlet in order to handle redirection. 
            //if the variable validate is true then it will redirect
            
            return validated; 
        }  
    }
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (75,'Secure Session Cookies',' Secure Session Cookies 


 Example:


    //Secure Flag

    //Benefit: Instructs the browser to never send the cookie over a HTTP request. The cookie can only be sent over HTTPS. This works //even if the user manually types in a request for HTTP. The HTTP request will be sent, but the browser will not send any cookies //marked as “SECURE”

    //Limitations: The HTTP Request is still sent and this could be manipulated by a man in the middle to perform convincing phishing //attacks (See Strict Transport Security for solution).

    //Example within HTTP Response:
    //Cookie: JSESSIONID=kljahsdf123; SECURE;

    //web.xml

    //Servlet 3.0 (Java EE 6) introduced a standard way to configure secure attribute for the session cookie, this can be done by //applying the following configuration in web.xml

    <sessionconfig>
    <cookieconfig>
    <secure>true</secure>
    </cookieconfig>
    </sessionconfig>

    //Tomcat

    //In Tomcat 6 if the first request for session is using https then it automatically sets secure attribute on session cookie. 

    //or programmatically 

    String sessionid = request.getSession().getId();
    response.setHeader("SETCOOKIE", "JSESSIONID=" + sessionid + "; secure");
    ','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (76,'Rfc2898 DeriveBytes',' RFC 2898 password derivation compatible with .NET Rfc2898DeriveBytes


 Example:


	package com.edw;

	import java.io.UnsupportedEncodingException;
	import java.security.InvalidKeyException;
	import java.security.NoSuchAlgorithmException;

	import javax.crypto.Mac;
	import javax.crypto.spec.SecretKeySpec;

	/*
	 RFC 2898 password derivation compatible with .NET Rfc2898DeriveBytes class.
	*/

	public final class Rfc2898DeriveBytes
	{
		public static void main(String[] args) throws Exception
		{
			Rfc2898DeriveBytes rfc2898 = new Rfc2898DeriveBytes("*^@KK@!        ", "*^@KK@!".getBytes());

		}

		private Mac _hmacSha1;
		private byte[] _salt;
		private int _iterationCount;

		private byte[] _buffer = new byte[20];
		private int _bufferStartIndex = 0;
		private int _bufferEndIndex = 0;
		private int _block = 1;

		/**
		* Creates new instance.
		* 
		* @param password
		*            The password used to derive the key.
		* @param salt
		*            The key salt used to derive the key.
		* @param iterations
		*            The number of iterations for the operation.
		* @throws NoSuchAlgorithmException
		*             HmacSHA1 algorithm cannot be found.
		* @throws InvalidKeyException
		*             Salt must be 8 bytes or more. or Password cannot be null.
		*/
		public Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations) throws NoSuchAlgorithmException, InvalidKeyException
		{
			if ((salt == null) || (salt.length < 8))
			{
				throw new InvalidKeyException("Salt must be 8 bytes or more.");
			}
			if (password == null)
			{
				throw new InvalidKeyException("Password cannot be null.");
			}
			this._salt = salt;
			this._iterationCount = iterations;
			this._hmacSha1 = Mac.getInstance("HmacSHA1");
			this._hmacSha1.init(new SecretKeySpec(password, "HmacSHA1"));
		}

		/**
		* Creates new instance.
		* 
		* @param password
		*            The password used to derive the key.
		* @param salt
		*            The key salt used to derive the key.
		* @param iterations
		*            The number of iterations for the operation.
		* @throws NoSuchAlgorithmException
		*             HmacSHA1 algorithm cannot be found.
		* @throws InvalidKeyException
		*             Salt must be 8 bytes or more. or Password cannot be null.
		* @throws UnsupportedEncodingException
		*             UTF8 encoding is not supported.
		*/
		public Rfc2898DeriveBytes(String password, byte[] salt, int iterations) throws InvalidKeyException, NoSuchAlgorithmException, UnsupportedEncodingException
		{
			this(password.getBytes("UTF8"), salt, iterations);
		}

		/**
		* Creates new instance.
		* 
		* @param password
		*            The password used to derive the key.
		* @param salt
		*            The key salt used to derive the key.
		* @throws NoSuchAlgorithmException
		*             HmacSHA1 algorithm cannot be found.
		* @throws InvalidKeyException
		*             Salt must be 8 bytes or more. or Password cannot be null.
		* @throws UnsupportedEncodingException
		*             UTF8 encoding is not supported.
		*/
		public Rfc2898DeriveBytes(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException
		{
			this(password, salt, 0x3e8);
		}

		/**
		* Returns a pseudorandom key from a password, salt and iteration count.
		* 
		* @param count
		*            Number of bytes to return.
		* @return Byte array.
		*/
		public byte[] GetBytes(int count)
		{
			byte[] result = new byte[count];
			int resultOffset = 0;
			int bufferCount = this._bufferEndIndex  this._bufferStartIndex;

			if (bufferCount > 0)
			{ // if there is some data in buffer
				if (count < bufferCount)
				{ // if there is enough data in buffer
					System.arraycopy(this._buffer, this._bufferStartIndex, result, 0, count);
					this._bufferStartIndex += count;
					return result;
				}
				System.arraycopy(this._buffer, this._bufferStartIndex, result, 0, bufferCount);
				this._bufferStartIndex = this._bufferEndIndex = 0;
				resultOffset += bufferCount;
			}

			while (resultOffset < count)
			{
				int needCount = count  resultOffset;
				this._buffer = this.func();
				if (needCount > 20)
				{ // we one (or more) additional passes
					System.arraycopy(this._buffer, 0, result, resultOffset, 20);
					resultOffset += 20;
				}else{
					System.arraycopy(this._buffer, 0, result, resultOffset, needCount);
					this._bufferStartIndex = needCount;
					this._bufferEndIndex = 20;
					return result;
				}
			}
			return result;
		}

		private byte[] func()
		{
			this._hmacSha1.update(this._salt, 0, this._salt.length);
			byte[] tempHash = this._hmacSha1.doFinal(getBytesFromInt(this._block));

			this._hmacSha1.reset();
			byte[] finalHash = tempHash;
			for (int i = 2; i <= this._iterationCount; i++)
			{
				tempHash = this._hmacSha1.doFinal(tempHash);
				for (int j = 0; j < 20; j++)
				{
					finalHash[j] = (byte) (finalHash[j] ^ tempHash[j]);
				}
			}
			if (this._block == 2147483647)
			{
				this._block = 2147483648;
			}else{
				this._block += 1;
			}
			return finalHash;
		}

		private static byte[] getBytesFromInt(int i)
		{
			return new byte[] { (byte) (i >>> 24), (byte) (i >>> 16), (byte) (i >>> 8), (byte) i };
		}
	}

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (77,'Login function',' Login Functionality 


 Example:


	package com.edw;

	import java.io.IOException;
	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.util.UUID;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.servlet.ServletException;
	import javax.servlet.http.Cookie;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	public final class Login extends HttpServlet{

		final static Logger logger = Logger.getLogger(Login.class);
		private String password ;
		private String username;
		private int userID;
		private String salt;
		private String access ;
		private int privilege;

		//First we include the audit log class.
		Auditlog Log = new Auditlog();
			
		//Second we include the password hash.
		Hashing hash = new Hashing();

		//Third we include the random password/token class.
		Randomizer CSRF = new Randomizer();
			
		//Last we include the random InputValidation class.
		InputValidation validate = new InputValidation();
			
		/**
		* 
		*/
		private static final long serialVersionUID = 1L;
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

			username = req.getParameter("username");
			this.checkSession(req, resp);
			String passwordHash = "";
			String userId = "";

			//we also validate the username input, if it was bad we empty the string:
			if (validate.validateInput(username, "alphanumeric", "Error in username", "LOW", "0") != true) { username = ""; }
		
			//Here we connect to the database by means of a connection string as configured in the web.xml 
			Connection conn = null;
			try {
					
				Context initContext = new InitialContext();
				Context webContext  = (Context)initContext.lookup("java:/comp/env");
				DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
				conn = ds.getConnection();	

				//Here we select the user from the users table
				String query = "SELECT * from users WHERE username = ?";
			
				PreparedStatement st = conn.prepareStatement(query);
				st.setString(1, username);
				
				//execute the query, and get a java resultset
				//We bind the parameter in order to prevent sql injections

				ResultSet rs = st.executeQuery();
				
				while (rs.next())
				{
					username   = rs.getString("username");
					passwordHash = rs.getString("password");
					salt = rs.getString("salt");
					userId = rs.getString("userID");
				}
				
				st.close();
				conn.close();
				
			} catch (SQLException | NamingException e) {
				logger.error("cannot search database. check query" + e.toString() );
			}

			/*
			We validate the password see "Password storage(salting stretching Hashing)" in the code examples
			for more detailed information:
			*/
			if (hash.Validate(passwordHash, salt, password) == true)
			{
				/*
				This is is to prevent session fixation, after login we create a new cookie which
				we then use to authenticate. This value can not be fixated since it is set after 
				login.

				create a new UUID and save into the session:
				*/

				UUID uuid = UUID.randomUUID();
				String randomUUIDString = uuid.toString();
				req.getSession().setAttribute("AuthToken", randomUUIDString);  
				
				// now create a new cookie with this UUID value
				Cookie newCookie = new Cookie("AuthToken", randomUUIDString);        	 
				resp.addCookie(newCookie);
				
				//the connection has to be reported into the log files
				Log.SetLog("", "", "login was OK!", "SUCCESS", "NULL");
				
				/*
				Now we create a random value for our CSRF tokens. See "Random password token generation" in
				the code examples for more detailed information:
				*/
				String CSRftoken = CSRF.generate(25);
				
				//Set an accessor session.
				req.getSession().setAttribute("CSRF", CSRftoken);  
				
				/*
				Put id in a session for query identifier based authentication
				See "identifier based authentication" code example for more information
				*/
				req.getSession().setAttribute("userID", userId);
			}else{
				//the connection has to be reported into the log files
				Log.SetLog("", "null", "Login failed!", "FAIL", "NULL");
			
				req.setAttribute("msg","Session terminated!");
				req.getRequestDispatcher("/login.jsp").forward(req, resp);
				return;
			}	
			super.doGet(req, resp);
		}

		@Override
		protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			super.doPost(req, resp);
		}

		//In this method we do a check if the sessions are ok
		public void checkSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
		{
			Cookie cookie = null;
			Cookie[] cookies = null;
			// Get an array of Cookies associated with this domain
			cookies = req.getCookies();
			
			String authtoken = " "; 
			for (int i = 0; i < cookies.length; i++){
				cookie = cookies[i];
					
				if (cookie.getName().equals("AuthToken"))
				{
					authtoken = cookie.getName(); 
				}
				
				//We use this try catch for whenever the cookie is dropped
				try{
					//Check sessions and cookies to see if they match
					if (!req.getSession().getAttribute("AuthToken").equals(authtoken) || req.getSession().getAttribute("AuthToken") != "access")
					{
						req.setAttribute("msg","Session terminated!");
						req.getRequestDispatcher("/login.jsp").forward(req, resp);
						return;
					}
				}catch (Exception e){
						logger.error(e.toString());
						req.getSession().removeAttribute("Authenticated");
						req.getSession().invalidate();
						req.getRequestDispatcher("/login.jsp").forward(req, resp);
						return;       
				}
			}    
		}
	}
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (78,'HTML Output',' HTML Output


 Example:

	      
	/*
	Whenever user input is displayed in the application all user input should be properly escaped 
	to prevent XSS injections.
	*/

	/*
	This escaping is used whenever you put the code straight into the html like:
	<span>YOUR USER INPUT</span>
	The attack bellow will now be outputted as,
	&lt;script&gt;alert(1337);&lt;/script&gt;
	*/

	import org.owasp.esapi.ESAPI;
	import org.owasp.esapi.errors.EncodingException;

	String htmlbug = ESAPI.encoder().encodeForHTML("<script>alert(1337);</script>");

	/*
	This next encoding method is used for whenever you are allowing userinput into 
	html attributes.
	The attack below will now be outputted as:
	onload=&amp;39;alert(1337)&amp;39;
	*/
			
	String htmlatr = ESAPI.encoder().encodeForHTMLAttribute("onload=''''alert(1337);''''");
			
	/*
	Whenever parameters are rendered via javascript your application will detect normal injections
	in the first instant. in order for the application not to be vulnerable to javascript encoding you MUST use the encodeForJavaScript function, any other escaping function still leaves your code vulnerable
	*/	      

	ESAPI.encoder().encodeForJavaScript("\\x3Cscript\\x3Ealert(12);\\x3C\\x2Fscript\\x3E");
			
	/*
	Whenever a user can submit an link/A HREF in your application you must solely depend upon the
	"ESAPI.encoder().encodeForURL" method since an attacker could otherwise inject the href with an XSS
	that looks like this "javascript:alert("XSS");" whenever a victim now clicks the link this XSS
	will be executed in his browser.
	*/ 

	try {
		ESAPI.encoder().encodeForURL("javascript:alert(234);");
	} catch (EncodingException e) {
		logger.error("Error encoding characters : " + e.toString() + " Time : " + LocalDateTime.now());
	}

	/*
	Security consists of different layers of protection in order to guarantee the integrity
	of your application. This means that the value displayed from the database/user should
	already be sanitized before being processed in order to prevent XSS.

	As an example, what do you do when you expect a numeric value from your application?

	You first sanitize the user input by means of an input validation method like:
	See the "input validation" class for the entire example!
	*/
	InputValidation validate = new InputValidation();
	String userinput = "when this string is evil the application will block operation!";
	if(validate.validateInput(userinput, "numeric", "Unexpected user input", "HIGH", 3)== false)
	{ /* Cancel operation of your application */ }
			
	/*
	In this example the application cancelled the request by means of simple validation.
	*/
    


','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (79,'HttpOnly flag',' HttpOnly flag


 Example:


    //If you''''re using Servlets 3.0, you can actually instruct the app server to ensure that all session cookies are HttpOnly and Secure //with the following fragments:

    <sessionconfig>
      <cookieconfig>
        <secure>true</secure>
        <httponly>true</httponly>
      </cookieconfig>
    </sessionconfig>


    //httpOnly is supported as of Tomcat 6.0.19 and Tomcat 5.5.28.

    //See the changelog entry for bug 44382.

    //The last comment for bug 44382 states, "this has been applied to 5.5.x and will be included in 5.5.28 onwards." However, it does //not appear that 5.5.28 has been released.

    //The httpOnly functionality can be enabled for all webapps in conf/context.xml:

    <Context useHttpOnly="true">
    ...
    </Context>

    //  My interpretation is that it also works for an individual context by setting it on the desired Context entry in conf/server.xml // (in the same manner as above).

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (80,'Session cookies domain',' Session Cookies 


 Example:


    /*
    Setting the "Domain" attribute to a too permissive value, such as "example.com" 
    allows an attacker to launch attacks on the session IDs between different hosts and 
    web applications belonging to the same domain, known as crosssubdomain cookies.
    For example, vulnerabilities in www.example.com might allow an attacker to get access 
    to the session IDs from secure.example.com.
    */

    //This is apparently supported via a configuration setting in 6.0.27 and onwards:

    Configuration is done by editing METAINF/context.xml

    <Context sessionCookiePath="/something" sessionCookieDomain=".domain.tld" />
','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (81,'RFD and file download injections',' RFD and file download injections


 Example:


    /*
    the following code snippet represents the jsf page used to download a file 

    <html xmlns="http://www.w3.org/1999/xhtml"
        xmlns:h="http://java.sun.com/jsf/html"
        xmlns:f="http://java.sun.com/jsf/core"
        xmlns:p="http://primefaces.org/ui"
        xmlns:cu="http://localhost:8080/custom"
        xmlns:ui="http://java.sun.com/jsf/facelets">

    <f:view contentType="text/html">
    <h:head>
        <h:outputStylesheet name="commonstyle.css" library="css" />
    </h:head>   
    <h:body>
        <div id="page">    
                <div id="header">
                <ui:insert name="header" >
                    <ui:include src="commonHeader.xhtml" />
                </ui:insert>
                    <img src="resources/images/skf.png"></img>
                </div>
                <p:separator style="border: 0px;"></p:separator>
        </div>
        
        <div id="content">      
            <ui:insert name="content" >
            <ui:include src="commonDownloadRFD.xhtml" />
            </ui:insert>      
            <p:dialog modal="true" widgetVar="statusDialog" header="Status" draggable="false" closable="false" resizable="false">
                <p:graphicImage name="/images/ajaxloadingbar.gif" />
            </p:dialog>
            
            <h:form>
                <p:commandButton value="Download" ajax="false" actionListener="{fileDownloadController.filedownload}" onclick="PrimeFaces.monitorDownload(start, stop);" icon="uiiconarrowthick1s">
                </p:commandButton>
                <p:spacer width="20" height="40" />
                <p:commandButton action="{navigationController.moveToMainMenu}" ajax="false" value="Main Menu" />    
            </h:form>
            
            <script type="text/javascript">
                    function start() {
                        PF(''''statusDialog'''').show();
                    }
                    
                    function stop() {
                        PF(''''statusDialog'''').hide();
                    }
            </script>
        </div>
    </h:body>
    </f:view>
    </html>

    */


    // The following bean represents the managed bean to perform the file download action   

    package prime.com.beans;

    import java.io.File;
    import java.io.FileInputStream;
    import java.io.IOException;
    import java.io.OutputStream;
    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.time.LocalDateTime;
    import org.apache.log4j.Logger;
    import java.util.regex.Pattern;

    import javax.faces.application.FacesMessage;
    import javax.faces.bean.ManagedBean;
    import javax.faces.component.UIComponent;
    import javax.faces.context.ExternalContext;
    import javax.faces.context.FacesContext;
    import javax.naming.Context;
    import javax.naming.InitialContext;
    import javax.naming.NamingException;
    import javax.servlet.annotation.MultipartConfig;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import javax.sql.DataSource;

    import com.Lib.AuditLog;
    import com.Lib.InputValidation;
    import com.Lib.WhiteList;
    

    @ManagedBean(name="fileDownloadController")
    @MultipartConfig
    public final class FileDownloader {
        
        // Applications are rarely tested for Unicode exploits, and yet many are vulnerable due to the same sort of issues which allows HTTP Request Smuggling to work – every browser, 
        // web server, web application firewall or HTTP inspection agent, and other device treats user locale handling in different (and usually confusing) manner.
        // Canonicalization deals with the way in which systems convert data from one form to another. 
        // Canonical means the simplest or most standard form of something. Canonicalization is the process of converting something from one representation to the simplest form.
        // Web applications have to deal with lots of canonicalization issues from URL encoding to IP address translation. 
        // When security decisions are made based on less than perfectly canonicalized data, the application itself must be able to deal with unexpected input safely. 
        
        final static Logger logger = Logger.getLogger(FileUploader.class);
        private AuditLog Log = new AuditLog(); 
        private WhiteList wl = new WhiteList();
        InputValidation validate = new InputValidation();
        private UIComponent component;
        private String file;
        private File fileplace;
        
        public FileDownloader() {        
            
            FacesContext context = FacesContext.getCurrentInstance();
            HttpServletRequest request = (HttpServletRequest)FacesContext.getCurrentInstance().getExternalContext().getRequest();
            HttpServletResponse response = (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();  
            
            // Unicode Encoding is a method for storing characters with multiple bytes. Wherever input data is allowed, 
            // data can be entered using Unicode to disguise malicious code and permit a variety of attacks. RFC 2279 references many ways that text can be encoded. 
            
            FacesContext.getCurrentInstance().getExternalContext().setResponseContentType("text/html;charset=UTF8");
            
            String action = ""; 
            boolean proceed = false ;
            String mimetype = "";
            
            // Create path components to save the file
            // The location of stored files should always be outside of your root
            file = "C:\\tsec.jpg";
            fileplace = new File(file); 
            
            String fileNameformat = fileplace.getName();
            
            String filenameparts[] = fileNameformat.split(Pattern.quote("."));
            String fileName = filenameparts[0];
            String afterdot = filenameparts[1];
            
            /*
            First we check if the value is alphanumeric only to prevent uploading out of intended directory, 
            as well as other injections
            */
            
            /* in normal situations the userID should be retrieved from session or from the web page made the request. 
            * For demonstration purposes we assume that the usedID is always 2, which indicated the Administration ID number. 
            */
            
            if (validate.validateInput("2", fileName, "alphanumeric", "validation failed",request.getRemoteAddr(),"HIGH") == "validation failed")
            {
            proceed = false;
            action = "validation failed";
            }
            
            else if (validate.validateInput("2", fileName, "alphanumeric", "Session Termination",request.getRemoteAddr(),"HIGH") == "terminate")
            {
                proceed = false;
                action = "terminate";
            }   
            
            else if (validate.validateInput("2", fileName, "alphanumeric", "Block access",request.getRemoteAddr(),"HIGH") == "block")
            {
                proceed = false;
                action = "block";
            }else{
                Log.SetLog("2", "Validated Successfully" , "SUCCESS", LocalDateTime.now(),request.getRemoteAddr(),  "");
                action = "Validated Successfully";
                proceed = true;
            }
            
            if (proceed == true)
            {
                //Here we connect to the database by means of a connection string as configured in the web.xml and /METAINF/context.xml 
                Connection conn = null;
                try {
                            
                    Context initContext = new InitialContext();
                    Context webContext  = (Context)initContext.lookup("java:/comp/env");
                    DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
                    conn = ds.getConnection();  

                    //Here we select the number of counts from aggregate column in order to verify the number of connections:
                    String query = "SELECT * FROM privileges WHERE privilegeID=?";
                
                    PreparedStatement st = conn.prepareStatement(query);
                    
                    /* in normal situations the privilegeID should be retrieved from database based on UserID retrieved from the active session 
                    * or from the web page made the request. 
                    * For demonstration purposes we assume that the privilegeID is always 1, which indicated the Administration privilege ID number. 
                    */
                    st.setString(1, "1");

                    // execute the query, and get a java result set
                    //We bind the parameter in order to prevent SQL injections
                    ResultSet rs = st.executeQuery();
                    
                    while (rs.next())
                    {
                        mimetype   = rs.getString("mimeType");
                    }
                    st.close();
                    conn.close();
                } catch (SQLException | NamingException e) {
                    logger.error("cannot read from database. check query :" e.toString());
                }     

                /*
                We also define the mimetype per download file.
                This is because whenever a user can only download images it is not necessary to set
                an uncommon contenttype header for it.
                NOTE: These mimetypes should not be stored based upon the mimetype which was send 
                the response header when the user uploaded the file. This value can be easily 
                manipulated with an intercepting PROXY. You should get the mimetype from the file
                itself after it was stored on the server.
                */
                response.reset();
                response.setContentType(mimetype);
                response.addHeader("CacheControl", "nocache");
                response.addHeader("ContentDisposition", "attachment; filename=" + fileName + "." + afterdot + ";");
                
                OutputStream out;
                try {
                    out = response.getOutputStream();
                    
                    FileInputStream in = new FileInputStream(fileplace);
                    byte[] buffer = new byte[4096];
                    int length;
                    while ((length = in.read(buffer)) > 0){
                        out.write(buffer, 0, length);
                    }
                    in.close();
                    out.flush();   
                } catch (IOException e) {
                    logger.error("Cannot download file  " e.toString());
                }
            }
            else if (file == null)
            {
                action = "empty";
            }
            
            if (action.equals("terminate"))
            {
                request.getSession().invalidate();
                request.setAttribute("msg","Session terminated! file has not been downloaded");             
                ExternalContext ec = FacesContext.getCurrentInstance().getExternalContext();
                try {
                    ec.redirect(ec.getRequestContextPath() + "/Menu.xhtml");
                } catch (IOException e) {
                    logger.error("Cannot redirect  " e.toString());
                }
            }
            if (action.equals("validation failed"))
            {
                request.getSession().invalidate();
                context.addMessage(component.getClientId(), new FacesMessage(FacesMessage.SEVERITY_ERROR, "FAIL!", "Session terminated! file has not been downloaded"));
            }
            if (action.equals("block"))
            { 
                request.getSession().invalidate();          
                context.addMessage(component.getClientId(), new FacesMessage(FacesMessage.SEVERITY_ERROR, "FAIL!", "Session terminated with Blocked Access! file has not been downloaded"));
            }
            if (action.equals("Validated Successfully"))
            {
                context.addMessage(component.getClientId(), new FacesMessage(FacesMessage.SEVERITY_ERROR, "SUCCESS!", "file downloaded"));   
            }
        }
        
        public String getFile() {
            return file;
        }

        public void setFile(String file) {
            this.file = file;
        }

        public void fixedDownloads(String file, String download, HttpServletResponse response)
        {
            /*
            The second example is for whenever you are providing users with fixed downloads
            such as manuals etc. We do not only check if the file just exists, because that would
            allow an attacker to also download important other files from your server, so instead
            we whitelist them.
            */
            if (wl.WhiteListing(file, download) != false)
            {
                response.reset();
                response.setContentType("text/plain");
                response.addHeader("CacheControl", "nocache");
                response.addHeader("ContentDisposition", "attachment; filename=" + file + ";");
                
                OutputStream out;
                try {          
                    out = response.getOutputStream();
                    FileInputStream in = new FileInputStream(file);
                    byte[] buffer = new byte[4096];
                    int length;
                    while ((length = in.read(buffer)) > 0){
                        out.write(buffer, 0, length);
                    }
                    in.close();
                    out.flush();
                } catch (IOException e) {
                    logger.error("Cannot download file  " e.toString());
                }   
            }   
        }
    }

','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (82,'Identifier based authorization',' Identifierbased authorization


 Example:


	package com.edw;

	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.time.LocalDateTime;

	import javax.naming.Context;
	import javax.naming.InitialContext;
	import javax.naming.NamingException;
	import javax.sql.DataSource;

	import org.apache.log4j.Logger;

	public final class IdentifierBased {

		private int userID;
		private String name;
		private String email;
		private String phone;
		final static Logger logger = Logger.getLogger(IdentifierBased.class);
		/*
		First we include the audit log class.
		For more detailed information see the Auditlog code example
		*/
		AuditLog Log = new AuditLog();
		
		/*
		We then do the same for aggregate user controls.
		For more detailed information see the Aggregate user control code example
		*/
		Aggregate aggregate =  new Aggregate();
		
		InputValidation validate = new InputValidation();
		
		/* 
		the following function return a String value that informs the appropriate 
		SERVLET to take actions such as terminate the session or take logs about 
		a certain action such as user blocking
		The following SERVLET is an example of such behavior
		
		* protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 
		{
			userID = request.getParameter("userID");
			name = request.getParameter("User");
			
			IdentifierBased au = new IdentifierBased() ;
			String auth = au.IdentifierBasedAuthentication(pageID, userID, name);
			
			if (auth.equals("terminate"))
			{
				request.getSession().invalidate();
				request.setAttribute("msg","FAIL! Session terminated!");
				request.getRequestDispatcher("/login.jsp").forward(request, response);
				return;
			}
			
			else if (auth.equals("block"))
			{
				request.getSession().invalidate();
				request.setAttribute("msg","FAIL! User Blocked!");
				request.getRequestDispatcher("/login.jsp").forward(request, response);
				return;
			}
		}	
		* 
		* 
		*/
		
		public String IdentifierBasedAuthentication(int pageID, String user_id, String username)
		{	
			String page  = new Integer(pageID).toString();
			String identifier = "null" ; 
			/*
			First we validate if the incoming value is in fact an integer since we expect a page id number.
			If the incoming value is not a number we lockout the users since he tries to manipulate application operation.
			*/

			boolean doFunction = true;
			//see the "input validation" code example for more detailed information about this function
			if (validate.validateInput("", page, "numeric", "Failed to get file", "HIGH") == false) { doFunction = false; }
			
			if (doFunction == false)
			{
				//First we log the fact we detected a tampering in the application operation
				Log.SetLog(user_id, "User tried to manipulate application operation", "FAIL", LocalDateTime.now(),"","HIGH");

				/*
				Set counter; if counter hits 3, the user''''s session must be terminated.
				After 3 session terminations the user''''s account must be blocked. 
				Given the high threat level, there will be immediate session termination.
				*/
				String validation = Log.counter(3);	
				
				//the following values will be used from the SERVLET in order to handle session terminations or user blocking 
				if (validation.equals("SQL insert query error in update access" )){
						Log.SetLog(user_id, "" , "SQL insert query error in update access", LocalDateTime.now(),"",  "");
				}
				if (validation.equals("block")){
					Log.SetLog(user_id, "" , "block", LocalDateTime.now(), "",  "HIGH");
					identifier = "block";
				}
				if (validation.equals("terminate")){
					Log.SetLog(user_id, "" , "terminate", LocalDateTime.now(), "",  "HIGH");
					identifier = "terminate";
				}
			}
			
			if (doFunction == true)
			{
				//the page retrieval has to be reported into the log files
				Log.SetLog(user_id, "Connection to the database was made successfully", "SUCCESS", LocalDateTime.now(),"","");

				//We also count the connection to the database.
				aggregate.aggregateControl(1,username , user_id);

				/* 
				Whenever you are checking whether a user is restricted to review certain data,
				the access restrictions should be processed from the server.
				
				The userID could be stored inside a session variable on login, and should
				be used to retrieve user data from the database when requested
				
				in order to verify if the user is allowed to look into that data:
				*/

				//Here we connect to the database by means of a connection string as configured in the web.xml and /METAINF/context.xml 
				Connection conn = null;
					try {
		
						Context initContext = new InitialContext();
						Context webContext  = (Context)initContext.lookup("java:/comp/env");
						DataSource ds = (DataSource)webContext.lookup("jdbc/myJdbc");
						conn = ds.getConnection();	
						
						//We also count the connection to the database.
						aggregate.aggregateControl(1,username , user_id);
					
						/* Here we select the users privilege level from the users table */
						String query = "SELECT * from profile WHERE userID = ? ";
					
						//execute the query, and get a java result set
						//We bind the parameter in order to prevent SQL injections
						PreparedStatement st = conn.prepareStatement(query);
						st.setInt(1, userID);
						
						//Next we read the value from the database and put it into a variable
						ResultSet rs = st.executeQuery();
						
						while (rs.next())
						{
							name  = rs.getString("name");
							email = rs.getString("email");
							phone = rs.getString("phone");
						}
						
						st.close();
						conn.close();
				
					} catch (SQLException | NamingException e) {
						logger.error("cannot search database. check query" + e.toString() );
					}
			
				this.setEmail(email);
				this.setName(name);
				this.setPhone(phone);
			}
			return identifier;
		}

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public String getEmail() {
			return email;
		}

		public void setEmail(String email) {
			this.email = email;
		}

		public String getPhone() {
			return phone;
		}

		public void setPhone(String phone) {
			this.phone = phone;
		}
	}
    ','java-needs-reviewing',1);
INSERT INTO "code_items" VALUES (83,'X XSS Protection header',' XXSSProtection header


 Example:


    <?php

    //In order to set the XXSSProtection header, you''''ll have to add the following code to the head of your application:
    header("XXSSProtection:1; mode=block");

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (84,'Enforce secure passwords',' Enforce secure passwords


 Example:


    <?php

	class passwordPolicy{
		public function createPassword($pwd){
			$proceed = true;

			//Recommended to use a small phrase instead of a password:
			if(strlen($pwd) < 8 ){
				$error .= "Password too short!";
				$proceed = false;
			}

			$pattern = array("/[09]+/","/[az]+/","/[AZ]+/","/\W+/");		

			/*
			The password should include at least one number, a small letter, a CAPS,
			and a special character as defined in the patterns array:
			*/
			foreach($pattern as $value){
				if(!preg_match($value, $pwd)){
					$error .= "Password incomplete";
					$proceed = false;
				}
			}

			/*
			Even though your password is sufficient according to all your standards, the password could still be weak.
			Just imagine the password "Password!"; this could easily be guessed by an attacker. To prevent the use of weak passwords we
			compare the password with a list of top 500 bad passwords and if matched, the password wil be rejected:
			*/
			$file = file_get_contents(''''badpasswords.txt'''');

			$pattern = explode('''','''', $file);

			foreach($pattern as $password){
				if(preg_match($password, $pwd)){
					$error .= "Your password was matched with the bad password list, please try again.";
					$proceed = false;
				}
			}

			if($proceed == true){
				echo "Your password is allowed!";
				return true;
			}else{
				echo "Password validation failure(your choice is weak): $error";
				return false
			}				
		}
	}
			
    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (85,'Re authentication',' Reauthentication


 Example:


    <?php

	/*
	Whenever a user wants to change his credentials or do other important data exchanges such as
	transferring money he should always be challenged to reauthenticate himself before
	allowing them to perform these actions.
	*/

	class challengeUser{
			public function reauthenticate($password){

			//init DB connection
			include("classes.php");
			$con     = new database();
			$logging = new logging();

			$db = con>connection();

			//PDO prepared statement in order to prevent SQL injections        
			$stmt = $db>query("SELECT * FROM members WHERE id = :userID ");

			//We than bind the parameters in order to prevent SQL injection;
			$stmt>execute(array('''':userID''''=>$_SESSION[''''userID''''] ));


			$loginUser = $stmt>fetchAll(PDO::FETCH_ASSOC);

			/*
			Than we validate the password, if the validation is true than we set the sessions
			For more detailed information on password validation check please look into the
			Password storage(salting/stretching/hashing) in the knowledgebase for more information.
			*/
			if($this>ValidatePassword($loginUser[''''password''''], $password) === true){

				//After successful validation we want to log that Password was validated successfully:
				setLog($_SESSION[''''userID''''],"Password return true", "SUCCESS", date(ddmmyyyy), $privilege, "NULL");

				session_start();

				//Change the session id on login
				session_regenerate_id(true);

				//Here we set a session to see if the user is authenticated throughout the system
				$_SESSION[''''access'''']   = "active";

				/*
				The userID in a session variable to use as an identifier to prevent a user reading
				into unauthorized data, See Identifierbased authorization for more information and
				code examples.
				*/

				$_SESSION[''''userID'''']   = $loginUser[''''id''''];

				//The CSRF token is set here by an approved random number generator
				$_SESSION[''''csrf''''] = base64_encode(openssl_random_pseudo_bytes(128));

				//if all is ok we return loginUser values
				return true;

			}else{

				//The user failed reauthenticating himself
				$logging>setLog($_SESSION[''''userID''''],"Reauthentication failed", "FAIL", date("dmy"), "null", "MOD");

				//If the authentication fails we destroy the session
				session_start();
				session_destroy();

				//Regenerate the session ID to lock out an attacker!
				session_regenerate_id(true);
				$_SESSION[''''active''''] = "";

				header("location:login.php");

				die();           	
			}
		}
	}

	/*
	Before we let a user perform certain actions he should first be challenged to authenticate
	himself. imagine the following scenario, the user wants to change his email address.
	*/

	$challenge =  new challengeUser()
	if($challenge>reauthenticate() !== true){

		echo "please reauthenticate yourself";
		echo
		"
		<form method=''''post''''>
		<input type=''''password'''' name=''''password''''/>
		<input type=''''submit'''' name=''''authenticate''''/>
		</form>		
		";

	}else{

		//Do operation for changing the email address
		echo "You can now change your email address!";
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (86,'XSL injection prevention',' XSL injection prevention


 Example:


    <?php

	/*
	In order to prevent XSL injections you must enforce strict policy''''s whenever the
	files are loaded from a source controlled by an possible attacker.

	Let''''s say for example that the user can choose from several XSL files on your application.

	ABC.xsl arranges your employee names on alphabetical order
	CBA.xsl does not care and just shows the input by order of your XML file.

	Before we want to attach the XSL files to the style sheet we first want to
	do validation on the request to make sure the included file was one of our own pre
	defined files, example:
	including("file1.xsl,file2.xsl,etc", $_GET[''''xslfile''''], "3")
	*/

	class includeXSL{
		public function including($whiteListing, $inputParam, $countLevel){

			//Include the classes of which you want to use objects from
			include_once("classes.php");

			$whitelist = new whitelisting();

			$continue = true;

			/*
			We want to whitelist the paged for expected values, in this example they are,
			page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
			*/
			if($whitelist>checkpattern($whiteListing, $inputParam, $countLevel) == false)
			{$continue = false;}

			//If all went good we do the function
			if($continue == true){
				 LOAD XML FILE
				// Load the XML source
				$xml = new DOMDocument;
				$xml>load(''''test.xml'''');

				$xsl = new DOMDocument(''''1.0'''',''''UTF8'''');
				$xsl>load($inputParam);

				// Configure the transformer
				$proc = new XSLTProcessor;
				$proc>importStyleSheet($xsl); // attach the xsl rules

				echo $proc>transformToXML($xml);
			}
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (87,'Session cookies (domain)',' Session cookies (domain)


 Example:


    <?php

	/*
	Whenever a session is started, and you want to share it over different domains,
	the domain value should be set to the specific domain:
	*/

	public function sessionStart(){

		$lifetime = 3600;
		$path     = "/";
		$domain   = "demo.yourdomain.com";  // <  the Configure domains, do not use .yourdomain.com (wildcard) this increases the attack surface!

		$secure   = 0;
		$httponly = true;

		session_set_cookie_params($lifetime, $path, $domain, $secure, $httponly);
	}

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (88,'Directory listing',' Directory listing


 Example:


    <?php

	/*
	To disable or prevent directory access, add following line in your .htaccess file. If
	user points the browsers to a directory that does not have an index file, then a
	"403 Forbidden" error will be displayed:

	Add this line of code to your .htaccess file:
	*/

	Options Indexes

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (89,'',' Secure use of mail function


 Example:

    /*
    PHP comes with the builtin function mail() for sending emails from a PHP application. The mail delivery can be configured by using the following five parameters.

    http://php.net/manual/en/function.mail.php

    bool mail(	
        string $to, 
        string $subject,
        string $message [, 
        string $additional_headers [, 
        string $additional_parameters ]]
    )
    In order to use the mail() function in PHP, an email program or server has to be configured. The following two options can be used in the php.ini configuration file:

    1)Configure an SMTP server’s hostname and port to which PHP connects
    2)Configure the file path of a mail program that PHP uses as a Mail Transfer Agent (MTA)

    When PHP is configured with the second option, calls to the mail() function will result in the execution of the configured MTA program. Although PHP internally applies escapeshellcmd() to the program call which prevents an injection of new shell commands, the 5th argument $additional_parameters in mail() allows the addition of new program arguments to the MTA. Thus, an attacker can append program flags which in some MTA’s enables the creation of a file with usercontrolled content.
    */

   	<?php

        /* 
        It is important that user input should not be passed into the fifth parameter of the mail() function.

        Since first 4 parameters can get added to logs, it is important that they should not contain  any php code

        !preg_match( "/[\r\n]/", $additional_parameters ) is used to mitigate any header injection attack

        Below code is implemented considering all 5 parameters are user controllable
        */

       if(!strpos($to, ''''<?'''') && !strpos($subject, ''''<?'''') && !strpos($message, ''''<?'''') && !strpos($additional_headers, ''''<?'''') && !strpos($additional_parameters, ''''<?'''') && !preg_match( "/[\r\n]/", $additional_parameters )){

           /*
           A PHP function is used to escape commandline arguments, which replaces escapeshellarg with more robust methods for both Windows and nonWindows platforms. 
           Install it from https://packagist.org/packages/winbox/args
           */

           mail(Winbox\Args::escape($to), Winbox\Args::escape($subject), Winbox\Args::escape($message), Winbox\Args::escape($additional_headers), Winbox\Args::escape($additional_options));

       }

       /*
        If fifth parameter is user controllable this implementation does not stop an attacker to append program flags which in some MTA’s enables the read and creation of a file.
        
        Hence additional checks should be implemented for the type of input expected in fifth parameter
        */

    ?>','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (90,'RFD and file download injection prevention',' Reflective file download and file download injection prevention


 Example:


	<?php

	//include all necessary classes
	include_once("class/classCollect.php");

	class fileDownload{
		/*
		The first example we cover how to download files which users can upload
		themselves on the web application
		*/

		public function downloadUserFiles($fileID){		

			$conn = new NewDatabase();
			$db   = $conn > connection();
			$validation = new validation();
			$proceed = true;

			/*
			For the sake of example we only allow the users to download their own files
			by identifier based sql query''''s. As you can see we select the filename
			by its id. in this case we prevent direct user input into the disposition header.
			*/

			if($validation>inputValidation($fileID, "numeric", "validate was false", "HIGH", 3) == false){
				$proceed = false;
			}

			if($proceed == true){
				$stmt = $db>prepare("SELECT * FROM download WHERE fileID=? AND userID=?");
				$stmt>execute(array($fileID, $_SESSION[''''userID'''']));
				$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

				foreach($rows as $row){
					$filename = $row[''''fileName''''];
					$mimeType = $row[''''mimeType''''];
				}

				if($filename){
				/*
				We also define the mimetype per download file.
				This is because whenever a user can only download images it is not necessary to set
				an uncommon contenttype header for it.
				NOTE: These mimetypes should not be stored based upon the mimetype which was send
				the response header when the user uploaded the file. This value can be easily
				manipulated with an intercepting proxy. You should get the mimetype from the file
				itself after it was stored on the server.
				*/
				header(''''ContentDescription: File Transfer'''');
    			header("contenttype:".$mimeType."");
    			header(''''ContentDisposition: attachment; filename=''''.$filename);
    			header(''''Expires: 0'''');
				header("CacheControl: nostore, nocache, mustrevalidate, maxage=0");
				header("CacheControl: postcheck=0, precheck=0", false);
				header("Pragma: nocache");    
				header(''''ContentLength: '''' . filesize($filename));
				//Last check to see if it really does exist.
				if(file_exists($filename)){
					readfile($filename);
				}
				/*
				Exit is very important, if other mechanims fail this makes sure the rest
				of the page plus attack string does not get downloaded anyways.
				*/
				exit;
				}
			}
		}

		/*
		The second example is for whenever you are providing users with fixed downloads
		such as manuals etc. We do not only check if the file just exists, because that would
		allow an attacker to also download important other files from your server, so instead
		we whitelist them.
		*/
		public function downloadStored($filename){

			$white = new whitelisting();

			if($white > checkpattern("file1.txt,file2.txt", $filename, 3) != false){
				header(''''ContentDescription: File Transfer'''');
    			header(''''ContentType: text/plain'''');
    			header(''''ContentDisposition: attachment; filename=''''.$filename);
    			header(''''Expires: 0'''');
				header("CacheControl: nostore, nocache, mustrevalidate, maxage=0");
				header("CacheControl: postcheck=0, precheck=0", false);
				header("Pragma: nocache");    
				header(''''ContentLength: '''' . filesize($filename));
				if(file_exists($filename)){
					readfile($filename);
				}
				/*
				Exit is very important, if other mechanims fail this makes sure the rest
				of the page plus attack string does not get downloaded anyways.
				*/
				exit;
			}
		}
	}

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (91,'X Content Type Options header',' XContentTypeOptions header


 Example:


    <?php

    //In order to set the "XContentTypeOptions" header you''''ll have to add the following code to the head of your application:
    header(''''XContentTypeOptions: nosniff'''');

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (92,'Audit logs',' Audit logs


 Example:


    <?php

	/*
	The log function does not have to be complicated as long as you log at least these 6 values

	Whenever a user is registered or added to your system, the application must also
	automatically generate a table for this user which contains his userID, counter and blocker
	variable in order to keep track of his behavior.
	*/

	class logging{
		public function setLog($userID, $errorMessage, $value, $date, $privilege, $threat){

			//Save log file in a directory which has restrictions in place so no one can access it easily
			$myFile = "restrictedfolder/logfile.txt";

			$fh = fopen($myFile, ''''a+'''') or die("can''''t open file");

			//Notice how we user the userID instead of the actual username in order to prevent the integrity of these usernames
			//should an attacker ever gain access to these log files
			$stringData = $date." ".$userID." ".$errorMessage." ".$value." ".$privilege." ".$threat." \n" ;

			fwrite($fh, $stringData);
			fclose($fh);
		}

		public function setCounter($count){

			include("classes.php");

			//init DB connection
			$con  = new database();
			$db = $con>connection();


			//Here we select all data to verify if the users session should be terminated or his account should be lockedout
			$stmt = $db>prepare("SELECT count, blocker FROM counter WHERE userID=:id");
			$stmt>execute(array($_SESSION[''''userID'''']));
			$row = $stmt>fetchAll(PDO::FETCH_ASSOC);

			foreach($row as $rows){

				//First we update the count/blocker variable with the old values for the update
				$dbCount   = $rows[''''count''''];
				$dbBlocker = $rows[''''blocker''''];

			}

			$countUpdate   = $count + $dbCount;
			$blockerUpdate = $count + $dbBlocker;

			//Here we want to set a counter for whenever a user attacks the application so we can lockout his account
			//when there are to many violations registered.
			$stmt = $db>prepare("UPDATE counter SET count=?, blocker=? WHERE userID=?");
			$stmt>execute(array($countUpdate, $blockerUpdate, $_SESSION[''''userID'''']));
			$affected_rows = $stmt>rowCount();

			//If the users counter was bigger than three his session should be terminated
			if($countUpdate >= 3){

				//Log that the users sessions have been terminated:
				setLog($_SESSION[''''userID''''],"The users session was terminated", "SUCCESS", date(ddmmyyyy), $privilege, "NULL");

				//Clear the session variable to deny access
				$_SESSION[''''accessor''''] = "";
				session_start();
				session_destroy();

				$countUpdate = 0;
			}


			//If the users counter was bigger than three his session should be terminated
			if($blockerUpdate >= 12){

				//Log that the users has been denied access to system:
				setLog($_SESSION[''''userID''''],"The users is denied access to system", "SUCCESS", date(ddmmyyyy), $privilege, "NULL");

				//If the blocker was bigger than 12 it means the user has made three strikes and his account should blocked
				$status = "blocked";
				$stmt = $db>prepare("UPDATE users SET status=? WHERE userID=?");
				$stmt>execute(array($status, $_SESSION[''''userID'''']));
				$affected_rows = $stmt>rowCount();

				//Clear the session variable to deny further access
				$_SESSION[''''accessor''''] = "";
				session_start();
				session_destroy();
			}

			//After the counter has terminated a session he should be set to zero again
			$stmt = $db>prepare("UPDATE counter SET count=? WHERE userID=?");
			$stmt>execute(array($countUpdate, $_SESSION[''''userID'''']));
			$affected_rows = $stmt>rowCount();

		}
	}
	
  	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (93,'CSRF tokens',' CSRF tokens


 Example:


	<?php

	class CSRF{

		public function generateToken(){
			/*
			After successful user authentication, the application must start a session
					which contains the "Cross Site Request Forgery(CSRF)" token.
			*/

			$_SESSION[''''csrf''''] = base64_encode(openssl_random_pseudo_bytes(128));
		}

		/*

		The random CSRF token generated need to be send to the server with every form submission.
		This token is included in a form as a HTML hidden form field parameter. When the form is
		submitted the token value is also submitted along with it.

		The token is then validated against the csrf token which was generated during user authentication.
		Below code demonstrate the validation of csrf token at the server side:

		*/

		protected function _checkCsrf($token){        
			session_start();                    

			if($_SESSION[''''csrf''''] != $token){        

				//Log the invalid token verification
				setLog($_SESSION[''''userID''''],"invalid CSRF token send!", "FAIL", date("dmy"), $_SESSION[''''privilege''''], "HIGH");

				//If the token was not valid we terminate the users session
				session_start();
				session_destroy();                   

				//The die function is to make sure the rest of the php code is not executed beyond this point
				die();        
			}    
		}  
	}   
	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (94,'Logout function',' Logout function


 Example:


	<?php

	/*
	This way, the logout functionality will revoke the complete session:
	*/

	public function deleteLogin(){

		//We first want to log the user logging out.
		setLog($_SESSION[''''userID''''],"User logout", "SUCCESS", date("dmy"), $_SESSION[''''privilege''''], "NULL");

		//We empty his authentication session
		$_SESSION[''''Authenticated''''] = "";

		//Than we destroy the entire session
		session_start();
			session_regenerate_id(true);
		session_destroy();
	}

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (95,'Timeout a session',' Timeout a session


 Example:


    <?php

	public function sessionStart(){

		$lifetime = 3600; // < lifetime of a session
		$path     = "/";
		$domain   = "www.example.com";
		$secure   = 0;
		$httponly = true;

		session_set_cookie_params($lifetime, $path, $domain, $secure, $httponly);

	}

	/*
	You could also set the session cookie its secure function with a ini_set
	This ini_set has to be included in the header of al your pages in order to work
	*/

	ini_set(''''session.cookie_lifetime'''', 3600);

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (96,'White listing',' Whitelisting


 Example:


    <?php

	class whitelisting{

		/*
		First we create a function which checks the allowed patterns:
		checkpattern("value1,value2,value3" , $input, "3")
		*/
			function checkpattern($allowed, $input, $countLevel){

			$logging = new logging();
			$result  = explode("," , $allowed);

			$results = false;

			foreach($result as $pattern){
				while(preg_match("/^".$pattern."$/", $input)){		
					//If the value is valid we send a log to the logging file.        
					$logging>setLog($_SESSION[''''userID''''],"Good whitelist validation",
					"SUCCESS", date("dmy"),"null", "HIGH");

					$results = true;

					//Whenever there was a valid match we return true      			
					return true;
				}
			}

			//Check for a false in order to send error to log and counter the user.
			if($results == false){
				//If the value is invalid we send a log to the logging file.        
				$logging>setLog($_SESSION[''''userID''''],"Bad whitelist validation",
				"FAIL", date("dmy"), $_SESSION["privilege"], "HIGH");

				$logging>setCounter($countLevel);
				return false;		
			}
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (97,'Session hijacking and fixation',' Session hijacking and fixation


 Example:


   	<?php

	/*
	As soon as a user logs into your application you must store his session id as well as his
	IP address along with his userID. This information will be used later on in your application in order to
	identify possible session hijacking.

	TABLE track_sessions
	
	| TrackID | userID |		   	   SESSION 	                |   Ip address	    |
	
	|   1     | 1      | 	79dcd529c0f5e01a9bfb2425c52036c6    |	123.45.67.89    |   
	
	|   2     | 1      | 	79dcd529c0f5e01a9bfb2425c52036c6    |	123.45.67.81    |
	
	|   3     | 2      | 	c80959d3ea4c166413774e45375ac2a1    |	987.65.43.21    |
	

	In order to prevent session hijacking there are a couple of defense strategies
	which combined are a hardened defense.  
	*/

	/*
	First we implement the strict transport security header, this is in order to prevent
	users from accessing your application over an unprotected connection.
	*/

	//Example of the strict transport security header:
	header(''''StrictTransportSecurity: maxage=31536000'''');


	//If all present and future subdomains will be HTTPS:
	header(''''StrictTransportSecurity: maxage=31536000; includeSubDomains'''');

	/*
	Recommended: If the site owner would like their domain to be included in the HSTS preload
	list maintained by Chrome (and used by Firefox and Safari), then use:
	*/

	header(''''StrictTransportSecurity: maxage=31536000; includeSubDomains; preload'''');

	/*
	The `preload` flag indicates the site owner''''s consent to have their domain preloaded.
	The site owner still needs to then go and submit the domain to the list. the preload list
	enforces the browser to always present your application on HTTPS even on the first time
	the user hits your application
	*/

	/*
	Then we set the httpOnly flag
	(see "HttpOnly" in the code examples for more details about implementation)
	*/
	ini_set(''''session.cookie_httponly'''', 1);

	/*
	Then we set the flag for session timeout
	(see "Timeout" in the code examples for more details about implementation)
	*/
	ini_set(''''session.cookie_lifetime'''', 3600);

	/*
	Then we set the session secure flag
	(see "Secure flag" in the code examples for more details about implementation)
	*/
	ini_set(''''session.cookie_secure'''', 1);

	/*
	On login we change the session id in order to prevent session fixation
	(see "Login functionality" in the code examples for more details about implementation)
	*/
	session_regenerate_id(true);

	/*
	NOTE: On applications that require high level security, there should never be an
	remember me functionality implemented.
	*/


	/*
	Now imagine the scenario after the login of the user (see the "login functionality" in
	the code examples for more details). Whenever the user is logged in, the users IP address
	and session id are also stored in the database these values are used in order to verify
	if there are multiple users active on the same session.
	If so, we can let the user decide to terminate the session and terminate the
	other assigned sessions.
	*/
	class sessionCheck{
			//We implement this logic into our checksession functionality
			public function _checkSession(){

			//init a DB connection
			include("classes.php");
			$con = new database();
			$db = $con >connection()

			//Here we check for a valid session to see if the user is authenticated
			session_start();
			if(($_SESSION[''''access''''] != "active") || $_SESSION[''''access''''] == ""){
				header("Location: /login");

				/*
				this statement ABSOLUTELY MUST DIE or else an attacker could gain knowledge and abuse
				all your pages and functionality simply by intercepting the response
				from the server when connection to your pages.
				*/

				die();
			}

			/*
			Then we start the rest of the function where we will check if there are multiple
			users/IP addresses using the same session id
			*/

			//store current session id
			$session  = session_id();

			//get users ip address
			$ipaddress = $_SERVER[''''REMOTE_ADDR''''];

			$stmt = $db>prepare("SELECT * FROM track_sessions WHERE userID=:id");
			$stmt>execute(array('''':id'''' => $_SESSION[''''userID'''']));
			$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

				foreach($rows as $row){

					//check to see if the current ip address matches the one stored in login if not warn user!
					if(($ipaddress != $row[''''ipaddress'''']) && $row[''''SESSION''''] != $session){

						echo "
						<div style=''''borderstyle:solid; bordercolor:black; color:white; backgroundcolor:red; float:left;''''>
						<p>There are other active sessions on other IPaddresses.<br/>
						Your session could be hijacked press logout in order to authenticate again
						for security reasons!
						<br/><br/>
						<a href=''''/logout''''>Terminate sessions</a>
						<br/>
						<a href=''''/Proceed''''>Proceed anyway</a>
						</p>
						</div>
						";				
				}
			}			
		}
	}

	/*
	the only thing left to do now is to update your track_sessions table by inserting
	the IP address, sessionID and userID if you want to accept the other sessions as valid.
	Otherwise the user just has to terminate his current session in order to lock out the
	other sessions.
	*/

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (98,'Random password token generation',' Random password/token generation


 Example:


    <?php

	//A good random token example for tokens would be:
	$_SESSION[''''csrf''''] = base64_encode(openssl_random_pseudo_bytes(128));

	//A good random password would be:
	$bytes = openssl_random_pseudo_bytes(15);
	$pwd = bin2hex($bytes);

	/*
	When needing to generate random numbers, always use proven methods
	instead of writing your own.
	*/

	  ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (99,'Directory path traversal',' Directory/path traversal


 Example:


	<?php

	class fileGetContents{ 	
		/*
		Define the whitelist pattern and validation type and input parameter, countLevel like:
		getFiles("page1,page2,etc", "alphanumeric", $_GET[''''filename''''], "3")
		*/
		public getFiles($whiteListPattern, $validationType, $inputParameter, $countLevel){

			//Include the classes of which you want to use objects from
			include_once("classes.php");

			$validate  = new validation();
			$whitelist = new whitelisting();

			$continue = true;

			/*
			First, we want to filter the filenames for expected values. For this example we use only az/09
			Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
			for more information about validation see "input validations" in the code examples:
			*/
			if($validate>inputValidation($inputParameter, $validationType,
			"Invalid user input", "HIGH", $countLevel) == false) {$continue = false;}

			/*
			Second, we want to whitelist the filenames for expected values, in this example they are,
			page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
			*/
			if($whitelist>checkpattern($whiteListPattern, $inputParameter, $countLevel) == false)
			{$continue = false;}

			//If all went good we include the filename
			if($continue == true){
				include($inputParameter);
			}
		}
	}
	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (100,'Input validation',' input validation


 Example:


    <?php

	/*
	This function is where you store al your input validation controls.
	It makes it easy to maintain whenever you want to apply changes for
	certain input validation roles and reduces the chance of mistakes in your regexes.
	*/

	class validation{

		//Our input validation function
		public function inputValidation($input, $type, $logMessage, $threatLevel, $countLevel){

			//Audit log and user lockdown
			$logging = new logging();

			switch ($type) {
				case "numeric":
					$pattern = "/^[09]+$/";
					break;
				case "alphanumeric":
					$pattern = "/^[azAZ09]+$/";
					break;
			}

			if(!preg_match($pattern, $input)){

				/*
				Set a log for whenever there is unexpected user input with a threat level
				See "audit logs" code example for more information:
				*/
				$logging > setLog($_SESSION[''''userID''''], $logMessage, "FAIL", date("dmy"),
				$_SESSION["privilege"], $threatLevel);

				/*
				Set counter if counter hits 3 the users session must terminated
				After 3 session terminations the user account must be blocked
				See "audit logs" code example for more information:
				*/			
				$logging>setCounter($countLevel);

				return false;
				}else{

				//Set a log for whenever there is unexpected userinput with a threat level
				$logging>setLog($_SESSION[''''userID''''],"Valid input validation for regex from ".$type." ",
				"SUCCESS", date("dmy"), $_SESSION["privilege"], "NONE");

				return true;
			}
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (101,'Enforce sequential step order shopping',' Enforce sequential step order (Shopping)


 Example:


    <?php

	/*
	Whenever an functionality consists out of following several steps to achieve some goal i.e,
	"User adds items to chart", "User enters shipping information", "User pays for goods",
	"Items will be shipped." You want to make sure the user can not skip the payment step in
	order to receive his goods.


		    
	| Items  |	|  Cart	 |	|checkout |	 | CostumerInfo	|
		  	 
	|itemID  |	|cartID  |	|PaymentID|  |ConsumerID    |
	|price	 |	|itemID  |	|itemID   |	 |name          |
	|name  	 |	|sessionID|	|Token    |	 |address	    |
		  |sessionID|  |sessionID   	|
							|Verified |  |consumerToken |
							 	 		

	As you can see above we have a very simplified database structure for your average
	web shop. now we can walk through the different steps needed to enforce the user to take
	all steps before payment.

	We wont cover the entire shopping cart functions since that would become a rather big
	example so let''''s cover the basics of enforcing the sequential steps.

	Step1: would be, the user adding items to his cart.

	Step2: would be, the user adding his items to checkout. Whenever he is done shopping
			"add to checkout" generates a random token for the added items which
			are inserted into the payment table in the database


	*/

	//First we build the checktokens function because we want to check the checkout tokens
	//multiple times throughout the steps
	function checkTokens(){
		$stmt = $db>prepare("SELECT * from checkout where sessionID=? ");
		$stmt>execute(array(session_id()));
		$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

		foreach($rows as $row){

			//Here we check for a different token or new session token
			if(($row[''''token''''] != $row[''''token'''']) && ($row[''''token''''] != $_SESSION[''''token''''])){

				$stmt = $db>prepare("DELETE FROM customerinfo WHERE sessionID=:id");
				$stmt>execute(array(session_id()));
				$affected_rows = $stmt>rowCount();

				$stmt = $db>prepare("DELETE FROM checkout WHERE sessionID=:id");
				$stmt>execute(array(session_id()));
				$affected_rows = $stmt>rowCount();

				header(''''location:checkout.php'''');
			}
		}
	}

	//note: As soon as the user visits your website you start sessions in order to assign phpsessionID

	//A random token for every time the form loads
	$token = base64_encode(openssl_random_pseudo_bytes(128));

	/*
	We create a session with the token, if someone adds new items to the checkout this
	token will change and will intercept attackers tampering the system.
	*/


	?>

	<form methods="post">
	<input type="hidden" name="token"  value="<?php echo $token; ?>"/>
	<input type="submit" name="submit" value="add to checkout"/>
	</form>


	<?php

	//On submit we create a new session for the token
	if(isset($_POST[''''submit'''']){
		$_SESSION[''''token''''] = $token;
	}

	/*
	On submit we send al the shopping cart data to another table in the database, but
	this time al the items also contain the same random token. Now an attacker cannot sneak
	in new items since these tokens will be evaluated on the payment page.

	next, the user lands on a page where he has to fill in his customer info:

	NOTE: do not forget the CSRF token in order to prevent attackers from changing his
	shipping info.
	*/

	//First we check the checkout tokens to see if no new items where added.
	checkTokens();

	?>

	<form methods="post">
	<input type="text"   name="customerName" />
	<input type="text"   name="CustomerAddress" />
	<input type="submit" name="submit" value="to payment"/>
	<input type="hidden" name="token"  value="<?php echo $_SESSION[''''csrf'''']; ?>"/>
	</form>

	<?php

	//After submit we first of course check the CSRF token for validity

	checkCsrf($_POST[''''token'''']);

	//Check the checkout tokens to see if no new items where added
	checkTokens();  

	//than we proceed to check if the post values where not empty
	$errors = array();
	$check = true;

	if(empty($_POST[''''customerName''''])){
			$check = false;
			array_push($errors, "Customer name is required");
		}

		if(empty($_POST[''''customerAddress''''])){
			$check = false;
			array_push($errors, "Customer address is required");
		}

		if(!$check){
			echo $errors;
		}
		else{

			header(''''location:summary.php'''');
			//In this step we also insert al the customer data into the database.
		}

	/*
	Then we select al the customer info and shopping items on sessionID from the
	database and display it on screen in order for the user to verify if all the
	information displayed is correct.
	*/

	//when the user has verified we again check the checkout tokens to see if no new items where added
	checkTokens();    

	/*
	After that the user verifies this information then he will be redirected to the payment
	page like ideal, Paypal etc.

	Whenever the payment returns true you set the "verified" column on the checkout
	table to TRUE and you send the customer the invoice and send him his items.
	*/


	$verified = "true";
	$stmt = $db>prepare("UPDATE checkout SET verified=? WHERE sessionID=? and token=?");
	$stmt>execute(array($verified, session_id(), $_SESSION[''''token'''']));
	$affected_rows = $stmt>rowCount();

	//also in this step we clear al the db items matching to the phpsessionid
	$stmt = $db>prepare("DELETE FROM customerinfo WHERE sessionID=:id");
	$stmt>execute(array(session_id()));
	$affected_rows = $stmt>rowCount();

	$stmt = $db>prepare("DELETE FROM checkout WHERE sessionID=:id");
	$stmt>execute(array(session_id()));
	$affected_rows = $stmt>rowCount();

	$stmt = $db>prepare("DELETE FROM cart WHERE sessionID=:id");
	$stmt>execute(array(session_id()));
	$affected_rows = $stmt>rowCount();

	*/

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (102,'System commands',' System commands


 Example:


    <?php

	class systemCommands{ 	

		/*
		Define the whitelist pattern and validation type and input parameter like:
		getFiles("value1,value2,etc", "alphanumeric", $_GET[''''filename''''], "3")
		*/
		public function command($whiteListPattern, $validationType, $inputParameter){

			//Here we include al the necessary classes like audit logs, whitelisting and validation:
			include("classes.php");

			$validate  = new validation();
			$whitelist = new whitelisting();

			$continue = true;

			/*
			Whenever a system command is finished, you should properly sanitize and escape this user input.
			System command functions examples are: system(), eval(), exec()

			First, we want to filter the filenames for expected values. For this example we use only az/09
			Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
			for more information about validation see "input validations" in the code examples:
			*/

			if($validate>inputValidation($inputParameter, $validationType,
			"Invalid user input for system commands", "HIGH", $countLevel) == false) {$continue = false;}

			/*
			Second, we want to whitelist the filenames for expected values, in this example they are,
			page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
			*/

			if($whitelist>checkpattern($whiteListPattern, $inputParameter, $countLevel) == false)
			{$continue = false;}

			//If all went good we include the filename
			if($continue == true){

				//Even though there is a match we still escape the shellcommand:
				$command = ''''./configure ''''.$inputParameter;
				$escaped_command = escapeshellcmd($command);
				//Only after validation do we put the shellcommand into the system() function:
				system($escaped_command);
			}
		}
	}
    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (103,'Session cookies HttpOnly',' Session cookies HttpOnly


 Example:


    <?php

	//Whenever a session is started, the "httpOnly" option should always be set to "true" or "1":

	public function sessionStart(){

		$lifetime = 3600;
		$path     = "/";
		$domain   = "www.example.com";
		$secure   = 0;
		$httponly = true; // <  the httponly flag

		session_set_cookie_params($lifetime, $path, $domain, $secure, $httponly);
	}

	/*
	You could also set the session cookie its httpOnly function with a ini_set
	This ini_set has to be included in the header of al your pages in order to work
	*/

	ini_set(''''session.cookie_httponly'''', 1);

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (104,'SQL query',' SQL query


 Example:


    <?php

	/*
	This example uses a prepared statement in order to insert data into the database.
	Because this method enforces the user to prepare all user input  passed into the query, it always escapes SQL
	injections so none could be accidentally forgotten as with the normal mysqli_real_escape_string() methods.
	*/

	$stmt = $db>prepare("SELECT * FROM table WHERE id=? AND name=?");
	$stmt>execute(array($id, $name));
	$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

	//or		

	$stmt = $db>prepare("UPDATE table SET name=? WHERE id=?");
	$stmt>execute(array($name, $id));
	$affected_rows = $stmt>rowCount();

	//or

	$stmt = $db>prepare("DELETE FROM table WHERE id=:id");
	$stmt>bindValue('''':id'''', $id, PDO::PARAM_STR);
	$stmt>execute();
	$affected_rows = $stmt>rowCount();

	//or

	$stmt = $db>prepare("INSERT INTO table(field1,field2) VALUES(:field1,:field2)");
	$stmt>execute(array('''':field1'''' => $field1, '''':field2'''' => $field2));
	$affected_rows = $stmt>rowCount();

	/*
	All methods will prevent SQL injections.
	The less recommended option for preventing sql injections is to use the mysqli_real_escape_string() function.
	*/

	$username = mysqli_real_escape_string($connectionString, $_POST[''''username'''']);
	$email    = mysqli_real_escape_string($connectionString, $_POST[''''email'''']);

	mysqli_query($connectionString, "INSERT INTO users (username, email) VALUES ("''''.$username.''''", "''''.$email.''''")");

	/*
	NOTE: mysqli_real_escape_string() will _not_ work when escaping integers since the function only
	escapes strings. In order to prevent all SQL injection vulnerabilities, we strongly recommend
	using prepared statements
	*/

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (105,'Open forwards & redirects',' Open forwards & redirects


 Example:


   	<?php

	/*
	When using forwards & redirects you should make sure the URL is being explicitly
	declared in the code and cannot be manipulated by an attacker like:
	*/

	header("location:redirectpage.php");

	/*
	Generally you should avoid getting input into the redirect which could contain
	userinput by any means. if for any reason this may not be feasible than you
	should make a whitelist input validation for the redirect like so:
	send("value1,value2,etc", $_GET[''''redirectParam''''], "3")
	*/

	class redirecting{
		public function send($whiteListing, $inputParam, $countLevel){

			//Include the classes of which you want to use objects from
			include_once("classes.php");

			$whitelist = new whitelisting();

			/*
			We want to whitelist the paged for expected values, in this example they are,
			page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
			*/
			if($whitelist>checkpattern($whiteListing, $inputParameter, $countLevel) == true){
				header("location:".$inputParam."");
			}			
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (106,'X path query',' Xpath query


 Example:

	
    <?php

	class xPathControl{ 	

		/*
		Define the allowed characters and input parameter and count level for the
		user lockout like:
		controller("<''''>&", $_GET[''''filename''''], "3")
		*/
		public function controller($allowedCharacters, $inputParameter, $countLevel){

			//Include the classes where you want to make objects of:		
			include("classes.php");
			$encode = new encodeInput();

			/*
			First we build our encoding method, see "input validation" code example for
			more detailed information about encoding and escaping.
			*/

			$return = $encode>encoder($allowedCharacters, $inputParameter, $countLevel);

			//If the encoder came back false we do not process the function!
			if($return !== false){
				//start a new domdocument

				$xmldoc = new DOMDocument();
				$xmldoc>load(''''test.xml'''');

				$xpathvar = new Domxpath($xmldoc);

				/*
				Assuming that you used the encoder function also for adding users, it will now retrieve the
				user O''''Reilly from the query
				*/

				$queryResult = $xpathvar>query(''''//lemonade[@supplier="''''.$return.''''"]/price'''');

				foreach($queryResult as $result){
						echo $result>textContent;
				}
			}
		}
	}
    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (107,'Anti caching headers',' Anticaching headers


 Example:


	<?php

	/*
	Add the following headers to your application head in order to prevent the browser from caching
	*/

	header("CacheControl: nostore, nocache, mustrevalidate"); // HTTP/1.1
	header("CacheControl: postcheck=0, precheck=0", false);
	header("Pragma: nocache"); // HTTP/1.0

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (108,'Secure session cookies',' Secure session cookies


 Example:


    <?php

	/*
	Whenever  a cookie is sent over a secured connection, the cookie should be set
	with the secure flag, in order to guarantee the integrity of the data it contains.
	The secure flag is set by giving it the "true" or "1" value:
	*/

	public function sessionStart(){

		$lifetime = 3600;
		$path     = "/";
		$domain   = "www.example.com";
		$secure   = true; // < the secure flag
		$httponly = true;

		session_set_cookie_params($lifetime, $path, $domain, $secure, $httponly);
	}

	/*
	You could also set the session cookie its secure function with a ini_set
	This ini_set has to be included in the header of al your pages in order to work
	*/

	ini_set(''''session.cookie_secure'''', 1);

  	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (109,'Crossdomain.xml ',' Crossdomain.xml


 Example:

    			
		// A bad example of a crossdomain.xml would be:
		
		<?xml version="1.0" ?>
		<crossdomainpolicy>
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowaccessfrom domain="*"/>
			<allowhttprequestheadersfrom domain="*" headers="*"/>
		</crossdomainpolicy>

		// Because it allows access from all other domains.
		// Instead of this approach you might want to use the following restrictions.
		// Example by twitter''''s crossdomain.xml:

		<?xml version="1.0" encoding="UTF8"?>
		<crossdomainpolicy xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance" xsi:noNamespaceSchemaLocation="http://www.adobe.com/xml/schemas/PolicyFile.xsd">
			<allowaccessfrom domain="twitter.com" />
			<allowaccessfrom domain="api.twitter.com" />
			<allowaccessfrom domain="search.twitter.com" />
			<allowaccessfrom domain="static.twitter.com" />
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowhttprequestheadersfrom domain="*.twitter.com" headers="*" secure="true"/>
		</crossdomainpolicy>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (110,'Password forget and disallow old passwords',' Password forget & Disallow old passwords


 Example:


    <?php

	/*
	Whenever you are developing a password forget function, these are the steps to follow
	in order to create hardened defenses.

	TABLE users
	
	| userID | userName | password |   EmailAddress	 |    access    |
	   
	|   1    | Admin    | Csdar323 | info@admin.com	 | 	   TRUE	    |
	    	
	|   2    | User	    | Adf4fsv  | info@user.com   |	   FALSE    |
	    
	|   3    | Guest    | dff4fKr  | info@guest.com	 |	   TRUE	    |
	    


	TABLE passwordForget
	   
	| forgotPasswordID | 		Token 	         | 	UserID |   Active	|	  olPasswords   |
	
	|      1           | 	c3ab8ff13720e....	 |	  1	   | 	YES	    |	   Csdar323	    |
	
	|	   2  	       | 	7dd39466b3c89....	 |	  1	   | 	NO	    |		ef0c4f2	    |
	
	|	   3 	       | 	83d4a3960714c....	 |	  3	   | 	NO	    |		dff4fKr	    |
	


	As you can see we also store the old passwords into the password forget table, this
	we do in order to prevent the user from using old passwords later on in the process.

	Also use a cron job to make sure the generated tokens for the password reset are
	expire after a certain amount of time like 20 minutes.
	*/

	class passwordForget{
		public function checkValidity(){

			//init a DB connection
			include("classes.php");
			$con = new database();
			$db = $con >connection()

			$stmt = $db>prepare("SELECT * FROM members WHERE email=?");
			$stmt>execute(array($_POST[''''email'''']));
			$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

			foreach($rows as $row){
				//Here we select the old password as well as the userid from the members table
				$password = $row[''''password''''];
				$userID   = $row[''''id''''];
				$email 	  = $row[''''email''''];
			}

			//If the select was not empty we will be sending an email to the user as well as
			//preparing the password forget function
			if(!empty($rows)){

				echo "An email was sent to your email for password reset";

				/*
				Before we do anything we first set all other possible active statuses to NO
				in order to prevent an attacker creating a whole lot of tokens and than fuzz
				the password reset token.
				*/

				$active = "NO";
				$stmt = $db>prepare("UPDATE forgetPassword SET active=? WHERE userID=?");
				$stmt>execute(array($active, $userID));
				$affected_rows = $stmt>rowCount();

				//Here we generate the password forget token
				$bytes = openssl_random_pseudo_bytes(30);
				$token = bin2hex($bytes);

				$stmt = $db>prepare("
				INSERT INTO forgetPassword
					(token, userID, active, oldPasswords)
						VALUES
							(?, ?, ?, ?)");

				$stmt>execute(array(
				$token,
				$userID,
				''''YES'''',
				$password
				));

				//Here we send an email to the user with the needed reset function
				$msg = "follow this link to reset your password http://example.com/index.php?resetLink=$token";
				mail($email,"Password reset",$msg);
			}else{

				/*
				We show the user the same message in order to prevent the enumeration of
				valid email addresses.
				*/

				echo "An email was sent to your email for password reset";			
			}
		}

		public function resetPassword(){

			//init a DB connection and make objects for hashing and secure password enforcing
			include("classes.php");

			$con  = new database();
			$hash = new passwordHash();
			$pwd  = new passwordPolicy();

			$db = $con>connection()		

			/*
			Imagine the user clicked on his link with the token included and is redirected towards
			the page where he can enter his new password.

			Now we select the information from the forgot password function where the
			forgot tokens matches the token in the database.
			*/

			$active = "YES";

			$stmt = $db>prepare("
			SELECT  a.userID, a.token, b.id
					FROM forgetPassword as a
						JOIN members as b
							ON a.userID = b.id WHERE token=? and Active=? ");

			$stmt>execute(array($_GET[''''resetLink''''], $active));
			$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

			foreach($rows as $row){

				//Here we select token and users id:
				$token  = $row[''''token''''];
				$userID = $row[''''userID''''];

			}

			if($token === $_GET[''''resetLink'''']){

				/*
				First we pull the password through our function which enforces the input of
				secure passwords.(see "Enforce secure passwords" in code examples for more
				detailed information)
				*/

				if($pwd>createPassword($_POST[''''password'''']) === true);

				/*
				Than we encrypt our password
				(see "Password storage" in code examples for more
				detailed information)
				*/

				$hash>createHash($_POST[''''password'''']);

				/*
				Finally we compare the password against other old passwords from the
				password reset database in order to prevent the user from using old passwords
				which could already be compromised by any means.
				*/

				$stmt = $db>prepare("SELECT oldPasswords FROM forgetPassword where userID=?");
				$stmt>execute(array($userID));
				$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

				foreach($rows as $row){

					if($newpassword === $row[''''oldPasswords'''']){
						echo "This was an old password please do not use this password";
					}else{

						//First we update the new password for the user
						$active = "NO";
						$stmt = $db>prepare("UPDATE members SET password=? WHERE userID=?");
						$stmt>execute(array($newPassword, $userID));
						$affected_rows = $stmt>rowCount();

						//Then we destroy the reset token by setting it''''s value to NO
						$stmt = $db>prepare("UPDATE forgetPassword SET active=? WHERE userID=?");
						$stmt>execute(array($active, $userID));
						$affected_rows = $stmt>rowCount();

					}
				}
			}
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (111,'XML External entities',' XML External entities


 Example:

    
	<?php

	/*
	The overall prevention method for loading external entities is adding the following line of code:
	This line of code function tells the underlying libxml parsing to not try to interpret the values
	of the entities in the incoming XML and leave the entity references intact.
	*/

	libxml_disable_entity_loader(true);

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (112,'Anti clickjacking headers',' Anti clickjacking headers


 Example:

            
    /*
  	One way to defend against clickjacking is to include a "framebreaker" script in each
  	page that should not be framed. The following methodology will prevent a webpage from
  	being framed even in legacy browsers, that do not support the XFrameOptionsHeader.
  	In the document HEAD element, add the following:
  	First apply an ID to the style element itself:
  	*/

  	<style id="antiClickjack">body{display:none !important;}</style>
  	//And then delete that style by its ID immediately after in the script:

	<script type="text/javascript">
	if (self === top) {
		var antiClickjack = document.getElementById("antiClickjack");
		antiClickjack.parentNode.removeChild(antiClickjack);
	} else {
		top.location = self.location;
	}
	</script>


  	<?php
    
  	/*
  	The second option is to use "security headers".
  	There are two options for setting the "anticlickjacking" headers in your application:
  	*/

  	//this will completely prevent your page from being displayed in an iframe.
  	header(''''XFrameOptions: DENY'''');


  	//this will completely prevent your page from being displayed in an iframe on other sites.
  	header(''''XFrameOptions: SAMEORIGIN'''');

  	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (113,'Debug enabling',' Debug Enabling


 Example:


    <?php

    /*
    Turn off all error reporting, this method should be included on all your pages.
    We recommend putting it in a main method which is used throughout your entire application.
    */
    error_reporting(0);

    //or
    ini_set(''''display_errors'''',''''Off'''');

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (114,'Login functionality',' Login functionality


 Example:


    <?php

	/*
	For privilege based authentication we need an extra table in your database in order to write the users privileges to.

	TABLE users
	    
	| userID | userName | password | privilegeID |    access	| AggregateControl	|
	   
	| 1	     | Admin    | Csdar323 |      1	     | 	 TRUE       |       2336        |
	   	
	| 2      | User	    | Adf4fsv  |      2	     |   FALSE	    |         0	        |
	   
	|	3	     | Guest	  | dff4fKr  |	  3		     |	   TRUE		|		135			          |
	   

	TABLE privileges
	   
	| privilegeID | privilege        |
	
	|     1       | edit:read:delete |
	
	|     2	      | edit:read        |
	
	|     3       | read             |
	

	Now instead of using roles in sessions we rather want to assign privileges to users
	by means of a DatabaseBased Authentication system.
	Now we can easily assign a user certain privileges for him to access.
	See "Privilege based authentication" code example for more information:
	*/

	class login{
		public function loginUser($username,$password)
		{

			//init DB connection
			include("classes.php");
			$conn = new database();
			$db = $con>connection();

			/*
			You must log invalid user input in order to detect a possible attack on your login form
			In this example the expected input is "aZ/09  _"
			*/

			if(preg_match("/[^azAZ09]/", $username))
			{       
				//Set a log for whenever there is unexpected user input with a threat level
				setLog("null","invalid expected input", "FAIL", date("dmy"), "null", "HIGH");
				header("location:login.php");
				die();
			}

			/*
			We also want to make sure the user access is TRUE, if not, it means the user was blocked
			for attempting to hack the application
			*/

			//After successful validation we want to log that username was validated successfully:
			setLog($_SESSION[''''userID''''],"Username return true", "SUCCESS", date(ddmmyyyy), $privilege, "NULL");

			//PDO prepared statement in order to prevent SQL injections
			$stmt = $db>prepare("
				SELECT a.username, a.password, a.privilegeID, b.privilegeID, b.privilege   
					FROM users as a
						JOIN privileges as b
							ON a.projectID = b.projectID
								WHERE a.username = :username and b.access=''''TRUE''''");

			$this>_setSql($sql);

			$stmt>execute(array('''':page'''' => $_GET[''''page''''], '''':username'''' => $username));
			$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

			foreach($rows as $loginUser){

				/*
				Than we validate the password, if the validation is true than we set the sessions
				For more detailed information on password validation check please look into the
				Password storage(salting/stretching/hashing) in the knowledgebase for more information.
				*/
				if($this>ValidatePassword($loginUser[''''password''''], $password) === true)
				{
					//After successful validation we want to log that Password was validated successfully:
					setLog($_SESSION[''''userID''''],"Password return true", "SUCCESS", date("dmy"), $privilege, "NULL");

					session_start();

					//Change the session id on login
					session_regenerate_id(true);

					//Here we set a session to see if the user is authenticated throughout the system
					$_SESSION[''''access'''']   = "active";

					/*
					The userID in a session variable to use as an identifier to prevent a user reading
					into unauthorized data, See Identifierbased authorization for more information and
					code examples.
					*/
					$_SESSION[''''userID'''']   = $loginUser[''''id''''];

					//The CSRF token is set here by an approved random number generator
					$_SESSION[''''csrf''''] = base64_encode(openssl_random_pseudo_bytes(128));

					//if all is ok we return loginUser values
					return $loginUser;
				}
			}
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (115,'User registration SQL truncation',' User registration / Sql truncation prevention


 Example:


    <?php

	/*
	In order to prevent Column truncation sql injection Solution we have to make sure the
	applications structural logic does not mismatches with the database structural logic.
	To achieve this imagine the follow example of a database structure of a users table

	TABLE users
	
	|	     *Name*        |     *Type*       |    *Extra*     |
	
	|        userID	       |    Int(11)       | AUTO_INCREMENT |
	
	|       Username  	   |    char(21)      |  	           |
	
	|       Password       |  Varchar(255)    |	               |
	
	|      PrivilegeID     |    Int(11)       |                |
	
	*/

	class registerUser{
		//First we create a function in order to select all usernames in order to see of they already exists
		public function userCheck($username){

			//init DB
			$con = new database();
			$db = $con>connection();

			$stmt = $db>prepare("SELECT * FROM members WHERE username = :input");
			$stmt>bindParam('''':input'''', $username, PDO::PARAM_STR);
			$stmt>execute();

			if($stmt>fetch(PDO::FETCH_OBJ) == False){
				//Return true in order to complete registration
				return true;

			}else{
				//The username already exists:
				return false;
			}
		}

		public function userRegister($username, $password, $privID){

			//init DB
			$con  = new database();
			$user = new registerUser();
			$db = $con>connection();

			/*
			Whenever the user gains the ability to register himself or change his user
			credentials you must always enforce the application to compare the length of the
			submitted string against the length of the allowed string length in your database
			structure in order to prevent sql column truncation.
			*/
			$length = strlen($username);

			/*
			We now compare the length of the username against the allowed string length in
			The database structure
			*/

			if($length >= 21){
				//If length is to large the application must die.
				die("Username was to long!");
			}

			//If true than register the user!		
			if($user>Usercheck($username) === true){

				$hash = new passwordHash();

				//Than we encrypt the password with the Bcrypt encryption function of PHP
				$hash>createHash($password);

				//After successful validation we enter the new user into the database
				$stmt = $db>prepare(

				"INSERT INTO users
							(Username, Password, PrivilegeID)
						VALUES
							(?, ?, ?)");

				$stmt>execute(array($username, $hash, $privilegeID));
				$affected_rows = $stmt>rowCount();			
			}else{
				echo "Username already existed";
			}
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (116,'Encoder',' Character encoding


 Example:


    <?php

	/*
	This is the encoder class for whenever you have to allow certain
	possibly dangerous characters into your code for i.e names such as O''''Reilly
	*/

	class encodeInput {
		//As you can see you can specify allowed characters in your function
		public function encoder($allowed, $input, $countLevel){

			//create object for logging class
			$logging = new logging();

			$return = true;

			if(!preg_match("/^[azAZ09 ".$allowed."]+$/", $input)){		

				/*
				Set a log for whenever there is unexpected user input with a threat level
				See "audit logs" code example for more information:
				*/
				$logging>setLog($_SESSION[''''userID''''],"Bad user inputs", "FAIL",
				date("dmy"), $_SESSION["privilege"], "HIGH");

				/*
				Set counter if counter hits 3 the users session must terminated
				After 3 session terminations the user account must be blocked
				See "audit logs" code example for more information:
				*/			
				$logging>setCounter($countLevel);
				$input = false;
			}

			//We also check for the single quote since htmlspecialchar does not encode it
			if(preg_match("/''''/", $input)){
				$input = preg_replace("/''''/", "&39;", $input);
			}

			//We return the input by means of htmlspecialcharacters so it becomes encoded
			return htmlspecialchars($input);
		}
	}//end class

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (117,'Aggregate user controls',' Aggregate user controls


 Example:


    <?php

	/*
	In order to enforce Aggregate access control protection the best method would be to
	define your rules by means of a database structure rather than sessions or log''''s.
	This is due to the fact that if the user drops his session the rating would start
	al over again.

	TABLE users
	   
	| userID | userName | password | privilegeID |    access    | AggregateControl	|
	  
	|   1    | Admin    | Csdar323 |      1      |     TRUE     |     2322         	|
	   
	|   2    | User     | Adf4fsv  |      2      |     FALSE    |     0             |
	  
	|   3    | Guest    | dff4fKr  |      3      |     TRUE     |     125           |
	

	TABLE privileges
	   
	| privilegeID | privilege        |
	
	|     1       | edit:read:delete |
	
	|     2       | edit:read        |
	
	|     3       | read             |
	
	*/

	class aggregateUserControl{
		public function countAccess($count){
			//init DB
			include("classes.php");
			$con     = new database();
			$logging = new logging();
			$db  = $con>connection();

			/*
			Each time the user accesses the database we keep track of the number of times he
			connected. Whenever the user passes a reasonable number he should be rejected
			since he could be an attacker scraping your table contents and stealing company information
			You could a CRON job in your mysql system in order to clean the Aggregate column within certain timeframes
			*/

			//First we log the access
			$logging>setLog($_SESSION[''''userID''''],"User access database ", "SUCCESS", date("dmy"), $privilege, "NULL");

			//After that we select
			$stmt = $db>prepare("SELECT AggregateControl FROM members WHERE userID=:id ");
			$stmt>execute(array('''':id'''' => $_SESSION[''''userID'''']));
			$row = $stmt>fetchAll(PDO::FETCH_ASSOC);

			$aggregate = 0;

			foreach($row as $rows){

				$control = $rows[''''AggregateControl''''];
			}

			//We add the count to control variable for the update
			$control += $count;

			if($control >= 5000){

				//First we log the surpassing of the user control count
				//setLog($_SESSION[''''userID''''],"Aggregate control breach", "FAIL", date("dmy"), $privilege, "HIGH");

				/*
				Then we lock out the users account assuming it has been compromised by
				an attacker.
				*/
				$access = "FAIL";
				$stmt = $db>prepare("UPDATE members SET access=? WHERE userID=?");
				$stmt>execute(array($access, $_SESSION[''''userID'''']));
				$affected_rows = $stmt>rowCount();

			}			

			//Then we update the users table and count +1 tot the AggregateControl column
			$stmt = $db>prepare("UPDATE members SET AggregateControl=? WHERE userID=?");
			$stmt>execute(array($control, $_SESSION[''''userID'''']));
			$affected_rows = $stmt>rowCount();
		}
	}

	//We use the function as follows:
	countAccess(1);

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (118,'Password storage(salting stretching hashing)',' Password storage(salting/stretching/hashing)


 Example:


    <?php

	class passwordHash{
		
		public function createHash($pwd){

			/*
			For the encryption of passwords we use PHP''''s BCRYPT encryption method.
			*/

			//Here we generate a hash with a random salt
			public function HashPassword($password){
				$options = [
				''''cost'''' => 11,
				''''salt'''' => mcrypt_create_iv(22, MCRYPT_DEV_URANDOM),
				];

				$hash =	password_hash($password, PASSWORD_BCRYPT, $options)."\n";

				return $hash;
			}

			//Validate your password
			public function ValidatePassword($correctHash, $password)
			{
			if(password_verify($password, $correctHash))
				{
					//After successful validation we want to log that password was validated successfully:
					setLog($_SESSION[''''userID''''],"Password return true", "SUCCESS", date(ddmmyyyy), $privilege, "NULL");
					return true;
				}else{		
					//We log invalid password use
					setLog($_SESSION[''''userID''''],"Password return false", "FAIL", date(ddmmyyyy), $privilege, "LOW");
					return false;
				}
			}
		}
	}
			
	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (119,'Sandboxing',' Sandboxing


 Example:


    <?php

	<iframe sandbox="value">

		/*
		sandbox=""  Applies all restrictions
		allowforms  Reenables form submission
		allowpointerlock  Reenables APIs
		allowpopups  Reenables popups
		allowsameorigin  Allows the iframe content to be treated as being from the same origin
		allowscripts  Reenables scripts
		allowtopnavigation  Allows the iframe content to navigate its toplevel browsing context
		*/

		?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (120,'Identifier based authorization',' Identifierbased authorization


 Example:


    <?php

	class identifierBasedAuth{ 	

		/*
		Define the whitelist pattern and validation type and input parameter like:
		identity("page1,page2,etc", "alphanumeric", $_GET[''''page''''], "3")
		*/
		public function identity($whiteListPattern, $validationType, $inputParameter, $countLevel){

			//Include the classes of which you want to use objects from
			include_once("classes.php");

			$validate  = new validation();
			$whitelist = new whitelisting();
			$aggregate = new aggregateControl();
			$conn  	   = new database();

			//init DB connection
			$db = $con>connection();

			$continue = true;

			/*
			First, we want to filter the filenames for expected values. For this example we use only az/09
			Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
			for more information about validation see "input validations" in the code examples:
			*/
			if($validate>inputValidation($inputParameter, $validationType,
			"Invalid user input", "HIGH", $countLevel) == false) {$continue = false;}

			/*
			Second, we want to whitelist the filenames for expected values, in this example they are,
			page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
			*/
			if($whitelist>checkpattern($whiteListPattern, $inputParameter, $countLevel) == false)
			{$continue = false;}

			/*
			Whenever you are checking whether a user is restricted to review certain data,
			the access restrictions should be processed server side.
			The userID could be stored inside a session variable on login, and should be used to
			retrieve user data from the database:
			*/
			if($continue == true){

				/*
				We count the number of connections towards the database,
				See "aggregate user controls" code example for more information:
				*/
				$aggregate > countConnections(1);

				$stmt = $db>prepare("SELECT * FROM table WHERE id=:userID AND page=:page");
				$stmt>execute(array('''':page'''' => $_GET[''''page''''], '''':id'''' => $_SESSION[''''userID'''']));
				$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);
			}
		}
	}

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (121,'PHP Object Injection',' PHP Object Injection


 Example:

    
	/*
	Vulnerability occur when unsanitized input is passed into the unserialize function

	<?php

		class foo{
			public $cmd;

			function __destruct()
			{
				system($cmd);
			}

		}

		$data = $_GET[''''data''''];

		$obj = unserialize($data);

	?>

	In the above example user can control the input to the unserialize function, which can lead to change in the $cmd variable which can even result in taking over the server.

	Do not use unserialize() function with usersupplied input, use JSON functions instead.
	We can use json_decode instead of unserialize.
	Otherwise userinput should not be able to control the unserialize function
	
	*/

	// Secure approach for preventing the PHP object injection
	
	<?php

		class foo{
			public $cmd;

			function __destruct()
			{
				system($cmd);
			}

		}

		$data = $_GET[''''data''''];
		$obj = json_decode($data);

	?>	
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (122,'Charsets',' Charsets


 Example:


    <?php

	//Add the following line of code inside the application header:
	//<meta httpequiv="ContentType" content="text/html; charset=utf8">

	//or:
	header(''''ContentType: text/html; charset=utf8'''');

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (123,'Content type headers',' Content type headers


 Example:


    <?php

	//Content type header in php
	header("ContentType:text/html; charset=UTF8");

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (124,'XML injection prevention',' XML injection prevention


 Example:


    <?php

	/*
	Whenever you are using XML parsers you must sanitize or encode al userinput before
	including this input into your XML file.

	Some methods like below, the Dom document already encodes the input before storing it
	into the XML. But beware, since this encoded input is still a threat whenever you are
	displaying the this data on screen as HTML output. This encoded data should be escaped
	at all times before displaying.

	Whenever your XML function does not encode your data on the fly, you may want to write
	your own function for achieving this. See the code examples and search for "Input encoding"
	for more detailed information.
	*/


	//Let us take an easy example where we store your favorite number name into a XML file.
	$doc = new DOMDocument();
	$doc>formatOutput = true;

	$r = $doc>createElement( "employees" );
	$doc>appendChild( $r );

	$b = $doc>createElement( "employee" );

	$name = $doc>createElement( "name" );
	$name>appendChild(
	$doc>createTextNode( $_POST[''''name''''] )
	);
	$b>appendChild( $name );

	$r>appendChild( $b );

	$doc>save("test.xml");

	/*
	We will try to insert <script>alert(123);</script> into the XML file,
	Now after inserting the employee name into the XML file it will look like:


	<?xml version="1.0"?>
	<employees>
		<employee>
		<name>&lt;script&gt;alert(123);&lt;/script&gt;</name>
		</employee>
	</employees>

	As you can see de input has been encoded but still can trigger an XSS whenever we
	extract the data as shown in the example below:

	NOTE: if you ever want to include the xml files by means of userselected sources,
	be aware of the fact that an attacker could also include sources from external websites
	and even execute External entity injections on your applications. See the "XSLT injection prevention"
	code example for more detailed information on how to implement this type of functionality since
	the same principle''''s apply to both functions.
	*/


	$doc = new DOMDocument();
	$doc>load( ''''test.xml'''' );
	$doc > validateOnParse = true;
	$employees = $doc>getElementsByTagName( "employee" );

	foreach( $employees as $employee )
	{

		$names = $employee>getElementsByTagName( "name" );
		$name = $names>item(0)>nodeValue;

		//This example is vulnerable to XSS
		echo $name;

		//This example is escaped
		$esc = htmlspecialchars($name);

		echo $esc;

	}

	/*
	We recommend to not rely solely on the encoding of the input by the Dom document.
	So before you insert userinput into the XML file you want to have it sanitized.
	See the "Encoding" and "input validation" code examples for more detailed information
	*/

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (125,'File upload',' File upload


 Example:


	<?php

	class fileUpload{
		
		public function Image(){

			include(''''classes.php'''');
			$validated = new validate();
			$log = new logging();


			$image = $_FILES[''''fileToUpload''''];
			//File location outside of the root
			$uploaddir = ''''assets/uploads/'''';

			//check extensions
			$filetype = explode(".", $image[''''name'''']);

			/*
			For uploading out of intended directory we check the filename and verify that it only contains alphanumeric values.
			*/
			if($validated > inputValidation($filetype[0], "alphanumeric", "invalid filename", "MOD", 2){
				header(''''location:/page'''');
				die();
			}

			/*
			We take the last array value to make sure it is the last extension to prevent validating
			.jpg.php in a file name.
			*/
			$takeLastValue = count($filetype)  1;

			while(($filetype[$takeLastValue] != "png") && ($filetype[$takeLastValue] != "jpg")){

				//Set a log for whenever there is an unexpected user input with a threat level
				$log > setLog($_SESSION[''''userID''''],"Unrestricted image extension upload",
				"FAIL", date(ddmmyyyy), $privilege, "HIGH");

				/*
				Set counter; if counter hits 3, the user''''s session must be terminated.
				After 3 session terminations the user account should be blocked
				Since the high threat level will lead to immediate session termination
				*/
				$log > setCounter(3);

				//The die function is to make sure the rest of the php code is not executed beyond this point
				die();
			}

			 // Check file size
			if($image["size"] > 500000) {
				 header(''''location:/page'''');
				 die();
			 }

			// Check if file already exists to prevent overwriting
			if(file_exists(''''assets/uploads/''''.$image[''''name''''])) {
				header(''''location:/page'''');
				die();
			}  

			//if all goes well upload your file, first we want to log the event.
			$log > setLog($_SESSION[''''userID''''],"File upload", "SUCCESS", date(ddmmyyyy),
			$privilege, "NULL");

			$uploadfile = $uploaddir . basename($image[''''name'''']);
			move_uploaded_file($image[''''tmp_name''''], $uploadfile);

			//Last mime type check after upload if not correct than delete!
			$finfo = finfo_open(FILEINFO_MIME_TYPE);
			echo $theType = finfo_file($finfo, $uploaddir.$image[''''name'''']);

			if($theType != "image/jpeg" && $theType != "image/png"){    
				unlink($uploaddir.$image[''''name'''']);

				//Set a log for whenever there is unexpected user input with a threat level
				$log > setLog($_SESSION[''''userID''''],"invalid image mime type",
				"FAIL", date(ddmmyyyy), $privilege, "HIGH");

				/* ^^
				Set counter; if counter hits 3, the user''''s session must be terminated.
				After 3 session terminations the user account should be blocked
				since the high threat level can lead to immediate session termination.
				*/
				$log > setCounter(3);

				//The die function is to make sure the rest of the php code is not executed beyond this point
				die();              
			}
		}
	}
	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (126,'Privilege based authentication',' Privilege based authentication


 Example:


    <?php

	/*
	For privilege based authentication we need an extra table in your database in order to write the users privileges to.

	TABLE users
	    
	| userID | userName | password | privilegeID |    access	| AggregateControl	|
	   
	|   1    | Admin    | Csdar323 |	  1      | 	   TRUE		|		2336        |
	   	
	|	2    | User	    | Adf4fsv  |	  2      |	   FALSE	|		 0         	|
	   
	|	3    | Guest    | dff4fKr  |	  3	     |	   TRUE		|		135	       	|
	   

	TABLE privileges
	   
	| privilegeID | privilege        |
	
	|     1	      | edit:read:delete |
	
	|	  2	      | edit:read        |
	
	|	  3	      | read             |
	

	Now instead of using roles in sessions we rather want to assign privileges to users
	by means of a DatabaseBased Authentication system.
	Now we can easily assign a user certain privileges for him to access.
	*/

	class privilege{

	//Here is the isAuthorized function in which we check whether the user is permitted to do the action
	public function isAuthorized($ispermitted){

		//we make object of logging class for our logging methods also for db connection
		include("classes.php");

		$logging = new logging();
		$con 	 = new database();

		$db = $con>connection();

		//We select the privilege from the database
		$stmt = $db>prepare("
			SELECT a.username, a.password, a.privilegeID, b.privilegeID, b.privilege   
				FROM users as a
					JOIN privileges as b
						ON a.projectID = b.projectID
							WHERE a.userID = :id and b.access=''''TRUE''''");

		$stmt>execute(array('''':id'''' => $_SESSION[''''userID'''']));
		$rows = $stmt>fetchAll(PDO::FETCH_ASSOC);

		foreach($rows as value){
			$privilege = $value[''''privilege''''];
		}

		//We first explode the value''''s to see how much parts the arrays consists of
		$permission    = explode(":", $privilege);
		$authorization = explode(":", $ispermitted); // $ispermitted

		//Then we count the authorization array
		$count     = count($authorization);
		$counthits = 0;

		/*
		We check the permissions against the ispermitted value to see how many times
		they match. whenever they match we count the hits
		*/
		foreach($permission as $value){
			if(preg_match(''''/''''.$value.''''/'''', $ispermitted)){
				$counthits++;
			}
		}

		/*
		Whenever the counts hits are greater or equal to the needed permissions
		we now know we deserved access to the part of the system.
		*/
		if($counthits >= $count){

			//Log that the user had sufficient privileges:
			$logging>setLog($_SESSION[''''userID''''],"User was privileged!", "SUCCESS",
			date("dmy"), $privilege, "NULL");

			return true;
		}else{

			//Log that the user had insufficient privileges:
			$logging>setLog($_SESSION[''''userID''''],"User was not privileged!", "FAIL",
			date(ddmmyyyy), $privilege, "HIGH");

			/*
			Set counter; if counter hits 3, the user''''s session must be terminated.
			After 3 session terminations the user''''s account must be blocked.
			Given the high threat level, there will be immediate session termination.
			in this case the user tried to manipulate the application operation in order to do things he is not
			privileged to, immediate session termination will follow!
			*/

			$logging>setCounter(3);

			return false;
			}
		}
	}

	/*
	This is how you enforce the permissions in your application
	We define the roles we want the user to suffice
	*/

	if(isAuthorized("edit:read:delete") === true){
		//Do your operation
	}

	/*
	if ever there are new ''''roles'''' added to the system you can easily assign them the needed privileges without
	having to add new roles throughout your entire system. This system takes a little more planning up ahead but
	it enforces higher level of security.
	*/

    ?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (127,'HTML output',' HTML output


 Example:


    <?php

	/*
	Whenever user input is displayed in the application, whether, as content or a parameter value
	submitted towards the url, all user input should be properly escaped to prevent XSS injections.
	*/

	//For normal output this escaping will do the trick
	$escaped = htmlspecialchars($_POST[''''value''''], ENT_QUOTES, ''''UTF8'''');
	echo $escaped;

	//This also applies, for instance, when retrieving content from a database:
	while($row = $stmt>fetch(PDO::FETCH_ASSOC)) {
		echo htmlspecialchars($row[''''value''''], ENT_QUOTES, ''''UTF8'''');
	}

	/*
	Security consists of different layers of protection, in order to guarantee the integrity
	of your application. This means that the value submitted from the user should
	already be sanitized before being submitted towards the database in order to prevent XSS.
	As an example, you are expecting only alphanumerical value here:
	*/

	if(!preg_match("/^[azAZ09]+$/", $escaped)){
		die();
	}

	/*
	This type of approach should be used whenever you are allowing user input in
	your DOM like for example, let''''s say a user was allowed to upload an image and
	set an alt text. when you do not sanitize his input a possible attack string could be:
	*/

	this is an image" onload="alert(''''XSS'''');"

	/*
	whenever this string now is added to the users image this will be the outcome, leading
	to xss:
	*/

	<img src="http://image.com/image.jpg" alt="this is an image" onload="alert(''''XSS'''')"" />

	/*
	After this sanitation malicious code can no longer exist in the $_POST[''''value''''] variable.

	Another possibility for attackers to execute an XSS injection, is to pass malicious code directly
	into the URL by means of a "href", e.g.:
	javascript:alert(document.cookie);
	or
	data:text/html;base64,base64xssinjection

	In the following scenario escaping with htmlspecialchars() is not sufficient to block the injection.
	By checking the URL to see if it starts with either http:// or https:// whenever a link has
	been submitted to the web application by a user.

	?>
','php-needs-reviewing',1);
INSERT INTO "code_items" VALUES (128,'X XSS Protection header',' XXSSProtection header


 Example:


    """
    In order to set the XXSSProtection header, you''''ll have to add the following code to the head of your application
    """

    @app.after_request
    def anti_XSS(response):
        response.headers["XXSSProtection"] = "1; mode=block"
        return response
','flask',1);
INSERT INTO "code_items" VALUES (129,'Server side template Injection prevention',' Server Side Template Injection prevention


 Example:

    
	"""
	Server Side Template Injection, a frequent critical vulnerability that has high chance of 
	mistaken as Cross Site Scripting and miss it entirely. But inline XSS, it can lead attack in 
	Web server and may even obtain a RCE. Template Injection occurs when user input is embedded in a template in an unsafe manner. 
	"""

	//Vulnerable piece of Code which can lead to SSTI
	@app.errorhandler(404)
	def page_not_found(e):
    	template = ''''''''''''{%% extends "layout.html" %%}
		{%% block body %%}
    	<div class="centercontent error">
        <h1>Oops! That page doesn''''t exist.</h1>
    	<h3>%s</h3>
    	</div>
		{%% endblock %%}
		'''''''''''' % (request.url)
    	return render_template_string(template), 404

    """
    The above code is vulnerable to SSTI,
    If we give http://www.example.com/ss/<script>alert(1)</script>
    This will show an alert box, which means its vulnerable to XSS
    If we give http://www.example.com/ss/{{3*3}}
    This will show an output 9, which further tells us that it is vulnerable to code injection or SSTI
    """

    //Sanitization of user input can fix the issue
    @app.errorhandler(404)
	def page_not_found(e):

		//Initialize
		continue = True

		//Escape function would fix the issue
    	url = request.url
    	url = escape(url)
    	
    	//Checking the url
    	p = re.compile(r''''(http://www.example.com/(.*))(\?.*)?'''')

    	if inputValidation(url, "alphanumeric") or len(url>20) or inputValidation(url, "alpha"):
    		continue = False
    	
    	if p.match(url) and continue==True:

    		template = ''''''''''''{%% extends "layout.html" %%}
			{%% block body %%}
    		<div class="centercontent error">
        	<h1>Oops! That page doesn''''t exist.</h1>
    		<h3>%s</h3>
    		</div>
			{%% endblock %%}
			'''''''''''' % (url)
    		
    		return render_template_string(template), 404

','flask',1);
INSERT INTO "code_items" VALUES (130,'Enforce secure passwords',' Enforce secure passwords


 Example:

 todo, insecure default with proceed = True

    def checkPassword(pwd):
    	error = []
    	proceed = True
    	//Recommended a longer password for Security
    	if(len(pwd) < 13):
        	error.append("Password is too Short!!")
        	proceed = False
    
    
    //Even though your password is sufficient according to all your standards, the password could still be weak.
    //Just imagine the password "Password!"; this could easily be guessed by an attacker. To prevent the use of weak passwords we 
    //compare the password with a list of top 500 bad passwords and if matched, the password wil be rejected:

    	file = open(''''badpasswords.txt'''').read()
    	pattern = file.split(",") 

    	for value in pattern:
        	if value != pwd:
            	pass
        	else:
            	error.append("Your password was matched with the bad password list, please try again.")
            	proceed = False
            	break

    	if proceed == True:
        	flash("Your password is allowed!")
        	return True
        else:
        	flash("Password validation failure(your choice is weak):")
        	for x in error:
            	print x
        	return False','flask',1);
INSERT INTO "code_items" VALUES (131,'Re authentication',' Reauthentication


 Example:
    

    """
    Whenever a user wants to change his credentials or do other important data exchanges such as
    transferring money he should always be challenged to reauthenticate himself before
    allowing them to perform these actions.
    """
    
    def reauthenticate(password):
        user = User.query.filter_by(id=session[''''id'''']).first()

        //Validation of password in bcrypt encryption
        if ValidatePassword(user.password, password):
        
            //After successful validation we will log that password was validated successfully
            setLog(session[''''id''''], "Password return true", "SUCCESS", str(datetime.utcnow()), session[''''privilege''''], "NULL")

            //Here we set a session to see if the user is authenticated throughout the system
            session[''''access''''] = ''''active''''

            """
            The userID in a session variable to use as an identifier to prevent a user reading
            into unauthorized data, See Identifierbased authorization for more information and
            code examples.
            """

            //Setting the user Id
            session[''''id''''] = user.id

            return True

        else:

            //The user failed reauthenticating himself
            setLog(session[''''id''''], "Reauthentication failed", "FAIL", str(datetime.utcnow()), "null", "MOD")
            //If authentication failed destroyed the session
            session.destroy()
            session.regenerate()
            session[''''access''''] = ""

            return False


    """
    Before we let a user perform certain actions he should first be challenged to authenticate
    himself. imagine the following scenario, the user wants to change his email address.
    """

    if reauthenticate(password) !== True :

        return "<div id=''''error''''>please reauthenticate yourself<div>"\
    	+ "<form method=''''post''''>"\
    	+ "<input type=''''password'''' name=''''password''''/>"\
    	+ "<input type=''''submit'''' name=''''authenticate''''/>"\
    	+ "</form>"

    else:
    	//Do operation for changing the email address
    	return "<div id=''''success''''>You can now change your email address!</div>";

','flask',1);
INSERT INTO "code_items" VALUES (132,'XSL injection prevention',' XSL injection prevention


 Example:

    
    """
	In order to prevent XSL injections you must enforce strict policy''''s whenever the
	files are loaded from a source controlled by an possible attacker.

	Let''''s say for example that the user can choose from several XSL files on your application.

	ABC.xsl arranges your employee names on alphabetical order
	CBA.xsl does not care and just shows the input by order of your XML file.

	Before we want to attach the XSL files to the style sheet we first want to
	do validation on the request to make sure the included file was one of our own pre
	defined files, example:
	including("file1.xsl,file2.xsl,etc", filename)
	"""


	def including(whiteListing, input):

		continue = True

		"""
		First, we want to filter the filenames for expected values. For this example we use only az/09 and .
		Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
		for more information about validation see "input validations" in the code examples:
		"""

		if inputValidation(inputParameter, validationType, "Invalid userinput", "HIGH") == False:
			continue = False

		"""
		We want to whitelist the paged for expected values, in this example they are,
		page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
		"""

		if whitelisting(whiteListing, input, count) == False:
			continue = False

		//If all went good we do the function
		if continue == True:
			//Load XML file
			root = etree.parse("test.xml")

			xslt_root = etree.XML(input)
			transform = etree.XSLT(xslt_root)

			//Transform the XML
			result_tree = transform(root)

		else: 

			return False','flask',1);
INSERT INTO "code_items" VALUES (133,'Session cookies (domain)',' Session cookies (domain)


 Example:


	"""
	Whenever a session is started, and you want to share it over different domains,
	the domain value should be set to the specific domain
	"""

	from flask import Flask, session

	//Initialize the flask application
	app = Flask(__name__)

	//Set the secret key.  keep this really secret:
	app.secret_key = open("/dev/random","rb").read(32) 

	//Name of the session cookie
	app.config[''''SESSION_COOKIE_NAME''''] = ''''hrj''''
	//Path for the session cookie
	app.config[''''SESSION_COOKIE_PATH''''] = ''''/''''
	//Domain for the session cookie
	//Configure domains, do not use .yourdomain.com (wildcard)
	//This increases the attack surface!
	app.config[''''SESSION_COOKIE_DOMAIN''''] = ''''demo.yourdomain.com''''
	//Controls if the cookie should be set with the secure flag
	app.config[''''SESSION_COOKIE_SECURE''''] = True
	//Controls if the cookie should be set with the httponly flag
	app.config[''''SESSION_COOKIE_HTTPONLY''''] = True
	//Lifetime of a permanent session
	app.config[''''PERMANENT_SESSION_LIFETIME''''] = 3600

	//Store Value in session
	session[''''type''''] = "value"','flask',1);
INSERT INTO "code_items" VALUES (134,'Directory listing',' Directory listing


 Example:


    """
    To disable or prevent directory access, you need to configure your server used propery!
    """

','flask',1);
INSERT INTO "code_items" VALUES (135,'RFD and file download injection prevention',' Reflective file download and file download injection prevention


 Example:

    
	def downloadUserFiles(fileId):
		
		proceed = True

		"""
		For the sake of example we only allow the users to download their own files
		by identifier based sql query''''s. As you can see we select the filename
		by its id. in this case we prevent direct user input into the disposition header.
		"""

		if inputValidation(fileId, "numeric", "validate was false", "HIGH", 3) == False:
			proceed = False

		if proceed = True:
			file = Download.query.filter_by(fileId=fileId, userId=session[''''id'''']).first()

			filename = file.fileName
			mimeType = file.mimeType

			if filename:

				"""
				We also define the mimetype per download file.
				This is because whenever a user can only download images it is not necessary to set
				an uncommon contenttype header for it.
				NOTE: These mimetypes should not be stored based upon the mimetype which was send
				the response header when the user uploaded the file. This value can be easily
				manipulated with an intercepting proxy. You should get the mimetype from the file
				itself after it was stored on the server.
				"""

				response = Response(open(app.config[''''UPLOAD_FOLDER''''] + filename).read())
				response.headers["ContentDescription"] = "File Transfer"
				response.headers["Contenttype"] = mimeType
				response.headers["ContentDisposition"] = "attachment; filename=" + filename
				response.headers["Expires"] = 0
				response.headers["CacheControl"] = "nostore, nocache, mustrevalidate, maxage=0"
				response.headers["CacheControl"] = "postcheck=0, precheck=0", false

				if os.path.exists(app.config[''''UPLOAD_FOLDER''''] + filename):
        			return response

	"""
	The second example is for whenever you are providing users with fixed downloads
	such as manuals etc. We do not only check if the file just exists, because that would
	allow an attacker to also download important other files from your server, so instead
	we whitelist them.
	"""
	
	def downloadStored(filename):

		response = Response(open(app.config[''''UPLOAD_FOLDER''''] + filename).read())

		if whitelisting("file1.txt,file2.txt", $filename) != False:
			response.headers["ContentDescription"] = "File Transfer"
			response.headers["Contenttype"] = ''''text/plain''''
			response.headers["ContentDisposition"] = "attachment; filename=" + filename
			response.headers["Expires"] = 0
			response.headers["CacheControl"] = "nostore, nocache, mustrevalidate, maxage=0"
			response.headers["CacheControl"] = "postcheck=0, precheck=0", false
			response.headers["ContentLength"] = os.path.getsize(filename)

			if os.path.exists(app.config[''''UPLOAD_FOLDER''''] + filename):
        			return response
			','flask',1);
INSERT INTO "code_items" VALUES (136,'X Content Type Options header',' XContentTypeOptions header


 Example:


    """
    In order to set the "XContentTypeOptions" header you''''ll have to add the following code to the head of your application
    """

    @app.after_request
    def anti_ContentType(response):
        response.headers["XContentTypeOptions"] = "nosniff"
        return response
','flask',1);
INSERT INTO "code_items" VALUES (137,'Audit logs',' Audit logs


 Example:


    """
    The log function does not have to be complicated as long as you log at least these 6 values

    Whenever a user is registered or added to your system, the application must also
    automatically generate a table for this user which contains his userID, counter and blocker
    variable in order to keep track of his behavior.
    """

        def setLog(userId, error, value, date, threat):

            """
            There are different threats : LOW, MEDIUM, HIGH

            NULL if the operation is success

            LOW threats are debugging logs or information logs when it goes wrong

            MEDIUM threats can be failure of validation check, whitelisting checks failure

            HIGH threats can even result in ban of users, security testing and maximum number of tries
            """
            
            //Take the client''''s IP address
            ip = request.remote_addr

            //Save log file in a directory which has restrictions in place so no one can 
            file = "restrictedfolder/logfile.txt"
            f = open(file, ''''w+'''')
            
            //Notice how we user the userID instead of the actual username in order to prevent the integrity of these usernames
            f.write(date + str(userId) + error + value + threat + "Ip : " + str(ip))
            f.close()


        class Counter(db.Model):
            __tablename__ = "counter"
            count = db.Column(db.Integer, nullable=False)
            blocker = db.Column(db.Integer, nullable=False)
            userID = db.Column(''''userID'''', db.Integer, db.ForeignKey(''''users.user_id''''), primary_key=True)

            def __init__(self, count, blocker, userID):
                self.count = count 
                self.blocker = blocker
                self.userID = userID

            def increment(self, count):
                self.count+= count
                self.blocker+= count

                if self.counter >= 3:
                    setLog(self.userId,"The users session was terminated", "SUCCESS", datetime.utcnow(), "NULL")
                    //After the counter has terminated a session he should be set to zero again
                    self.count = 0
                    //Log that the users sessions have been terminated
                    logout()

                if self.blocker >= 12:
                    //If the blocker was bigger than 12 it means the user has made three strikes and his account should blocked
                    setLog(self.userId,"The users is denied access to system", "SUCCESS", datetime.utcnow(), "NULL")
                    user = User.query.filter_by(id=self.userID).first()
                    user.status = ''''Blocked''''','flask',1);
INSERT INTO "code_items" VALUES (138,'CSRF tokens',' CSRF tokens


 Example:


    //The random CSRF token generated need to be send to the server with every form submission. 
    //We are using FlaskWTF, for installing that: 
    //pip install U FlaskWTF
    //In HTML Forms, for specifying the CSRF we can use the below code

    <form method="post">
      <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
    </form>

	//For ajax requests, we can use the below code

    <script type="text/javascript">
    var csrf_token = "{{ csrf_token() }}";

    $.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {
                xhr.setRequestHeader("XCSRFToken", csrf_token);
            }
        }
    });
    </script>

	//For configuring in the backend, you can use the below code
    import base64
    from OpenSSL import SSL, rand
    from werkzeug.utils import secure_filename
    from flask_wtf.csrf import CSRFProtect, CSRFError

	//Initialize the flask application 
    app = Flask(__name__)

    //To Register CSRF protection globally for the app 
    csrf = CSRFProtect()
    csrf.init_app(app)

    //Configurations 
    //Strictly protection on SSL, Referrer 
    app.config[''''WTF_CSRF_SSL_STRICT''''] = True 

    
    //Always use a WTF_CSRF_SECRET_KEY otherwise by default this will use the Flask app''''s 
    //SECRET_KEY. So if user didn''''t WTF_CSRF_SECRET_KEY it will choose SECRET_KEY, 
    //Which may impact the secret key

    //Random string for generating CSRF token
    app.config[''''WTF_CSRF_SECRET_KEY''''] = base64.b64encode(rand.bytes(128)) 

    //Function which is called when CSRF error happens
    @app.errorhandler(CSRFError)
    def handle_csrf_error(e):
        return render_template(''''csrf_error.html'''', reason=e.description), 400
	','flask',1);
INSERT INTO "code_items" VALUES (139,'Logout function',' Logout function


 Example:


    from flask_login import login_user, LoginManager, UserMixin, logout_user, login_required

    """
    This way, the logout functionality will revoke the complete session:
    """
  
    @app.route("/logout")
    @login_required
    def logout():
      logout_user()
      setLog(self.userId,"Logout User", "SUCCESS", datetime.utcnow(), "NULL")
      return render_template(''''index.html'''')','flask',1);
INSERT INTO "code_items" VALUES (140,'White listing',' Whitelisting


 Example:


    """
    First we create a function which checks the allowed patterns:
    whitelisting("value1,value2,value3" , input)
    Whitelisting is checking if a value is identically the same as the whitelist we created. Please rewrite the below part to reflect this.
    """

    def whitelisting(allowed, input):
        result = allowed.split('''','''')
        flag = False
        for x in result:
            if x == match:
            
            //If the value is valid we send a log to the logging file
            setLog(session["id"], "Good whitelist validation", "SUCCESS", datetime.utcnow(),"HIGH")
            flag = True
            //Whenever there was a valid match we return true
            return True
            
        //Check for a false in order to send error to log and counter the user
        if flag == False:
                
            //If the whitelist is bad log the validation 
            setLog(session["id"], "Bad whitelist validation", "FAIL", datetime.utcnow(), "HIGH")            
            counter.increment()
            return False    
','flask',1);
INSERT INTO "code_items" VALUES (141,'Session hijacking and fixation',' Session hijacking and fixation


 Example:


    """
    As soon as a user logs into your application you must store his session id as well as his
    IP address along with his userID. This information will be used later on in your application in order to identify possible session hijacking.

    TABLE track_sessions
    
    | TrackID | userID |		   	   SESSION 		            |     Ip address	    |
    
    |   1     | 1      | 	79dcd529c0f5e01a9bfb2425c52036c6    |	123.45.67.89	|   
    
    |   2     | 1      | 	79dcd529c0f5e01a9bfb2425c52036c6    |	123.45.67.81	|
    
    |   3     | 2      | 	c80959d3ea4c166413774e45375ac2a1    |	987.65.43.21	|
    

    In order to prevent session hijacking there are a couple of defense strategies
    which combined are a hardened defense.  
    """

    """
    First we implement the strict transport security header, this is in order to prevent
    users from accessing your application over an unprotected connection.
    """

    //Example of the strict transport security header:
    response.headers["StrictTransportSecurity"] = "maxage=31536000"

    //If all present and future subdomains will be HTTPS:
    response.headers["StrictTransportSecurity"] = "maxage=31536000; includeSubDomains"    

    """
    Recommended: If the site owner would like their domain to be included in the HSTS preload
    list maintained by Chrome (and used by Firefox and Safari), then use:
    """

    response.headers["StrictTransportSecurity"] = "maxage=31536000; includeSubDomains; preload"    

    """
    The `preload` flag indicates the site owner''''s consent to have their domain preloaded.
    The site owner still needs to then go and submit the domain to the list. the preload list
    enforces the browser to always present your application on HTTPS even on the first time
    the user hits your application
    """

    """
    Then we set the httpOnly flag
    (see "HttpOnly" in the code examples for more details about implementation)
    """
    	
    app.config[''''SESSION_COOKIE_HTTPONLY''''] = True

    """
    Then we set the flag for session timeout
    (see "Timeout" in the code examples for more details about implementation)
    """
    	
    app.config[''''PERMANENT_SESSION_LIFETIME''''] = 3600

    """
    Then we set the session secure flag
    (see "Secure flag" in the code examples for more details about implementation)
    """
    app.config[''''SESSION_COOKIE_SECURE''''] = True

    """
    On login we change the session id in order to prevent session fixation
    (see "Login functionality" in the code examples for more details about implementation)
    """
    
    //In header we should include this
    from flask_kvsession import KVSessionExtension
    
    //Call for session regenerate to prevent session fixation
    session.regenerate()

    """
    NOTE: On applications that require high level security, there should never be an
    remember me functionality implemented.
    """


    """
    Now imagine the scenario after the login of the user (see the "login functionality" in
    the code examples for more details). Whenever the user is logged in, the users IP address
    and session id are also stored in the database these values are used in order to verify
    if there are multiple users active on the same session.
    If so, we can let the user decide to terminate the session and terminate the
    other assigned sessions.
    """

    def checkSession():
        //To check whether the user is active
        if session[''''status''''] != "active" or session[''''status''''] == "":
            return redirect(url_for(''''login''''))

        """
        Then we start the rest of the function where we will check if there are multiple
        users/IP addresses using the same session id
        """
    
        //Store the current session
        session = request.cookies.get(''''session'''')

        //Get user ip address
        ipaddress = request.remote_addr

        trackSession = track_sessions.query.filter_by(ipaddress = ipaddress).first()
        if trackSession.session == ipaddress:
            return """<div style=''''borderstyle:solid; bordercolor:black; color:white; backgroundcolor:red; float:left;''''>
                <p>There are other active sessions on other IPaddresses.<br/>
                Your session could be hijacked press logout in order to authenticate again
                for security reasons!
                <br/><br/>
                <a href=''''/logout''''>Terminate sessions</a>
                <br/>
                <a href=''''/Proceed''''>Proceed anyway</a>
                </p>
                </div>"""

    """
    The only thing left to do now is to update your track_sessions table by inserting
    the IP address, sessionID and userID if you want to accept the other sessions as valid.
    Otherwise the user just has to terminate his current session in order to lock out the
    other sessions.
    """','flask',1);
INSERT INTO "code_items" VALUES (142,'Random password token generation',' Random password/token generation


 Example:


	"""
	When needing to generate random numbers, always use proven methods 
	instead of writing your own.
	"""
	
	import secrets
	SECRET_KEY = secrets.token_hex(36)
    
	"""
	use secrets.token_urlsafe() for base64 encoded random secure strings
	"""


','flask',1);
INSERT INTO "code_items" VALUES (143,'Password storage (salting stretching hashing)',' Password storage (salting/stretching/hashing)


 Example:


    from flask.ext.bcrypt import Bcrypt

    //Initialize the application with Bcrypt
	app = Flask(__name__)
	bcrypt = Bcrypt(app)

	//For the encryption of passwords we use BCRYPT encryption method.

	def createHash(pwd):
		setLog(0, "Create password Hash", "SUCCESS", str(datetime.utcnow()), "HIGH")
		return bcrypt.generate_password_hash(pwd)

	//Validate your password

	def ValidatePassword(pwd_hash, pwd):
		setLog(0, "Start ValidatePassword", "SUCCESS", str(datetime.utcnow()), "HIGH")
		try:
			return bcrypt.check_password_hash(pwd_hash, pwd)
			setLog(0, "ValidatePassword correct password", "SUCCESS", str(datetime.utcnow()), "HIGH")
		except ValueError:
			return False
			setLog(0, "ValidatePassword incorrect password", "FAIL", str(datetime.utcnow()), "HIGH")

		','flask',1);
INSERT INTO "code_items" VALUES (144,'Directory path traversal',' Directory/path traversal


 Example:

 todo insecure default with continue is true:

	//Define the whitelist pattern and validation type and input parameter like:
	//getFiles("images,css,js", ''''alphanumeric'''', foldername)

	def getFiles(whiteListPattern, validationType, inputParameter):
		
		continue = True

		//First, we want to filter the filenames for expected values. For this example we use only az/09 and .
		//Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
		//For more information about validation see "input validations" in the code examples:

		if inputValidation(inputParameter, validationType, "Invalid userinput", "HIGH") == False:
			continue = False

		//Second, we want to whitelist the filenames for expected values, in this example they are,
		//page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:

		//Check for filename Whitelisting
		if whitelisting(whiteListPattern, inputParameter):
			continue = False

		if continue == True:
			//Create Path
			path = os.path.join(app.config[''''UPLOAD_FOLDER''''], inputParameter)   
			images = []
			
			//List all the URL
			for f in os.listdir(path):
			    if f.endswith("jpg") or f.endswith("png"):
			        images.append("%s%s/%s" % (app.config[''''UPLOAD_FOLDER''''], inputParameter, f))

			return render_to_response(''''gallery.html'''', {''''images'''': images})

		else:

		 	return render_to_response(''''gallery.html'''', {''''images'''' : ''''''''})

	//gallery.html

    {% for image in images %}
    <img src=''''{{image}}'''' />
    {% endfor %}
','flask',1);
INSERT INTO "code_items" VALUES (145,'Input validation',' Input validation


 Example:

    
	"""
	Instead of reinventing the wheel for input validation we utilize
	easy to apply libraries for these type of features such as flask WTForms
	or Cerberus for API''''s
	"""


	"""
	Flask WTForms:
	"""

	from wtforms import Form, BooleanField, StringField, PasswordField, validators

	class RegistrationForm(Form):
		username = StringField(''''Username'''', [validators.Length(min=4, max=25)])
		email = StringField(''''Email Address'''', [validators.Length(min=6, max=35)])
		password = PasswordField(''''New Password'''', [
			validators.DataRequired(),
			validators.EqualTo(''''confirm'''', message=''''Passwords must match'''')
		])
		confirm = PasswordField(''''Repeat Password'''')
		accept_tos = BooleanField(''''I accept the TOS'''', [validators.DataRequired()])


	"""
	Cerberus:
	"""

	from cerberus import Validator


	v = Validator()
	v.schema = {''''name'''': {''''required'''': True, ''''type'''': ''''string''''},
				''''age'''': {''''type'''': ''''integer''''}}

	if v.validate({''''age'''': 34}):
		print(''''valid data'''')
	else:
		print(''''invalid data'''')
		print(v.errors)

		','flask',1);
INSERT INTO "code_items" VALUES (146,'Enforce sequential step order shopping',' Enforce sequential step order (Shopping)


 Example:


    """
    Whenever an functionality consists out of following several steps to achieve some goal i.e,
    "User adds items to chart", "User enters shipping information", "User pays for goods",
    "Items will be shipped." You want to make sure the user can not skip the payment step in
    order to receive his goods.


    	    
    | Items  |	|  Cart	 |	|checkout |	 | CostumerInfo	|
    	  	 
    |itemID  |	|cartID  |	|PaymentID|  |ConsumerID    |
    |price	 |	|itemID  |	|itemID   |	 |name          |
    |name  	 |	|sessionID|	|Token    |	 |address	    |
    	  |sessionID|  |sessionID   	|
                            |Verified |  |consumerToken |
                            	 		

    As you can see above we have a very simplified database structure for your average
    web shop. Now we can walk through the different steps needed to enforce the user to take
    all steps before payment.

    We wont cover the entire shopping cart functions since that would become a rather big
    example so let''''s cover the basics of enforcing the sequential steps.

    Step1: would be, the user adding items to his cart.

    Step2: would be, the user adding his items to checkout. Whenever he is done shopping
            "add to checkout" generates a random token for the added items which
            are inserted into the payment table in the database

    """

    def checkTokens():

        //First we build the checktokens function because we want to check the checkout tokens
        //Multiple times throughout the steps
    
        rows = checkout.query.filter_by(sessionID=session[''''id'''']).all()
        for x in rows:

            //Here we check for a different token or new session token
            if x.token == session[''''token'''']:

                customerinfo.query.filter_by(sessionID=session[''''id'''']).delete()
                db.session.commit()

                checkout.query.filter_by(sessionID=session[''''id'''']).delete()
                db.session.commit()

                return redirect(url_for(''''checkout''''))

    //As soon as the user visits your website you start sessions in order to assign sessionId

    """
    On submit we send al the shopping cart data to another table in the database, but
    this time al the items also contain the same random token. Now an attacker cannot sneak
    in new items since these tokens will be evaluated on the payment page.

    next, the user lands on a page where he has to fill in his customer info:

    NOTE: do not forget the CSRF token in order to prevent attackers from changing his
    shipping info.
    """

    //Then we proceed to check if the post values where not empty
    	
    check = True
    error = ""

    if request.method == ''''POST'''':
        if request.form[''''customerName''''] == "" : 
            check = False
            error += "Customer name is required"

        if request.form[''''customerAddress''''] == "":
            check = False
            error += "Customer address is required"

        if check != True:
            return error
        else:
            return redirect(url_for(''''summary''''))
            //In this step we also insert at the customer data into the database

    """        
    Then we select al the customer info and shopping items on sessionID from the
    database and display it on screen in order for the user to verify if all the
    information displayed is correct.
    """

    //When the user has verified we again check the checkout tokens to see if no new items where added
    checkTokens()    

    """
    After that the user verifies this information then he will be redirected to the payment
    page like ideal, Paypal etc.

    Whenever the payment returns true you set the "verified" column on the checkout
    table to TRUE and you send the customer the invoice and send him his items.
    """

    verified = True

    data = checkout.query.filter_by(sessionID=session[''''id'''']).first()
    data.verified = verified
    db.session.commit()

    customer = customer.query.filter_by(sessionID=session[''''id'''']).delete()
    db.session.commit()

    checkout = checkout.query.filter_by(sessionID=session[''''id'''']).delete()
    db.session.commit()

    cart = cart.query.filter_by(sessionID=session[''''id'''']).delete()
    db.session.commit()

    ','flask',1);
INSERT INTO "code_items" VALUES (147,'System commands',' System commands


 Example:

 todo insecure default with continue is true:
 todo ideally you have a predefined subset of commands and correlate them to
  whatever was picked as a command

	"""
	Define the whitelist pattern and validation type and input parameter like:
	command("data.txt,users.txt", "filename", filename)
	"""

	def command(whiteListPattern, validationType, inputParameter){

		continue = True

		"""
		Whenever a system command is finished, you should properly sanitize and escape this user input.
		System command functions examples are: system(), eval(), exec()

		First, we want to filter the filenames for expected values. For this example we use only az/09
		Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
		for more information about validation see "input validations" in the code examples:
		"""

		if inputValidation(inputParameter, validationType) == False:
			continue = False

			"""
			Second, we want to whitelist the filenames for expected values, in this example they are,
			page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
			"""

		if whitelisting(whiteListPattern, inputParameter) == False:
			continue = False

		//If all went good we include the filename
		if continue == True:

			//Even though there is match we still escape the shelx.quote():
			command = ''''./configure {}'''' .format(quote(inputParameter))
			os.system(command)

		else:

			return False','flask',1);
INSERT INTO "code_items" VALUES (148,'Session cookies HttpOnly',' Session cookies HttpOnly


 Example:


	"""
	Whenever a session is started, the "httpOnly" option should always be set to "true" or "1":
	"""
	
	from flask import Flask, session

	//Initialize the flask application
	app = Flask(__name__)

	//Name of the session cookie
	app.config[''''SESSION_COOKIE_NAME''''] = ''''hrj''''

	//Path for the session cookie
	app.config[''''SESSION_COOKIE_PATH''''] = ''''/''''
	
	//Domain for the session cookie
	//Configure domains, do not use .yourdomain.com (wildcard)
	//This increases the attack surface!
	app.config[''''SESSION_COOKIE_DOMAIN''''] = ''''demo.yourdomain.com''''
	
	//Controls if the cookie should be set with the secure flag
	app.config[''''SESSION_COOKIE_SECURE''''] = True
	
	//Controls if the cookie should be set with the httponly flag
	app.config[''''SESSION_COOKIE_HTTPONLY''''] = True
	
	//Lifetime of a permanent session
	app.config[''''PERMANENT_SESSION_LIFETIME''''] = 3600

	//Store Value in session
	session[''''type''''] = "value"
','flask',1);
INSERT INTO "code_items" VALUES (149,'SQL query',' SQL query


 Example:


    """
    SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL.
	"""

	from flask_sqlalchemy import SQLAlchemy
	
	//Will track modifications of objects and emit signals
	app.config[''''SQLALCHEMY_TRACK_MODIFICATIONS''''] = True
	//Database URI is used for connection
	app.config[''''SQLALCHEMY_DATABASE_URI''''] = ''''sqlite:///test.db''''
	//Create object of SQL Alchemy
	db = SQLAlchemy(app)

	//Class Model that is a declarative base which can be used to declare models
	class User(db.Model):
    	id = db.Column(db.Integer, primary_key=True)
    	username = db.Column(db.String(80), unique=True, nullable=False)
    	password = db.Column(db.String(120), unique=True, nullable=False)

    	def __repr__(self):	
        	return ''''<User %r>'''' % self.username

    
    //create the tables and database
    from yourapplication import db
	db.create_all()

	//Inserting data into the database  create, add and commit
	admin = User(username=''''admin'''', password=''''9u3$$_m3_1f_y0u_C@n'''')
	db.session.add(admin)
	db.session.commit()

	//Delete entries from the table
	db.session.delete(admin)
	db.session.commit()

	//Querying Records
	//Retrieve the user with username
	admin = User.query.filter_by(username=''''admin'''').first()
	admin.id

	//SQL raw string approach

	from sqlalchemy import text

	if inputValidation(inputParameter, ''''alphanumeric'''') == False:
		//Protection from string interpolation attack
		sql = text("select name from penguins where id =%s" % (inputParameter,) )
	
		result = db.engine.execute(sql)
		print result[0]

    """
	Alternatively if SQL alchemy cannot be used, us prepared statement parameterized query
	"""

	def storeMessages(self, name, message, link):
	db = database_con()
	cur = db.execute('''''''''''' INSERT INTO messages(name, message, link, timestamp)VALUES(?,?,?,?)'''''''''''',(name, message, link, datetime.now() ))
	return db.commit()
    ','flask',1);
INSERT INTO "code_items" VALUES (150,'Open forwards & redirects',' Open forwards & redirects


 Example:

    
    """
    When using forwards & redirects you should make sure the URL is being explicitly
    declared in the code and cannot be manipulated by an attacker like example.com?page=dashboard :
    """

    redirect(url_for(''''dashboard''''))

    """
    Generally you should avoid getting input into the redirect which could contain
    userinput by any means. if for any reason this may not be feasible than you
    should make a whitelist input validation for the redirect like so:

    Example : 
    If the whitelisting list is home, upload and redirectParam is home 

    redirectParam = home
    redirecting("home,upload", redirectParam, "3")
    """


    def redirecting(whitelisting, input, count):
        
        """
        We want to whitelist the paged for expected values, in this example they are,
        page1,page2 etc.. for more information about whitelisting see "whitelisting" 
        in the code examples:
        """

        if whitelisting(whitelisting, input, count) == True:
            //Redirect the Input if whitelisting is correct
            redirect(url_for(input))


','flask',1);
INSERT INTO "code_items" VALUES (151,'X path query',' Xpath query


 Example:


    """
    Define the allowed characters and input parameter and count level for the
    user lockout like:
    controller("<''''>&", $_GET[''''filename''''], "3")
    
    In order to prevent xpath injections we have to treat these query''''s similar as 
    to the sql query''''s. 
    """
    
    def controller(allowed, input, count):
        
        """
        First we build our encoding method, see "input validation" code example for
        more detailed information about encoding and escaping.
        """
        
        return = encoder(allowed, input, count)

        //If the encoder came back false we do not process the function!

        if return != False:

            //Parse the register.xml
            root = etree.parse("register.xml")

            //Extract the id from the XML using XPath
            find = etree.XPath(''''/Employees/Employee[ID='''' + return + '''']'''')

            for x in find(root):
                print x.text
','flask',1);
INSERT INTO "code_items" VALUES (152,'Anti caching headers',' Anticaching headers


 Example:


	"""
	Add the following headers to your application head in order to prevent the browser from caching
	"""

	@app.after_request
	def antiCaching(response):
		response.headers["CacheControl"] = "nostore, nocache, mustrevalidate" HTTP/1.1
		response.headers["CacheControl"] = "postcheck=0, precheck=0, false"
		response.headers["Pragma"] = "nocache"  HTTP/1.0
		return response
','flask',1);
INSERT INTO "code_items" VALUES (153,'Secure session cookies',' Secure session cookies


 Example:


    """
    If you use SLL you can also make your cookies secure (encrypted) to 
    avoid "maninthemiddle" cookies reading
	"""

	from flask import Flask, session

	//Initialize the flask application
	app = Flask(__name__)

	//Set the secret key.  keep this really secret:
	app.secret_key = open("/dev/random","rb").read(32) 

	//Name of the session cookie
	app.config[''''SESSION_COOKIE_NAME''''] = ''''hrj''''
	
	//Path for the session cookie
	app.config[''''SESSION_COOKIE_PATH''''] = ''''/''''
	
	//Domain for the session cookie
	//Configure domains, do not use .yourdomain.com (wildcard)
	//This increases the attack surface!
	app.config[''''SESSION_COOKIE_DOMAIN''''] = ''''demo.yourdomain.com''''
	
	//Controls if the cookie should be set with the secure flag
	app.config[''''SESSION_COOKIE_SECURE''''] = True
	
	//Controls if the cookie should be set with the httponly flag
	app.config[''''SESSION_COOKIE_HTTPONLY''''] = True
	
	//Lifetime of a permanent session
	app.config[''''PERMANENT_SESSION_LIFETIME''''] = 3600

	//Store Value in session
	session[''''type''''] = "value"
','flask',1);
INSERT INTO "code_items" VALUES (154,'Crossdomain.xml ',' Crossdomain.xml


 Example:


		A bad example of a crossdomain.xml would be:

		<?xml version="1.0" ?>
		<crossdomainpolicy>
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowaccessfrom domain="*"/>
			<allowhttprequestheadersfrom domain="*" headers="*"/>
		</crossdomainpolicy>

		//Because it allows access from all other domains.
		//Instead of this approach you might want to use the following restrictions.
		//Example by twitter''''s crossdomain.xml:

		<?xml version="1.0" encoding="UTF8"?>
		<crossdomainpolicy xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance" xsi:noNamespaceSchemaLocation="http://www.adobe.com/xml/schemas/PolicyFile.xsd">
			<allowaccessfrom domain="twitter.com" />
			<allowaccessfrom domain="api.twitter.com" />
			<allowaccessfrom domain="search.twitter.com" />
			<allowaccessfrom domain="static.twitter.com" />
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowhttprequestheadersfrom domain="*.twitter.com" headers="*" secure="true"/>
		</crossdomainpolicy>


Alternatively for setting up cors in flask:

	from project import app
	from flask_cors import CORS

	if __name__ == ''''__main__'''':
		cors = CORS(app, resources={r"/*": {"origins": "*"}})  < never use a wildcard speficy a domain!!
		app.run(host=''''0.0.0.0'''')','flask',1);
INSERT INTO "code_items" VALUES (155,'Password forget and disallow old passwords',' Password forget & Disallow old passwords


 Example:


    """
    Whenever you are developing a password forget function, these are the steps to follow
    in order to create hardened defenses.

    TABLE users
    
    | userID   | userName | password |   EmailAddress	 |  access  |
       
    |     1	   | Admin	  | Csdar323 | info@admin.com	 | 	 True   |
        	
    |	  2	   | User	  | Adf4fsv  | info@user.com     |   False  |
        
    |	  3	   | Guest	  | dff4fKr  | info@guest.com	 |	 True   |
        


    TABLE passwordForget
       
    | forgotPasswordID | 		Token 	    | 	UserID |   Active	|	  olPasswords	    |
    
    |      1  	 	   | c3ab8ff13720e....  |	  1	   | 	True	|	   Csdar323	      	|
    
    |	   2	 	   | 7dd39466b3c89....  |	  1	   | 	False   |		ef0c4f2         |
    
    |	   3	 	   | 83d4a3960714c....	|	  3	   | 	True	|		dff4fKr	        |
    


    As you can see we also store the old passwords into the password forget table, this
    we do in order to prevent the user from using old passwords later on in the process.

    Also use a cron job to make sure the generated tokens for the password reset are
    expire after a certain amount of time like 20 minutes.

    """

    def checkValidity(email):

        user = Members.query.filter_by(email=email).first()

        //Here we select the old password as well as the userid from the members table
        password = user.password
        userID = user.id
        email = user.email

        //If the select was not empty we will be sending an email to the user as well as 
        //Preparing the password forget function

        if user is None:
            """
            We show the user the same message in order to prevent the enumeration of
            valid email addresses.
            """
            return "An email was sent to your email for password reset"

        else:

            """
            Before we do anything we first set all other possible active statuses to NO
            in order to prevent an attacker creating a whole lot of tokens and than fuzz
            the password reset token.
            """

            active = False

            user.active = active
            db.session.commit()

            //Here we generate the password forget token
            token = base64.b64encode(rand.bytes(128))

            passwordChange = forgetPassword(token=token, userID=userID, active=active, oldPasswords=password)
            db.session.add(passwordChange)
            db.session.commit()            


    		//Here we send an email to the user with the needed reset function
    		msg = "follow this link to reset your password http://example.com/reset/"" + "token"
    		mail(email,"Password reset", msg)


    def resetPassword(resetLink, password):		

    	"""
    	Imagine the user clicked on his link with the token included and is redirected towards
    	the page where he can enter his new password.

    	Now we select the information from the forgot password function where the
    	forgot tokens matches the token in the database.
    	"""

    	active = True

        data = forgetPassword.query.join(members, forgetPassword.userID==members.userID).filter_by(token=resetLink,Active=active).all()

        //We select token and users id
        token = data.token
        userID = data.userID

        if token == resetLink:
            
            """
            First we pull the password through our function which enforces the input of
            secure passwords.(see "Enforce secure passwords" in code examples for more
            detailed information)
            """

            if checkPassword(password) == True:

                """
                Than we encrypt our password
                (see "Password storage" in code examples for more
                detailed information)    
                """

                newPassword = createHash(password)
    	
                """
                Finally we compare the password against other old passwords from the
                password reset database in order to prevent the user from using old passwords
                which could already be compromised by any means.
                """
    			
                user = forgetPassword.query.filter_by(userID=userID).first()

                if newPassword == user.oldPasswords:

                    return "This was an old password please do not use this password"

                else:
                    
                    //First we update the new password for the user
                    active = False

                    //Update the details
                    newUser = members.query.filter_by(userID=userID).first()
                    newUser.password = newPassword
                    db.session.commit()
                    user.active = active
                    user.userID = userID
    				db.session.commit()
','flask',1);
INSERT INTO "code_items" VALUES (156,'XML External entities',' XML External entities


 Example:


	"""
	The overall prevention method for loading external entities is adding the following line of code:
	To be safe from loading external entities you have to turn off the entities in the parser.
	"""
	
	//If you are using lxml 

	content = ''''''''''''<?xml version="1.0" encoding="UTF8"?>\
	<!DOCTYPE title [ <!ELEMENT title ANY >\
	<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>''''''''''''

	"""
	If the dtd_validation = True and resolve_entities=True and if the attacker can control the
	XML file which is taken in the parser, he can read any file using the file protocol file:/// or use some other protocols like expect://, gopher:// to even get a shell        
	"""

	from lxml import etree
	
	//Both the entities and DTD are turned off
	parser = etree.XMLParser(dtd_validation=False ,resolve_entities=False)
	root = etree.XML("<root><a/><b></b></root>", parser)
	

	    


	    





	
','flask',1);
INSERT INTO "code_items" VALUES (157,'Anti clickjacking headers',' Anti clickjacking headers


 Example:

    
    """
    One way to defend against clickjacking is to include a ''''framebreaker'''' script in each
    page that should not be framed. The following methodology will prevent a webpage from
    being framed even in legacy browsers, that do not support the XFrameOptionsHeader.
    In the document HEAD element, add the following:
    First apply an ID to the style element itself:
    """

    <style id="antiClickjack">body{display:none !important;}</style>
    <! And then delete that style by its ID immediately after in the script >
    <script type="text/javascript">
      if (self === top) {
        var antiClickjack = document.getElementById("antiClickjack");
        antiClickjack.parentNode.removeChild(antiClickjack);
      } else {
        top.location = self.location;
      }
    </script>

    @app.after_request
    def clickjacking_Protection(response):
        """
        The second option is to use ''''security headers''''.
        There are two options for setting the ''''anticlickjacking'''' headers in
        your application:
        """

        //This will completely prevent your page from being displayed in an iframe 
        response.headers["XFrameOptions"] = "DENY"

        //This will completely prevent your page from being displayed in an iframe on other sites 
        response.headers["XFrameOptions"] = "SAMEORIGIN"
        return response
','flask',1);
INSERT INTO "code_items" VALUES (158,'Debug enabling',' Debug Enabling


 Example:

    
    """
    Debug mode makes it a major security risk and therefore it must never be used on production machines. It may even lead to execution of arbitrary code.
    """

    //In Linux machines, never export the environment variable FLASK_DEBUG to 1
    $ export FLASK_DEBUG=0
    $ flask run

    //On Windows you need to use set instead of export
    $ set FLASK_DEBUG=0

    //Even with python you can enable debug mode
    app.debug = False

    //By default it is False
    app.run()','flask',1);
INSERT INTO "code_items" VALUES (159,'Login functionality',' Login functionality


 Example:


    """
    For privilege based authentication we need an extra table in your database in order to write the users privileges to.

    TABLE users
    
    | userID     | userName   | password | privilegeID   |    access	| 
       
    |   1        | Admin	  | Csdar323 |	  1		     | 	   TRUE		|
       	
    |	2	     | User		  | Adf4fsv  |	  2		     |	   FALSE	|
       
    |	3	     | Guest	  | dff4fKr  |	  3		     |	   TRUE		|
       

    TABLE privileges
     
    | privilegeID     | privilege        |
    
    |     1           | edit:read:delete |
    
    |	  2	          | edit:read		 |
    
    |	  3	          | read	         |
    

    Now instead of using roles in sessions we rather want to assign privileges to users
    by means of a DatabaseBased Authentication system.
    Now we can easily assign a user certain privileges for him to access.
    See "Privilege based authentication" code example for more information:
    We will be using flask_login module for login
    """

    from flask_login import login_user, LoginManager, UserMixin, logout_user, login_required

    //Instantiating Flask Login
    login_manager = LoginManager()
    login_manager.init_app(app)


    //Database model for User
    class User(db.Model):
        __tablename__ = "users"
        id = db.Column(''''user_id'''',db.Integer , primary_key=True)
        username = db.Column(''''username'''', db.String(20), unique=True , index=True)
        password = db.Column(''''password'''' , db.String(10))
        email = db.Column(''''email'''',db.String(50),unique=True , index=True)
        status = db.Column(''''status'''', db.String(50), index=True)
        registered_on = db.Column(''''registered_on'''' , db.DateTime)
        privilegeID = db.Column(''''privilegeID'''', db.Integer, db.ForeignKey(''''privileges.id''''))

        def __init__(self , username ,password , email, privilegeID, status):
            self.username = username
            self.password = password
            self.email = email
            self.registered_on = datetime.utcnow()
            self.privilegeID = privilegeID
            self.status = status


    //Login a user
    @app.route(''''/login'''', methods=[''''GET'''', ''''POST''''])
    def login():
        //Redirect to login page in GET request
        if request.method == ''''GET'''':
            return render_template(''''login.html'''')
        
        //Initializing username and password
        username = request.form[''''inputName'''']
        password = request.form[''''inputPassword'''']

        //Check whether the username is alphanumeric
        if inputValidation(''''alphanumeric'''', username) != True:
            setLog(0, "invalid expected input", "FAIL", str(datetime.utcnow()), "HIGH")
            return redirect(url_for(''''login''''))

        //Username and password check   
        registered_user = User.query.filter_by(username=username).first()
        if registered_user is None:
            flash(''''Username or Password is invalid'''' , ''''error'''')
            return redirect(url_for(''''login''''))

        //Validate the password hash on bycrypt
        elif ValidatePassword(registered_user.password, password):
            //Logged In successfully
            login_user(registered_user)
            flash(''''Logged in successfully'''')
        
        return render_template(''''home.html'''', user=request.form[''''inputName''''])
','flask',1);
INSERT INTO "code_items" VALUES (160,'User registration SQL truncation',' User registration / Sql truncation prevention


 Example:


    """
    In order to prevent Column truncation sql injection Solution we have to make sure the
    applications structural logic does not mismatches with the database structural logic.
    To achieve this imagine the follow example of a database structure of a users table

    TABLE users
    
    |	     *Name* 	   |	*Type* 		  |    *Extra*     |
    
    |        userID	       |    Int(11)       | AUTO_INCREMENT |
    
    |       Username  	   |    char(21)      |  		       |
    
    |       Password       |  Varchar(255)    |			       |
    
    |      PrivilegeID     |    Int(11)       | 	     	   |
       
    |      Status          |    Varchar(200)  |                |
    
    """

    class User(db.Model):
        __tablename__ = "users"
        id = db.Column(''''user_id'''',db.Integer , primary_key=True)
        username = db.Column(''''username'''', db.String(20), unique=True , index=True)
        password = db.Column(''''password'''' , db.String(10))
        email = db.Column(''''email'''',db.String(50),unique=True , index=True)
        status = db.Column(''''status'''', db.String(50), index=True)
        registered_on = db.Column(''''registered_on'''' , db.DateTime)
        privilegeID = db.Column(''''privilegeID'''', db.Integer, db.ForeignKey(''''privileges.id''''))
 
        def __init__(self , username ,password , email, privilegeID, status):
            self.username = username
            self.password = password
            self.email = email
            self.registered_on = datetime.utcnow()
            self.privilegeID = privilegeID
            self.status = status

    //Function to add the details to database
    def userRegister(username, password, email, privilegeID, status):
        user = User(username, password, email, privilegeID, status)
        db.session.add(user)
        db.session.commit()

    //Register user 
    @app.route(''''/register'''' , methods=[''''GET'''',''''POST''''])
    def register():
        if request.method == ''''GET'''':
            return render_template(''''signup.html'''')
        //Ensure the username is not long
        if len(request.form[''''inputName''''] >= 21):
            raise Exception("Long username")
        //Create password hash
        password = passwordHash(request.form[''''inputPassword''''])
        userRegister(request.form[''''inputName''''], password, request.form[''''inputEmail''''], 3, "Active")
        flash(''''User successfully registered'''')
        return redirect(url_for(''''login''''))        
        ','flask',1);
INSERT INTO "code_items" VALUES (161,'Encoder',' Character encoding


 Example:

	
    """
    This is the encoder class for whenever you have to allow certain
    possibly dangerous characters into your code for i.e names such as O''''Reilly
	"""

	def encoder(allowed, input, count):
	    
	    """
	    As you can see you can specify allowed characters in your function
	    """
	    
	    flag = True
	    match = re.findall("/^[azAZ09 " + allowed+"]+$/", input)

	    if match:

	        """
	        Set a log for whenever there is unexpected userinput with a threat level
	        See "audit logs" code example for more information:
	        """

	        setLog(session[''''id''''], "Bad userinputs", "FAIL", datetime.utcnow(), "HIGH")
	        
	        """
	        Set counter if counter hits 3 the users session must terminated
	        After 3 session terminations the user account must be blocked
	        See "audit logs" code example for more information:
	        """
	        
	        counter.increment()
	        flag = False

	        //Remove Dangerous Characters
	        wordDict = {''''&'''': ''''&amp;'''', ''''<'''' : ''''&lt;'''', ''''>'''' : ''''&gt;'''' , ''''"'''' : ''''&quot;'''', "''''" : ''''&x27;'''', ''''/'''' : &x2F;, ''''\'''' : ''''\\''''}

	        for key in wordDict:
	        	input = input.replace(key, wordDict[key])

	        return input
','flask',1);
INSERT INTO "code_items" VALUES (162,'Aggregate user controls',' Aggregate user controls


 Example:

 
    """
    In order to enforce Aggregate access control protection the best method would be to
    define your rules by means of a database structure rather than sessions or log''''s.
    This is due to the fact that if the user drops his session the rating would start
    al over again.

    TABLE users
       
    | userID | userName | password | privilegeID |    access    | AggregateControl	|
      
    |   1    | Admin    | Csdar323 |      1      |     TRUE     |	  2322    	    |
       
    |   2    | User     | Adf4fsv  |      2      |     FALSE    |	  0             |
      
    |   3    | Guest    | dff4fKr  |      3      |     TRUE     |	  125           |
    

    TABLE privileges
       
    | privilegeID | privilege        |
    
    |     1       | edit:read:delete |
    
    |     2       | edit:read        |
    
    |     3       | read             |
    
    """

    def countAccess(count):
        
        """
        Each time the user accesses the database we keep track of the number of times he
        connected. Whenever the user passes a reasonable number he should be rejected
        since he could be an attacker scraping your table contents and stealing company information
        You could a CRON job in your mysql system in order to clean the Aggregate column within certain timeframes
        """
            
        setLog(session[''''id''''], "User access database ", "SUCCESS", datetime.utcnow(), "NULL")
        registered_user = User.query.filter_by(id=session[''''id'''']).first()
            
        //We add the count to control variable for the update
        control = registered_user.AggregateControl + count
            
        //Check the aggregate
        if control > 5000:
            setLog(session[''''id''''], "Aggregate control breach", "FAIL", date("dmy"), "HIGH")
                
            """
            Then we lock out the users account assuming it has been compromised by
            an attacker
            """
                
            access = "Fail"
            registered_user.status = access
            
            //we update the users table and count +1 tot the AggregateControl column
            registered_user.AggregateControl = control

            db.session.commit()','flask',1);
INSERT INTO "code_items" VALUES (163,'Absolute timeout of a session',' Absolute time out of a session


 Example:
	
	
	"""
	Whenever a session is started, absolute time out (lifetime) of a session should be set in seconds
	"""

	from flask import Flask, session

	//Initialize the flask application
	app = Flask(__name__)

	//Set the secret key.  keep this really secret:
	app.secret_key = open("/dev/random","rb").read(32) 

	Name of the session cookie
	app.config[''''SESSION_COOKIE_NAME''''] = ''''hrj''''

	Path for the session cookie
	app.config[''''SESSION_COOKIE_PATH''''] = ''''/''''
	
	//Domain for the session cookie
	//Configure domains, do not use .yourdomain.com (wildcard)
	//This increases the attack surface!
	app.config[''''SESSION_COOKIE_DOMAIN''''] = ''''demo.yourdomain.com''''
	
	//Controls if the cookie should be set with the secure flag
	app.config[''''SESSION_COOKIE_SECURE''''] = True
	
	//Controls if the cookie should be set with the httponly flag
	app.config[''''SESSION_COOKIE_HTTPONLY''''] = True
	
	//Lifetime of a permanent session
	app.config[''''PERMANENT_SESSION_LIFETIME''''] = 3600

	//Store Value in session
	session[''''type''''] = "value"
','flask',1);
INSERT INTO "code_items" VALUES (164,'Sandboxing',' Sandboxing


 Example:


	<iframe sandbox="value">
		/*
		sandbox=""  Applies all restrictions
		allowforms  Reenables form submission
		allowpointerlock  Reenables APIs
		allowpopups  Reenables popups
		allowsameorigin  Allows the iframe content to be treated as being from the same origin
		allowscripts  Reenables scripts
		allowtopnavigation  Allows the iframe content to navigate its toplevel browsing context
		*/
	</iframe>

','flask',1);
INSERT INTO "code_items" VALUES (165,'Identifier based authorization',' Identifierbased authorization


 Example:


    """
    Define the whitelist pattern and validation type and input parameter like:
    identity("page1,page2", "alphanumeric", page)
    """

    def identity(whiteListPattern, validationType, inputParameter):

    	continue = True

    	"""
    	First, we want to filter the filenames for expected values. For this example we use only az/09
    	Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
    	for more information about validation see "input validations" in the code examples:
    	"""

    	if inputValidation(inputParameter, validationType, "Invalid userinput", "HIGH", countLevel) == False:
            continue = False

    	"""
    	Second, we want to whitelist the filenames for expected values, in this example they are,
    	page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
    	"""

    	if whitelisting(whiteListPattern, inputParameter) == False:
            continue = False

    	"""
    	Whenever you are checking whether a user is restricted to review certain data,
    	the access restrictions should be processed server side.
    	The userID could be stored inside a session variable on login, and should be used to
    	retrieve user data from the database:
    	"""
    	
        if continue == True : 

    		"""
    		We count the number of connections towards the database,
    		See "aggregate user controls" code example for more information:
    		"""

            countAccess(1)
            data = Table.query.filter_by(id=session[''''id''''], page=inputParameter).first()

            return data

        else:

            return False','flask',1);
INSERT INTO "code_items" VALUES (166,'Charsets',' Charsets


 Example:


    """
    In order to set the "Charsets" header you''''ll have to add the following code to the head of your application, the following code could be used in your controller: For Example, text/html
    """

    //You add directly into the HTML markup
    <meta httpequiv="ContentType" content="text/html; charset=utf8">

    @app.after_request
    def content_Type_Charset(response):
      response.headers["ContentType"] = "text/html; charset=utf8"
      return response
','flask',1);
INSERT INTO "code_items" VALUES (167,'Content type headers',' Content type headers


 Example:


	//Content Type Header for HTML pages
	response.headers["ContentType"] = "text/html; charset=UTF8"
    return response

    //Content Type Header for JSON objects
	response.headers["ContentType"] = "application/json"
    return response    
','flask',1);
INSERT INTO "code_items" VALUES (168,'XML injection prevention',' XML injection prevention


 Example:


    """
	Whenever you are using XML parsers you must sanitize or encode al userinput before
	including this input into your XML file.

	Some methods like below, the Dom document already encodes the input before storing it
	into the XML. But beware, since this encoded input is still a threat whenever you are
	displaying the this data on screen as HTML output. This encoded data should be escaped
	at all times before displaying.

	Whenever your XML function does not encode your data on the fly, you may want to write
	your own function for achieving this. See the code examples and search for "Input encoding"
	for more detailed information.
	"""


	//Let us take an easy example where we store your favorite number name into a XML file.
	from lxml import etree

	//Create Root Element employees

	root = etree.Element("employees")
	
	//Create child Element for employees
	employee = etree.SubElement(root, "employee")
	name = etree.SubElement(employee, "name")
	
	//Insert the text in name tag
	name.text = request.form[''''name'''']

	//Save it in xml file
	with open("test.xml", "w") as f:
		f.write(etree.tostring(root, pretty_print=True))

	"""
	We will try to insert <script>alert(123);</script> into the XML file,
	Now after inserting the employee name into the XML file it will look like:

	<?xml version="1.0"?>
	<employees>
		<employee>
			<name>&lt;script&gt;alert(123);&lt;/script&gt;</name>
		</employee>
	</employees>

	As you can see de input has been encoded but still can trigger an XSS whenever we
	extract the data as shown in the example below:

	NOTE: if you ever want to include the xml files by means of userselected sources,
	be aware of the fact that an attacker could also include sources from external websites
	and even execute External entity injections on your applications. See the "XSLT injection prevention"
	code example for more detailed information on how to implement this type of functionality since
	the same principle''''s apply to both functions.
	"""
	
		//Read from a XML file
		x = etree.parse("test.xml")


		for element in x.iter("name"):
   	 		//This example is vulnerable to XSS
   	 		print element.text

   	 		//This example is escaped
   	 		print escape(element.text)

	"""
	We recommend to not rely solely on the encoding of the input by the Dom document.
	So before you insert userinput into the XML file you want to have it sanitized.
	See the "Encoding" and "input validation" code examples for more detailed information
	"""

 
','flask',1);
INSERT INTO "code_items" VALUES (169,'File upload',' File upload



 Example:

 todo: file size restrictions
    
	import os
	from flask import render_template, flash
	from flask import Flask, render_template,request, redirect
	from flask import url_for,send_from_directory
	from werkzeug.utils import secure_filename

	"""
	Always store the uploaded files in a directory somewhere outside the document root or that is not 
	accessible from the web. Because there is chance that attacker could upload malicious file and 
	later access it via the web server. 
	"""
	
	//Path to the upload directory
	app.config[''''UPLOAD_FOLDER''''] = ''''~/uploads/''''
	
	//Extensions which are accepted to be uploaded
	app.config[''''ALLOWED_EXTENSIONS''''] = set([''''png'''', ''''jpg'''', ''''jpeg'''', ''''pdf''''])
	
	//Check whether the file can be uploaded
	def allowed_file(filename):
	    return ''''.'''' in filename and \
	           filename.rsplit(''''.'''', 1)[1].lower() in app.config[''''ALLOWED_EXTENSIONS'''']

	//File upload route
	@app.route(''''/upload'''', methods=[''''POST''''])
	def upload_file():
		setLog(0, "Upload function has started", "SUCCESS", str(datetime.utcnow()), "HIGH")

	    //Check if the post request has the file part
	    if ''''file'''' not in request.files:
	        flash(''''No file part'''')
	        return redirect(request.url)
	    
	    //Get the name of the uploaded file
	    file = request.files[''''file'''']

	    //Submit a empty part without filename
	    if file.filename == '''''''':
	        flash(''''No selected file'''')
	        setLog(0, "No File was selected", "FAIL", str(datetime.utcnow()), "HIGH")
	        return redirect(request.url)
	    
	    //Check if the file is one of the allowed types/extensions
	    if file and allowed_file(file.filename):
	        
	        //Make the filename safe, remove unsupported chars
	        filename = secure_filename(file.filename)
	
	        //Remove the input when filename contains more than single dot
	        if len(filename.split(''''.'''')) > 1:
	        	return redirect(request.url)

	        //Move the file form the temporal folder to the upload folder we setup
	        file.save(os.path.join(app.config[''''UPLOAD_FOLDER''''], filename))

	        //Redirect the user to the uploaded_file route, which will basically show on the browser the uploaded file
	        setLog(0, "Upload was successful", "SUCCESS", str(datetime.utcnow()), "HIGH")
	        return redirect(url_for(''''uploaded_file'''', filename=filename))
	        
	    else:
	        flash(''''Not allowed extensions'''')       
	        //Log the unsuccessful upload
	        setLog(0, "Upload was not successful, not allowed extensions", "FAIL", str(datetime.utcnow()), "HIGH")
	        return redirect(request.url)

	@app.route(''''/uploads/<filename>'''')
	def uploaded_file(filename):
	    return send_from_directory(app.config[''''UPLOAD_FOLDER''''], filename)
	
','flask',1);
INSERT INTO "code_items" VALUES (170,'Privilege based authentication',' Privilege based authentication


 Example:

        
    """
    For privilege based authentication we need an extra table in your database in order to write the users privileges to.

    TABLE users
        
    | userID | userName | password | privilegeID |    access	| AggregateControl	  |
       
    | 1	     | Admin	  | Csdar323 |	  1		     | 	   TRUE		|		2336		          |
       	
    |	2	     | User		  | Adf4fsv  |	  2		     |	   FALSE	|		 0		        	  |
       
    |	3	     | Guest	  | dff4fKr  |	  3		     |	   TRUE		|		135		        	  |
       

    TABLE privileges
       
    | privilegeID | privilege 		   |
    
    |   1	 	      | edit:read:delete |
    
    |	  2	 	      | edit:read		     |
    
    |	  3	 	      | read			       |
    

    Now instead of using roles in sessions we rather want to assign privileges to users
    by means of a DatabaseBased Authentication system.
    Now we can easily assign a user certain privileges for him to access.

    Here is the isAuthorized function in which we check whether the user is permitted to do the action
    """

    def isAuthorized(ispermitted):

      //Select Privilege from the database
      data = Users.query.join(privileges, Users.projectID==privileges.projectID).filter_by(Users.userId==session[''''id''''], privileges.access=''''TRUE'''').all()

      privilege = data.privilege

      //We first explode the value''''s to see how much parts the arrays consists of
      permission = privilege.split('''':'''')
      authorization = ispermitted.split('''':'''')

      //Then we count the authorization array
      count = len(authorization)
      counthits = 0

      """
      We check the permissions against the ispermitted value to see how many times
      they match. whenever they match we count the hits
      """

      for value in permission:
        if value == ispermitted:
          counthits = countshits + 1

      """
      Whenever the counts hits are greater or equal to the needed permissions
      we now know we deserved access to the part of the system.
      """

      if counthits > count:
        //Log that the user had sufficient privileges:
        setLog(session[''''id''''], "User was privileged!", "SUCCESS", str(datetime.utcnow()), privilege, "NULL")
        return True
      else:
        //Log that the user had sufficient privileges:
        setLog(session[''''id''''], "User was not privileged!", "FAIL", str(datetime.utcnow()), privilege, "HIGH")

        """
        Set counter; if counter hits 3, the user''''s session must be terminated.
        After 3 session terminations the user''''s account must be blocked.
        Given the high threat level, there will be immediate session termination.
        in this case the user tried to manipulate the application operation in order to do things he is not
        privileged to, immediate session termination will follow!
        """

        Counter.increment(3)
        return False
        ','flask',1);
INSERT INTO "code_items" VALUES (171,'HTML output',' HTML output


 Example:


    """
    Whenever user input is displayed in the application, whether, as content or a parameter value
    submitted towards the url, all user input should be properly escaped to prevent XSS injections.

    Flask uses the Jinja2 templating engine which does auto escaping for you in the right context, with the
    exception of user supplied input being used in a "href" attribute
    """

    from flask import Flask, request, url_for, render_template, redirect

    app = Flask(__name__, static_url_path=''''/static'''', static_folder=''''static'''')
    app.config[''''DEBUG''''] = False

    @app.route("/")
    def start():
        return render_template("index.html")

    @app.route("/home", methods=[''''POST''''])
    def home():
        xss = request.form[''''string'''']
        return render_template("index.html",xss = xss)
        
    if __name__ == ''''__main__'''':
        app.run(debug=True,host=''''0.0.0.0'''')


    """
    in order to detect XSS see if the auto escape function is used
    """

    <p style="fontsize:2em;"> {% autoescape false %}{{xss}}{% endautoescape %} </p>
    

    """
    A simple example to prevent XSS in Href attribute could be something like:
    """

    @app.route("/home", methods=[''''POST''''])
    def home():
        xss = request.form[''''string'''']
        if not line.startswith("https://"):
            EXIT code here
        return render_template("index.html",xss = xss)','flask',1);
INSERT INTO "code_items" VALUES (172,'X XSS Protection header',' XXSSProtection header


 Example:

    
    """
    In order to set the XXSSProtection header, you''''ll have to add the following code to the head of your application

    For adding XXSS Protection in every page we have to add a middleware
    Make a middleware in yourapp/middleware.py
    """

    class MyMiddleware:

    	def __init__(self, get_response):
        	self.get_response = get_response

    	def __call__(self, request):
        	response = self.get_response(request)
        	response[''''XXSSProtection''''] = "1; mode=block"
        	return response
   	
   	//For adding middleware in the project, add in yourproject/settings.py
   	MIDDLEWARE = [
    	...,
    	''''yourapp.middleware.MyMiddleware'''',
    	...,
	]	

	//For adding in the individual response page using render_to_response
	response = render_to_response("template.html", {})
	response[''''XXSSProtection''''] = ''''1; mode=block''''

	return response

	//For adding in the individual response page using render
	response = render(request, "template.html", {})
	response[''''XXSSProtection''''] = ''''1; mode=block''''

	return response','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (173,'Enforce secure passwords',' Enforce secure passwords


 Example:

    
    def checkPassword(pwd):
    	error = []
    	proceed = True

    	//Recommended a longer password for Security
    	if(len(pwd) < 13):
        	error.append("Password is too Short!!")
        	proceed = False
    
		"""
		The password should include at least one number, a small letter, a CAPS,
		and a special character as defined in the patterns array:
		"""
    
    	if not any(x.isupper() for x in pwd):
        	error.append(''''Your password needs at least 1 capital letter'''')
    	if not any(x.islower() for x in pwd):
        	error.append(''''Your password needs at least 1 small letter'''')
    	if not any(x.isdigit() for x in pwd):
        	error.append(''''Your password needs at least 1 digit'''')

		"""
		Even though your password is sufficient according to all your standards, the password could still be weak.
		Just imagine the password "Password!"; this could easily be guessed by an attacker. To prevent the use of weak passwords we 
		compare the password with a list of top 500 bad passwords and if matched, the password wil be rejected:
		"""

    	file = open(''''badpasswords.txt'''').read()
    	pattern = file.split(",") 

    	for value in pattern:
        	if value != pwd:
            	pass
        	else:
            	error.append("Your password was matched with the bad password list, please try again.")
            	proceed = False
            	break
    	if proceed == True:
        	flash("Your password is allowed!")
        	return True
        else:
        	flash("Password validation failure(your choice is weak):")
        	for x in error:
            	print x
        	return False','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (174,'Re authentication',' Reauthentication


 Example:


    """
    Whenever a user wants to change his credentials or do other important data exchanges such as
    transferring money he should always be challenged to reauthenticate himself before
    allowing them to perform these actions.
    """
    
    from django.contrib.auth import authenticate, login

    def reauthenticate(request, password):
        //Access current_user
        current_user = request.user
        username = current_user.username
        //Authenticate user
        user = authenticate(request, username=username, password=password)
        //Validation of password 
        if user is not None:
            //After successful validation we will log that password was validated successfully
            log.info(''''Successful reauthentication user : {user} via ip: {ip}''''.format(
                user=user,
                ip=ip
            ))

            //Flush Session token 
            request.session.flush()
            //Make the current_user active
            current_user.is_active = 1
            //Save the session ID 
            login(request, user)
            //Success page 
            return render(request, ''''polls/home.html'''')
        else:
            //The user failed reauthenticating himself
            log.warning(''''Reauthentication Failed!! user : {user} via ip: {ip}''''.format(
                user=user,
                ip=ip
            ))
            //If authentication failed destroyed the session
            request.session.flush()
            return render(request, ''''polls/login.html'''')

    """
    Before we let a user perform certain actions he should first be challenged to authenticate
    himself. imagine the following scenario, the user wants to change his email address.
    """

    //Usage Example
    reauthenticate(password) ','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (175,'XSL injection prevention',' XSL injection prevention



 Example:


    """
	In order to prevent XSL injections you must enforce strict policy''''s whenever the
	files are loaded from a source controlled by an possible attacker.

	Let''''s say for example that the user can choose from several XSL files on your application.

	ABC.xsl arranges your employee names on alphabetical order
	CBA.xsl does not care and just shows the input by order of your XML file.

	Before we want to attach the XSL files to the style sheet we first want to
	do validation on the request to make sure the included file was one of our own pre
	defined files, example:
	including("file1.xsl,file2.xsl,etc", ''''filename'''' , $_GET[''''xslfile''''])
	"""

	def including(whiteListing, validation ,input, count):

		continue = True

		"""
		First, we want to filter the filenames for expected values. For this example we use only az/09 and .
		Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
		for more information about validation see "input validations" in the code examples:
		"""

		if inputValidation(inputParameter, validationType, "Invalid userinput", "HIGH") == False:
			continue = False

		"""
		We want to whitelist the paged for expected values, in this example they are,
		page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
		"""

		if whitelisting(whiteListing, input, count) == False:
			continue = False

		//If all went good we do the function
		if continue == True:
			//Load XML file
			root = etree.parse("test.xml")

			xslt_root = etree.XML(input)
			transform = etree.XSLT(xslt_root)

			//Transform the XML
			result_tree = transform(root)
		else: 
			return False','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (176,'Session cookies (domain)',' Session cookies (domain)


 Example:


	"""
	Whenever a session is started, and you want to share it over different domains,
	the domain value should be set to the specific domain

    For using sessions edit the middleware and make sure it contains ''''django.contrib.sessions.middleware.SessionMiddleware''''

    For adding HTTPONLY Cookies, we have to add the line in settings.py
    SESSION_COOKIE_HTTPONLY = True

    For adding Session Cookie age, we have to add the line in settings.py
    SESSION_COOKIE_AGE = 60000

    For setting session cookie domain, we have to add the line in settings.py
    SESSION_COOKIE_DOMAIN = ''''demo.yourdomain.com''''

	For setting session cookie name, we have to add the line in settings.py
	SESSION_COOKIE_NAME = ''''demo''''    
	
	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_PATH = ''''/''''

	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_SECURE = True
	"""

	//For adding session cookie
	request.session[''''test''''] = ''''test''''','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (177,'Directory listing',' Directory listing


 Example:


    """
    To disable or prevent directory access, add following line in your .htaccess file. If
    user points the browsers to a directory that does not have an index file, then a
    "403 Forbidden" error will be displayed:

    Add this line of code to your .htaccess file:
    """

    Options Indexes

	"""
	Python code to display the files from the uploads folder
	"""

	//Views.py

        def getFiles(request, whiteListPattern, validationType, inputParameter):

            continue = True
            
            """
            First, we want to filter the filenames for expected values. For this example we use only az/09  alphanumeric
            Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
            for more information about validation see "input validations" in the code examples:
            """
            
            if inputValidation(inputParameter, validationType) == False:
                continue = False

            """
            Second, we want to whitelist the filenames for expected values, in this example they are,
            page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
            """

            //Check for filename Whitelisting
            if whitelisting(whiteListPattern, inputParameter) == False:
                continue = False

            if continue == True:
                //Create Path
                path = os.path.join(settings.MEDIA_ROOT, inputParameter)   
                images = []

                //List all the URL
                for f in os.listdir(path):
                    if f.endswith("jpg") or f.endswith("png"):
                        images.append("%s%s/%s" % (settings.MEDIA_URL, inputParameter, f))
                return render_to_response(''''gallery.html'''', {''''images'''': images})
            else:
                return render_to_response(''''gallery.html'''', {''''images'''': ''''''''})                

        //gallery.html
        {% for image in images %}
        <img src=''''{{image}}'''' />
        {% endfor %}','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (178,'RFD and file download injection prevention',' Reflective file download and file download injection prevention


 Example:


	import os
	from django.conf import settings
	from django.http import HttpResponse

	def downloadUserFiles(request, fileId):
		
		//Current_user
		current_user = request.user
		proceed = True

		"""
		For the sake of example we only allow the users to download their own files
		by identifier based sql query''''s. As you can see we select the filename
		by its id. in this case we prevent direct userinput into the disposition header.
		"""

		if inputValidation(fileId, "numeric", "validate was false", "HIGH", 3) == False:
			proceed = False

		if proceed = True:
			file = Download.objects.filter(fileId=password, userId=current_user.id).first()
			filename = file.fileName
			mimeType = file.mimeType

			if filename:

				"""
				We also define the mimetype per download file.
				This is because whenever a user can only download images it is not necessary to set
				an uncommon contenttype header for it.
				NOTE: These mimetypes should not be stored based upon the mimetype which was send
				the response header when the user uploaded the file. This value can be easily
				manipulated with an intercepting proxy. You should get the mimetype from the file
				itself after it was stored on the server.
				"""

				file_path = os.path.join(settings.MEDIA_ROOT, filename)
				if os.path.exists(file_path):
					with open(file_path, ''''rb'''') as fh:
						response = HttpResponse(fh.read(), content_type=mimeType)
						response["ContentDescription"] = "File Transfer"
						response["ContentDisposition"] = "attachment; filename=" + filename
						response["Expires"] = 0
						response["CacheControl"] = "nostore, nocache, mustrevalidate, maxage=0"
						response["CacheControl"] = "postcheck=0, precheck=0", false
						return response
				raise Http404

	"""
	The second example is for whenever you are providing users with fixed downloads
	such as manuals etc. We do not only check if the file just exists, because that would
	allow an attacker to also download important other files from your server, so instead
	we whitelist them.
	"""
	
	def downloadStored(filename):
		if os.path.exists(file_path):
			with open(file_path, ''''rb'''') as fh:
				if whitelisting("file1.txt,file2.txt", $filename) != False:
					response = HttpResponse(fh.read(), content_type=''''text/plain'''')
					response.headers["ContentDescription"] = "File Transfer"
					response.headers["ContentDisposition"] = "attachment; filename=" + filename
					response.headers["Expires"] = 0
					response.headers["CacheControl"] = "nostore, nocache, mustrevalidate, maxage=0"
					response.headers["CacheControl"] = "postcheck=0, precheck=0", false
					response.headers["ContentLength"] = os.path.getsize(filename)
					return response
raise HTTP404','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (179,'X Content Type Options header',' XContentTypeOptions header



 Example:

    """
    In order to set the "XContentTypeOptions" header you''''ll have to add the following code to the head of your application

    For adding XContentTypeOptions in every page we have to add a middleware
    Make a middleware in yourapp/middleware.py
    """

    class MyMiddleware:

    	def __init__(self, get_response):
        	self.get_response = get_response

    	def __call__(self, request):
        	response = self.get_response(request)
        	response[''''XContentTypeOptions''''] = "nosniff"
        	return response
   	
   	//For adding middleware in the project, add in yourproject/settings.py
   	MIDDLEWARE = [
    	...,
    	''''yourapp.middleware.MyMiddleware'''',
    	...,
	]	

	//For adding in the individual response page using render_to_response
	response = render_to_response("template.html", {})
	response[''''XContentTypeOptions''''] = ''''nosniff''''

	return response

	//For adding in the individual response page using render
	response = render(request, "template.html", {})
	response[''''XContentTypeOptions''''] = ''''nosniff''''
	
	return response
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (180,'Audit logs',' Audit logs


 Example:


    """
    Django uses Python’s builtin logging module to perform system logging. 

    Methods which should be logged : 
         Data Addition
         Data modification
         Data deletion
         Data Exports
         Identifying security incidents
         Perfomance monitoring etc

    Python logging configurations consists of four parts:

      Loggers : is configured to have log level. Different log levels are DEBUG, INFO, 
                 WARNING, ERROR, CRITICAL. Each message that is written to the logger is a Log Record.
      Handlers : It describes particular logging behavior such as writing message on the screen, a file or to network socket.  
      Filters : We can place an additional criteria for logging process.
      Formatters : Formatters describe the exact format of that text.

    The logger module is inbuilt class in django for logging system information into files or sending logs through network.

    Different logging calls or mehtods : 
         logger.debug()
         logger.info()
         logger.warning()
         logger.error()
         logger.critical()
         logger.log()
         logger.exception()
    """

    //Configuring loggers with app in SETTINGS.PY
    """
    This creates polls app log file polls.log
    """
    LOGGING = {
        ''''version'''': 1,
        ''''disable_existing_loggers'''': False,
        ''''handlers'''': {
            ''''file'''': {
                ''''level'''': ''''DEBUG'''',
                ''''class'''': ''''logging.FileHandler'''',
                ''''filename'''': ''''debug.log'''',
            },
            ''''applogfile'''': {
                ''''level'''':''''DEBUG'''',
                ''''class'''':''''logging.handlers.RotatingFileHandler'''',
                ''''filename'''': os.path.join(DJANGO_ROOT, ''''polls.log''''),
                ''''maxBytes'''': 1024*1024*15,  15MB
                ''''backupCount'''': 10,
            },
        },
        ''''loggers'''': {
            ''''django'''': {
                ''''handlers'''': [''''file''''],
                ''''level'''': ''''DEBUG'''',
                ''''propagate'''': True,
            },
            ''''polls'''': {
                ''''handlers'''': [''''applogfile'''',],
                ''''level'''': ''''DEBUG'''',
            },
        },
    }

    //Get Client IP

    def get_client_ip(request):
        x_forwarded_for = request.META.get(''''HTTP_X_FORWARDED_FOR'''')
        if x_forwarded_for:
            ip = x_forwarded_for.split('''','''')[0]
        else:
            ip = request.META.get(''''REMOTE_ADDR'''')
        return ip

    //Example for logging error
    import logging

    //Get an instance of a logger
    logger = logging.getLogger(__name__)

    def my_view(request, arg1, arg):
        ...
        if bad_mojo:
            //Log an error message
            logger.error(''''Something went wrong!'''' + get_client_ip(request)) 


    //Example for logging critical
    import logging

    //Get an instance of a logger
    logger = logging.getLogger(__name__)

    def my_view(request, arg1, arg):
        ...
        if security_violation:
            //Log an critical message
            logger.critical(''''Security violation!'''' + get_client_ip(request))','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (181,'CSRF tokens',' CSRF tokens


 Example:

    
    """
    The random CSRF token generated need to be send to the server with every form submission. 

    The CSRF middleware and template tag provides easytouse protection against Cross Site Request Forgeries.
    The CSRF middleware is activated by default in the MIDDLEWARE setting.
    """

    """
    In HTML Forms, for specifying the CSRF we can use the below code
    """

    <form method="post">
    	{% csrf_token %}
	</form>

	"""
    For the AJAX POST requests, ou have to remember to pass the CSRF token in as POST data with every POST request. For this reason, there is an alternative method: on each XMLHttpRequest, set a custom XCSRFToken header to the value of the CSRF token.

    The CSRF token cookie is named csrftoken by default, but you can control the cookie name via the CSRF_COOKIE_NAME setting.

    The CSRF header name is HTTP_X_CSRFTOKEN by default, but you can customize it using the CSRF_HEADER_NAME setting.
	"""

	<script type="text/javascript">
    
    // using jQuery
    function getCookie(name) {
        var cookieValue = null;
        if (document.cookie && document.cookie !== '''''''') {
            var cookies = document.cookie.split('''';'''');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) === (name + ''''='''')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    $.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {
                xhr.setRequestHeader("XCSRFToken", getCookie(''''csrftoken''''));
            }
        }
    });
	</script>

    //Using CSRF in Jinja Templates
    <form action="" method="post">{{ csrf_input }}','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (182,'Logout function',' Logout function


 Example:


    """
    This way, the logout functionality will revoke the complete session:
    """
  
    from django.contrib.auth import logout

    def logout_view(request):   
        //Logging logout
        log.info(''''Logout Successful : {user} via ip: {ip}''''.format(
            user=user,
            ip=ip
        ))
        logout(request)
        //Redirect to a success page.
        return redirect(''''login'''')

    """
    Django has inbuilt logout functionality
    """

    //Adding urls.py 
    from django.conf.urls import url
    from django.conf import settings
    from django.contrib.auth.views import logout

    urlpatterns = [
        url(r''''^logout/$'''', logout, {''''next_page'''': settings.LOGOUT_REDIRECT_URL}, name=''''logout'''')
    ]

    //Add URI in Settings.py
    LOGOUT_REDIRECT_URL = ''''/login''''
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (183,'White listing',' Whitelisting


 Example:


    """
    First we create a function which checks the allowed patterns:
    whitelisting("value1,value2,value3" , input)
    Whitelisting is checking if a value is identically the same as the whitelist we created. Please rewrite the below part to reflect this.
    """

    def whitelisting(allowed, input):
        result = allowed.split('''','''')
        flag = False
        for x in result:
            if x == match:
            //If the value is valid we send a log to the logging file
            setLog(session["id"], "Good whitelist validation", "SUCCESS", datetime.utcnow(),"HIGH")
            flag = True
            //Whenever there was a valid match we return true
            return True
            
        //Check for a false in order to send error to log and counter the user
        if flag == False:
            //If the whitelist is bad log the validation 
            setLog(session["id"], "Bad whitelist validation", "FAIL", datetime.utcnow(), "HIGH")            
            counter.increment()
            return False    
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (184,'Session hijacking and fixation',' Session hijacking and fixation


 Example:

    
    """
    Session hijacking and Session fixation are attempts to gain access to another user. 
    We Should never put session IDS in the URL, use SSL and secure connection and HTTP only
    Cookies.

    We should regenerate a SESSION ID when someone logs in. But Django does regenerating 
    Session ID automatically.  

    First we implement the strict transport security header, this is in order to prevent
    users from accessing your application over an unprotected connection.
    """

    //Example of the strict transport security header:
    response[''''StrictTransportSecurity''''] = "maxage=31536000"
    //If all present and future subdomains will be HTTPS:
    response[''''StrictTransportSecurity''''] = "maxage=31536000; includeSubDomains"    

    """
    Recommended: If the site owner would like their domain to be included in the HSTS preload
    list maintained by Chrome (and used by Firefox and Safari), then use:
    """

    response[''''StrictTransportSecurity''''] = "maxage=31536000; includeSubDomains; preload"    

    """
    The `preload` flag indicates the site owner''''s consent to have their domain preloaded.
    The site owner still needs to then go and submit the domain to the list. the preload list
    enforces the browser to always present your application on HTTPS even on the first time
    the user hits your application

    Then we set the httpOnly flag in settings.py
    (see "HttpOnly" in the code examples for more details about implementation)
    """
    	
    SESSION_COOKIE_HTTPONLY = True

    """
    Then we set the flag for session timeout in settings.py
    (see "Timeout" in the code examples for more details about implementation)
    """
    	
    SESSION_COOKIE_AGE = 60000 

    """
    Then we set the session secure flag in settings.py
    (see "Secure flag" in the code examples for more details about implementation)
    """
    
    SESSION_COOKIE_SECURE = True','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (185,'Random password token generation',' Random password/token generation


 Example:


	"""
	When needing to generate random numbers, always use proven methods 
	instead of writing your own.
	"""
	
	//Generate a strong security key
	app.secret_key = os.urandom(32)

	//A random string for generating WTF CSRF token
	app.config[''''WTF_CSRF_SECRET_KEY''''] = base64.b64encode(rand.bytes(128))
    
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (186,'Directory path traversal',' Directory/path traversal


 Example:

	"""
	Define the whitelist pattern and validation type and input parameter, countLevel like:
	getFiles("images,css,js", "alphanumeric", foldername)
	"""

	def getFiles(request, whiteListPattern, validationType, inputParameter):

		continue = True
        
        """
		First, we want to filter the filenames for expected values. For this example we use only az/09  alphanumeric
		Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
		for more information about validation see "input validations" in the code examples:
		"""
		
		if inputValidation(inputParameter, validationType) == False:
			continue = False

		"""
		Second, we want to whitelist the filenames for expected values, in this example they are,
		page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
		"""

		//Check for filename Whitelisting
		if whitelisting(whiteListPattern, inputParameter):
			continue = False

		if continue == True:
        	//Create Path
        	path = os.path.join(settings.MEDIA_ROOT, inputParameter)   
        	images = []

        	//List all the URL
        	for f in os.listdir(path):
            	if f.endswith("jpg") or f.endswith("png"):
                	images.append("%s%s/%s" % (settings.MEDIA_URL, inputParameter, f))
        
        	return render_to_response(''''gallery.html'''', {''''images'''': images})
        else:
			return render_to_response(''''gallery.html'''', {''''images'''': ''''''''})        	

    //gallery.html

    {% for image in images %}
    <img src=''''{{image}}'''' />
    {% endfor %}','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (187,'Input validation',' input validation


 Example:


	"""
	This function is where you store all your input validation controls. 
	It makes it easy to maintain whenever you want to apply changes for 
	certain input validation roles and reduces the chance of mistakes in your regexes.
	"""

	def isFile(str):
		//Check whether this Filename
		if re.match("^[AZaz09.]*$", str):
			return True
		else:
			return False

	def isAlphanumeric(str):
		match = re.findall("^[azAZ09]+$" , str)
		//Check for alphanumeric
		if match:
			return True
		else:
			return False

	def isAlpha(str):
		match = re.findall("^[azAZ]+$" , str)
		//Check for alpha
		if match:
			return True
		else:
			return False

	def isDigit(str):
		match = re.findall("^[09]+$" , str)
		//Check for isDigit
		if match:
			return True
		else:
			return False	

	def isBool(str):
	    match = re.findall("^(True|False)+$" , str)
		if match:
	        return True
	    else:
            return False	

	def inputValidation(input, type):
	    if type == alphanumeric:
	    	//Set the audit log
	    	log.debug(''''Boolean True: {user} via ip: {ip}''''.format(
	    	    user=user,
	    	    ip=ip
	    	))
	    	return isAlphanumeric(input)
	   	elif type == numeric:
	   		//Set the audit log
	   		log.debug(''''Boolean True: {user} via ip: {ip}''''.format(
	   		    user=user,
	   		    ip=ip
	   		))
	   		return isDigit(input)
	   	elif type == alpha:
	   		//Set the audit log
	   		log.debug(''''Boolean True: {user} via ip: {ip}''''.format(
	   		    user=user,
	   		    ip=ip
	   		))
	   		return isAlpha(input)
	   	elif type == bool:
	   		//Set the audit log
	   		log.debug(''''Boolean True: {user} via ip: {ip}''''.format(
	   		    user=user,
	   		    ip=ip
	   		))
	   		return isBool(input)
	   	elif type == filename:
	   		//Set the audit log
	   		log.debug(''''Boolean True: {user} via ip: {ip}''''.format(
	   		    user=user,
	   		    ip=ip
	   		))
	   		return isFile(input)
	   	else:
	   		//Set the audit log
	   		log.info(''''Boolean False: {user} via ip: {ip}''''.format(
	   		    user=user,
	   		    ip=ip
	   		))
	   		//Increment the counter
	    	counter.increment(1)
	   		return False

','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (188,'System commands',' System commands


 Example:


	"""
	Define the whitelist pattern and validation type and input parameter like:
	getFiles("value1,value2,etc", "alphanumeric", filename)
	"""

	def command(whiteListPattern, validationType, inputParameter){

		continue = True

		"""
		Whenever a system command is finished, you should properly sanitize and escape this user input.
		System command functions examples are: system(), eval(), exec()

		First, we want to filter the filenames for expected values. For this example we use only az/09
		Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
		for more information about validation see "input validations" in the code examples:
		"""

		if inputValidation(inputParameter, validationType) == False:
			continue = False

			"""
			Second, we want to whitelist the filenames for expected values, in this example they are,
			page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
			"""

		if whitelisting(whiteListPattern, inputParameter) == False:
			continue = False

		//If all went good we include the filename
		if continue == True:
			//Even though there is match we still escape the shelx.quote():
			command = ''''./configure {}'''' .format(quote(inputParameter))
			os.system(command)
		else:
			return False','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (189,'Session cookies HttpOnly',' Session cookies HttpOnly


 Example:


	"""
    Javascript cannot set or read cookie''''s value if the HTTPOnly attribute is set on cookie.
    It makes attacker client side attacks such as Cross Site scripting harder to exploit.
    Attacker will not be able to steal the user''''s cookies.

    For using sessions edit the middleware and make sure it contains ''''django.contrib.sessions.middleware.SessionMiddleware''''

    For adding HTTPONLY Cookies, we have to add the line in settings.py
    SESSION_COOKIE_HTTPONLY = True

    For adding Session Cookie age, we have to add the line in settings.py
    SESSION_COOKIE_AGE = 60000

    For setting session cookie domain, we have to add the line in settings.py
    SESSION_COOKIE_DOMAIN = ''''demo.yourdomain.com''''

	For setting session cookie name, we have to add the line in settings.py
	SESSION_COOKIE_NAME = ''''demo''''    
	
	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_PATH = ''''/''''

	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_SECURE = True
	"""

	//For adding session cookie
	request.session[''''test''''] = ''''test''''','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (190,'SQL query',' SQL query


 Example:


    """
    Django supports almost most of the database backend.  

    A model contains the essential fields and behaviors of the data you’re storing.
    Each model maps to a single database table.

    CREATE TABLE myapp_person (
    	"id" serial NOT NULL PRIMARY KEY,
    	"first_name" varchar(30) NOT NULL,
    	"last_name" varchar(30) NOT NULL
	);

	Model for the above SQL query
	"""

	from django.db import models

	class Publisher(models.Model):

   		name = models.CharField(max_length=30)
   		address = models.CharField(max_length=50)

		def __str__(self):

    		return '''' ''''.join([
        		self.name,
        		self.address,
    		])

    //In order to add your model to django, you have to add the app in INSTALLED_APP
    INSTALLED_APPS = [
    	//...
    	''''myapp'''',
    	//...
	]

	"""
	After adding the application, in order to make the changes we need to make migrations
	and migrate  For creating tables 
	"""

	$ python manage.py makemigrations
	$ python manage.py migrate
	//Needs to be added

	"""
	Inserting data into the database  create, add and commit
	"""
	
	book = Publisher(name=p1, address=p2)
	book.save()

	"""
	Delete entries from the table
	"""
	
	instance = Publisher.objects.get(name=name)
	instance.delete()

	"""
	Querying Records
	"""
	
	//Retrieve the user with username
	instance = Publisher.objects.filter(name=name).all()
	instance.address

	"""
	SQL raw string approach
	"""
	
	if inputValidation(inputParameter, ''''alphanumeric'''') == False:
		people = Person.objects.raw(''''SELECT * FROM myapp_person WHERE last_name = %s'''', [inputParameter])
	
		for p in people:
			print("%s is %s." % (p.first_name, p.age))','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (191,'Open forwards & redirects',' Open forwards & redirects


 Example:


    """
    When using forwards & redirects you should make sure the URL is being explicitly
    declared in the code and cannot be manipulated by an attacker like example.com?page=dashboard :
    """

    redirect(''''dashboard'''')

    """
    Generally you should avoid getting input into the redirect which could contain
    userinput by any means. if for any reason this may not be feasible than you
    should make a whitelist input validation for the redirect like so:

    Example : 
    If the whitelisting list is home, upload and redirectParam is home 

    redirectParam = home
    redirecting("home,upload", redirectParam, "3")
    """

    def redirecting(whitelisting, input, count):
        
        """
        We want to whitelist the paged for expected values, in this example they are,
        page1,page2 etc.. for more information about whitelisting see "whitelisting" 
        in the code examples:
        """

        if whitelisting(whitelisting, input, count) == True:
            //Redirect the Input if whitelisting is correct
            redirect(input)','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (192,'X path query',' Xpath query


 Example:

    
    """
    Define the allowed characters and input parameter and count level for the
    user lockout like:
    controller("<''''>&", $_GET[''''filename''''], "3")
    
    In order to prevent xpath injections we have to treat these query''''s similar as 
    to the sql query''''s. 
    """
    
    def controller(allowed, input, count):
        
        """
        First we build our encoding method, see "input validation" code example for
        more detailed information about encoding and escaping.
        """
        
        return = encoder(allowed, input, count)

        //If the encoder came back false we do not process the function!
        if return != False:

            //Parse the register.xml
            root = etree.parse("register.xml")
            //Extract the id from the XML using XPath
            find = etree.XPath(''''/Employees/Employee[ID='''' + return + '''']'''')

            for x in find(root):
                print x.text
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (193,'Anti caching headers',' Anticaching headers


 Example:

    
	"""
    In order to set the AntiCaching header you''''ll have to your application head in order to prevent the browser from caching

    For adding AntiCaching header in every page we have to add a middleware

    Make a middleware in yourapp/middleware.py
    """

    class MyMiddleware:

    	def __init__(self, get_response):
        	self.get_response = get_response

    	def __call__(self, request):
        	response = self.get_response(request)

        	response["CacheControl"] = "nostore, nocache, mustrevalidate" HTTP/1.1
			response["CacheControl"] = "postcheck=0, precheck=0, false"
			response["Pragma"] = "nocache"  HTTP/1.0
        	
        	return response
   	
   	//For adding middleware in the project, add in yourproject/settings.py
   	MIDDLEWARE = [
    	...,
    	''''yourapp.middleware.MyMiddleware'''',
    	...,
	]	

	"""
	For adding in the individual response page using render_to_response
	"""
	response = render_to_response("template.html", {})
	response["CacheControl"] = "nostore, nocache, mustrevalidate" HTTP/1.1
	response["CacheControl"] = "postcheck=0, precheck=0, false"
	response["Pragma"] = "nocache"  HTTP/1.0

	return response
	
	"""
	For adding in the individual response page using render
	"""

	response = render(request, "template.html", {})
	response["CacheControl"] = "nostore, nocache, mustrevalidate" HTTP/1.1
	response["CacheControl"] = "postcheck=0, precheck=0, false"
	response["Pragma"] = "nocache"  HTTP/1.0
	
	return response','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (194,'Secure session cookies',' Secure session cookies


 Example:

    
    """
    If you use SLL you can also make your cookies secure (encrypted) to 
    avoid "maninthemiddle" cookies reading with

    For using sessions edit the middleware and make sure it contains ''''django.contrib.sessions.middleware.SessionMiddleware''''

    For adding HTTPONLY Cookies, we have to add the line in settings.py
    SESSION_COOKIE_HTTPONLY = True

    For adding Session Cookie age, we have to add the line in settings.py
    SESSION_COOKIE_AGE = 60000

    For setting session cookie domain, we have to add the line in settings.py
    SESSION_COOKIE_DOMAIN = ''''demo.yourdomain.com''''

	For setting session cookie name, we have to add the line in settings.py
	SESSION_COOKIE_NAME = ''''demo''''    
	
	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_PATH = ''''/''''

	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_SECURE = True
	"""

	//For adding session cookie
	request.session[''''test''''] = ''''test''''','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (195,'Crossdomain.xml ',' Crossdomain.xml


 Example:

    
		//A bad example of a crossdomain.xml would be:

		<?xml version="1.0" ?>
		<crossdomainpolicy>
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowaccessfrom domain="*"/>
			<allowhttprequestheadersfrom domain="*" headers="*"/>
		</crossdomainpolicy>

		//Because it allows access from all other domains.

		//Instead of this approach you might want to use the following restrictions.
		//Example by twitter''''s crossdomain.xml:

		<?xml version="1.0" encoding="UTF8"?>
		<crossdomainpolicy xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance" xsi:noNamespaceSchemaLocation="http://www.adobe.com/xml/schemas/PolicyFile.xsd">
			<allowaccessfrom domain="twitter.com" />
			<allowaccessfrom domain="api.twitter.com" />
			<allowaccessfrom domain="search.twitter.com" />
			<allowaccessfrom domain="static.twitter.com" />
			<sitecontrol permittedcrossdomainpolicies="masteronly"/>
			<allowhttprequestheadersfrom domain="*.twitter.com" headers="*" secure="true"/>
		</crossdomainpolicy>
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (196,'Password forget and disallow old passwords',' Password forget & Disallow old passwords


 Example:


    """
    Django has inbuilt feature of password reset. We just have to mentions the URL routes and
    templates.
    """

    //We need to add django.contrib.auth in INSTALLED_APPS
    INSTALLED_APPS = [
        ...
        ''''django.contrib.auth'''',
    ]

    //Add URL routes for forget password
    from django.contrib.auth import views as auth_views

    urlpatterns = [
        ...
        url(r''''^password_reset/$'''', auth_views.password_reset, {''''template_name'''': ''''polls/password_reset_form.html''''} , name=''''password_reset''''),
        url(r''''^password_reset/done/$'''', auth_views.password_reset_done, {''''template_name'''': ''''polls/password_reset_done.html''''}, name=''''password_reset_done''''),
        url(r''''^reset/(?P<uidb64>[09AZaz_\]+)/(?P<token>[09AZaz]{1,13}[09AZaz]{1,20})/$'''',
            auth_views.password_reset_confirm, {''''template_name'''': ''''polls/password_reset_confirm.html''''} , name=''''password_reset_confirm''''),
        url(r''''^reset/done/$'''', auth_views.password_reset_complete, {''''template_name'''': ''''polls/password_reset_complete.html''''} , name=''''password_reset_complete''''),    
    ]

    //Template for password_reset_form.html
    
    {% extends ''''base.html'''' %}
    {% block content %}
      <h3>Forgot password</h3>
      <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Submit</button>
      </form>
    {% endblock %}

    //Template for password_reset_subject.txt
    Password reset for Website
    //Template for password_reset_email.html
    {% autoescape %}
    To initiate the password reset process for your {{ user.get_username }} TestSite Account,
    click the link below:

    {{ protocol }}://{{ domain }}{% url ''''password_reset_confirm'''' uidb64=uid token=token %}
    If clicking the link above doesn''''t work, please copy and paste the URL in a new browser
    window instead.

    Sincerely,
    The TestSite Team
    {% endautoescape %}
  
    //Template for password password_reset_done.html
    {% extends ''''base.html'''' %}
    {% block content %}
      <p>
        We''''ve emailed you instructions for setting your password, if an account exists with the email you entered.
        You should receive them shortly.
      </p>
      <p>
        If you don''''t receive an email, please make sure you''''ve entered the address you registered with,
        and check your spam folder.
      </p>
    {% endblock %}

    //Template for password_reset_confirm.html
    {% extends ''''base.html'''' %}
    {% block content %}
      {% if validlink %}
        <h3>Change password</h3>
        <form method="post">
          {% csrf_token %}
          {{ form.as_p }}
          <button type="submit">Change password</button>
        </form>
      {% else %}
        <p>
          The password reset link was invalid, possibly because it has already been used.
          Please request a new password reset.
        </p>
      {% endif %}
    {% endblock %}

    //Template for password_reset_complete.html
    {% extends ''''base.html'''' %}
    {% block content %}
      <p>
        Your password has been set. You may go ahead and <a href="{% url ''''signin'''' %}">sign in</a> now.
      </p>
    {% endblock %}

    //Setting Up SMTP Email Backend in settings.py
    EMAIL_HOST = ''''smtp.sendgrid.net''''
    EMAIL_PORT = 587
    EMAIL_HOST_USER = ''''test''''
    EMAIL_HOST_PASSWORD = ''''password''''
    EMAIL_USE_TLS = True
    DEFAULT_FROM_EMAIL = ''''Test <noreply@example.com>''''
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (197,'XML External entities',' XML External entities


 Example:

    
	"""
	Django’s serialization framework provides a mechanism for “translating” Django models into other formats. By which we can avoid XXE while using XML. 
	
	Models can be easily translated to other formats such as XML, Json, YAML
	"""

	//Serialization of SomeModel defined in Models.py
	from django.core import serializers 
	data = serializers.serialize("xml", SomeModel.objects.all())

	//Save serialized data to file file.xml	
	XMLSerializer = serializers.get_serializer("xml")
	xml_serializer = XMLSerializer()
	with open("file.xml", "w") as out:
		xml_serializer.serialize(Question.objects.all(), stream=out)
	data = xml_serializer.getvalue()

	//Deserialize the XML
	for obj in serializers.deserialize("xml", data):
		//Accessing object
		obj.object


	






','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (198,'Anti clickjacking headers',' Anti clickjacking headers


 Example:


    """  
    One way to defend against clickjacking is to include a "framebreaker" script in each
    page that should not be framed. The following methodology will prevent a webpage from
    being framed even in legacy browsers, that do not support the XFrameOptionsHeader.
    In the document HEAD element, add the following:
    First apply an ID to the style element itself:
	  """

    <style id="antiClickjack">body{display:none !important;}</style>
    //And then delete that style by its ID immediately after in the script:

    <script type="text/javascript">
	   if (self === top) {
		   var antiClickjack = document.getElementById("antiClickjack");
		   antiClickjack.parentNode.removeChild(antiClickjack);
	   } else {
		   top.location = self.location;
	   }
    </script>

    """
    To set the same XFrameOptions value for all responses in your site, put ''''django.middleware.clickjacking.XFrameOptionsMiddleware'''' to MIDDLEWARE:

    MIDDLEWARE = [
        ...
        ''''django.middleware.clickjacking.XFrameOptionsMiddleware'''',
        ...
    ]

    Middleware will be enabled by default while starting the project.
    By default the XFrameOptions header is set to SAMEORIGIN  
    """

    //If we want to set the X_FRAME_OPTIONS to DENY
    //If you want DENY instead, set the X_FRAME_OPTIONS setting

    X_FRAME_OPTIONS = ''''DENY''''
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (199,'Debug enabling',' Debug Enabling


 Example:


    """
    Debug mode makes it a major security risk and therefore it must never be used on production machines. Django will display a detailed traceback with more details about the application such 
    as Django settings
    """

    //The default settings.py file created by djangoadmin startproject sets DEBUG = True
    //It should be set to False in production 
    DEBUG = False','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (200,'Login functionality',' Login functionality


 Example:


    """
    For privilege based authentication we need an extra table in your database in order to write the users privileges to.

    Django has inbuilt users table 

    TABLE users
    
    |ID|password|last_login|is_superuser|first_name|last_name|email|is_staff|is_active|date_joined|username |
      
    |1 |pbkdf2_s|20170831|	  0		| 	ram    |  mohan  |ra@..|   0    |    1    |20170831.| ram12   |
      	
    |2 |pbkdf2_s|20170829|	  0	    |	james  |  mathew |j@g..|   1    |    1    |20170830.| mathew  |
      
    |3 |pbkdf2_s|20170830|	  1	    |	admin  |  admin  |adm@.|   1    |    1    |20170829.| admin   |
       


    Now instead of using roles in sessions we rather want to assign privileges to users
    by means of a DatabaseBased Authentication system.
    Now we can easily assign a user certain privileges for him to access.
    See "Privilege based authentication" code example for more information:
    
    Django authentication in default has inbuilt code for most part of the authentication
    such as login, logout, password reset
    """
    
    //Create a login Template using form in django
    //File location registration/login.html

    {% extends ''''base.html'''' %}
    {% block title %}Login{% endblock %}
    {% block content %}
      <h2>Login</h2>
      <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Login</button>
      </form>
    {% endblock %}

    //First we need to Configure the URL routes
    //We need to import django.contrib.auth.views and add URL route for login and logout views 

    from django.conf.urls import url
    from django.contrib.auth import views as auth_views

    urlpatterns = [
        url(r''''^login/$'''', auth_views.login, {''''template_name'''': ''''core/login.html''''} ,name=''''login''''),
        url(r''''^logout/$'''', auth_views.logout, name=''''logout''''),
    ]
    
    //In settings.py, we can set the location where django will redirect after authentication
    LOGIN_REDIRECT_URL = ''''home''''

    """
    There is no need to write login view again, Django has inbuilt view for login.
    Proper input validation is also done in Django auth_view.login takes care for security.
    But we need to implement a proper logging system for logouts, logins, retries
    """

    //Logging is also a inbuilt feature in django, only we need to configure it
    //Add logging system in Settings.py which logs app wise

    LOGGING = {
        ''''version'''': 1,
        ''''disable_existing_loggers'''': False,
        ''''handlers'''': {
            ''''file'''': {
                ''''level'''': ''''DEBUG'''',
                ''''class'''': ''''logging.FileHandler'''',
                ''''filename'''': ''''debug.log'''',
            },
            ''''applogfile'''': {
                ''''level'''':''''DEBUG'''',
                ''''class'''':''''logging.handlers.RotatingFileHandler'''',

                //Specify the logging file name
                
                ''''filename'''': os.path.join(DJANGO_ROOT, ''''polls.log''''),
                ''''maxBytes'''': 1024*1024*15,  15MB
                ''''backupCount'''': 10,
            },
        },
        ''''loggers'''': {
            ''''django'''': {
                ''''handlers'''': [''''file''''],
                ''''level'''': ''''DEBUG'''',
                ''''propagate'''': True,
            },
            ''''polls'''': {
                ''''handlers'''': [''''applogfile'''',],
                ''''level'''': ''''DEBUG'''',
            },
        },
    }

    //Add view for logging, logout, wrong logins in view.py

    import logging
    from django.contrib.auth.signals import user_logged_in, user_logged_out, user_login_failed
    from django.dispatch import receiver

    //Create your views for logging
    log = logging.getLogger(__name__)

    @receiver(user_logged_in)
    def user_logged_in_callback(sender, request, user, **kwargs):

        //Track the IP
        ip = request.META.get(''''REMOTE_ADDR'''')

        //Logging the details 
        log.debug(''''login user: {user} via ip: {ip}''''.format(
            user=user,
            ip=ip
        ))

    @receiver(user_logged_out)
    def user_logged_out_callback(sender, request, user, **kwargs):

        ip = request.META.get(''''REMOTE_ADDR'''')

        log.debug(''''logout user: {user} via ip: {ip}''''.format(
            user=user,
            ip=ip
        ))

    @receiver(user_login_failed)
    def user_login_failed_callback(sender, credentials, **kwargs):

        log.warning(''''logout failed for: {credentials}''''.format(
            credentials=credentials,
        ))','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (201,'User registration SQL truncation',' User registration / Sql truncation prevention


 Example:

    """
    In order to prevent Column truncation sql injection Solution we have to make sure the
    applications structural logic does not mismatches with the database structural logic.
    To achieve this imagine the follow example of a database structure of a users table

    TABLE users
    
    |	     *Name*          |	   *Type*       |    *Extra*     |
    
    |        ID	           |    Int(11)       | AUTO_INCREMENT |
    
    |       Username  	   |    char(21)      |                |
    
    |       Password       |  Varchar(255)    |                |
    
    |      last_login      |      date        |                |
       
    |      is_superuser    |      int(1)      |                |
    
    |      first_name      |    varchar(30)   |                |
    
    |      last_name       |    varchar(30)   |                |
    
    |      email           |    varchar(30)   |                |
    
    |      is_staff        |      int(1)      |                |
    
    |      is_active       |      int(1)      |                |
    
    |      date_joined     |      date        |                |
    
    """

    //For URL routes for User Registration

    from django.conf.urls import url
    from mysite.core import views as core_views

    urlpatterns = [
        ...
        url(r''''^signup/$'''', core_views.signup, name=''''signup''''),
    ]

    //View for signup
    from django.contrib.auth import login, authenticate
    from django.shortcuts import render, redirect

    from .forms import SignUpForm

    def signup(request):
        if request.method == ''''POST'''':
            form = SignUpForm(request.POST)
            if form.is_valid():
                form.save()
                username = form.cleaned_data.get(''''username'''')
                raw_password = form.cleaned_data.get(''''password1'''')
                user = authenticate(username=username, password=raw_password)
                login(request, user)
                return redirect(''''index'''')
        else:
            form = SignUpForm()
        return render(request, ''''polls/signup.html'''', {''''form'''': form})

    //Template for signup.html
    {% block content %}
      <h2>Sign up</h2>
      <form method="post">
        {% csrf_token %}
        {% for field in form %}
          <p>
            {{ field.label_tag }}<br>
            {{ field }}
            {% if field.help_text %}
              <small style="color: grey">{{ field.help_text }}</small>
            {% endif %}
            {% for error in field.errors %}
              <p style="color: red">{{ error }}</p>
            {% endfor %}
          </p>
        {% endfor %}
        <button type="submit">Sign up</button>
      </form>
    {% endblock %}

    //forms.py for extra fields
    class SignUpForm(UserCreationForm):
    first_name = forms.CharField(max_length=30, required=False, help_text=''''Optional.'''')
    last_name = forms.CharField(max_length=30, required=False, help_text=''''Optional.'''')
    email = forms.EmailField(max_length=254, help_text=''''Required. Inform a valid email address.'''')

    class Meta:
        model = User
        fields = (''''username'''', ''''first_name'''', ''''last_name'''', ''''email'''', ''''password1'''', ''''password2'''', )            ','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (202,'Encoder',' Character encoding


 Example:

    """
    This is the encoder class for whenever you have to allow certain
    possibly dangerous characters into your code for i.e names such as O''''Reilly
	"""

	def encoder(allowed, input, count):
	    
	    """
	    As you can see you can specify allowed characters in your function
	    """
	    
	    flag = True
	    match = re.findall("/^[azAZ09 " + allowed+"]+$/", input)

	    if match:

	        """
	        Set a log for whenever there is unexpected userinput with a threat level
	        See "audit logs" code example for more information:
	        """

	        setLog(session[''''id''''], "Bad userinputs", "FAIL", datetime.utcnow(), "HIGH")
	        
	        """
	        Set counter if counter hits 3 the users session must terminated
	        After 3 session terminations the user account must be blocked
	        See "audit logs" code example for more information:
	        """
	        
	        counter.increment()
	        flag = False

	         Remove Dangerous Characters
	        wordDict = {''''&'''': ''''&amp;'''', ''''<'''' : ''''&lt;'''', ''''>'''' : ''''&gt;'''' , ''''"'''' : ''''&quot;'''', "''''" : ''''&x27;'''', ''''/'''' : &x2F;, ''''\'''' : ''''\\''''}

	        for key in wordDict:
	        	input = input.replace(key, wordDict[key])

	        return input
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (203,'Character encoding',' Character encoding


 Example:


    """
    This is the encoder class for whenever you have to allow certain
    possibly dangerous characters into your code for i.e names such as O''''Reilly
	"""

	def encoder(allowed, input, count):
	    
	    """
	    As you can see you can specify allowed characters in your function
	    """
	    
	    flag = True
	    match = re.findall("/^[azAZ09 " + allowed+"]+$/", input)

	    if match:

	        """
	        Set a log for whenever there is unexpected userinput with a threat level
	        See "audit logs" code example for more information:
	        """

	        setLog(session[''''id''''], "Bad userinputs", "FAIL", datetime.utcnow(), "HIGH")
	        
	        """
	        Set counter if counter hits 3 the users session must terminated
	        After 3 session terminations the user account must be blocked
	        See "audit logs" code example for more information:
	        """
	        
	        counter.increment()
	        flag = False
	        //Remove Dangerous Characters
	        wordDict = {''''&'''': ''''&amp;'''', ''''<'''' : ''''&lt;'''', ''''>'''' : ''''&gt;'''' , ''''"'''' : ''''&quot;'''', "''''" : ''''&x27;'''', ''''/'''' : &x2F;, ''''\'''' : ''''\\''''}

	        for key in wordDict:
	        	input = input.replace(key, wordDict[key])
	        return input
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (204,'Aggregate user controls',' Aggregate user controls


 Example:

 
    """
    In order to enforce Aggregate access control protection the best method would be to
    define your rules by means of a database structure rather than sessions or log''''s.
    This is due to the fact that if the user drops his session the rating would start
    al over again.


    TABLE userAggregate
       
    |   id   | user_id  | AggregateControl	|
      
    |   1    | Admin    | 	  2322    	    |
       
    |   2    | User     |     0             |
      
    |   3    | Guest    |     125           |
    
    	
    """

    //Extend the existing User model by adding another model and linking it to the User model using //onetoone relation in models.py

    class userAggregate(models.Model):
       user = models.OneToOneField(User)
       AggregateControl = models.IntegerField(default=0)


    //countAccess in views.py

    import logging

    def countAccess(request, count):
        
        """
        Each time the user accesses the database we keep track of the number of times he
        connected. Whenever the user passes a reasonable number he should be rejected
        since he could be an attacker scraping your table contents and stealing company information
        You could a CRON job in your mysql system in order to clean the Aggregate column within certain timeframes
        """
        
        ip = get_client_ip(request)
        current_user = request.user
        log = logging.getLogger(__name__)

        //Add logging
        log.debug(''''User aggregate control updated: {user} via ip: {ip}''''.format(
            user=user,
            ip=ip
        ))

        registered_user = userAggregate.objects.get(pk=current_user.id)
        //We add the count to control variable for the update
        control = registered_user.AggregateControl + count
        //Check the aggregate
        if control > 5000:
            logger.warning(''''User aggregate control breach: {user} via ip: {ip}''''.format(
                user=user,
                ip=ip
            ))
                
            """
            Then we lock out the users account assuming it has been compromised by
            an attacker
            """
                
            access = 0
            current_user.is_active = access
            current_user.save()
            //we update the users table and count +1 tot the AggregateControl column
            registered_user.AggregateControl = control
            registered_user.save()  ','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (205,'Absolute timeout of a session',' Absolute time out of a session


 Example:


	"""
	Whenever a session is started, absolute time out (lifetime) of a session should be set in seconds
	
	For using sessions edit the middleware and make sure it contains ''''django.contrib.sessions.middleware.SessionMiddleware''''

    For adding HTTPONLY Cookies, we have to add the line in settings.py
    SESSION_COOKIE_HTTPONLY = True

    For adding Session Cookie age, we have to add the line in settings.py
    SESSION_COOKIE_AGE = 60000

    For setting session cookie domain, we have to add the line in settings.py
    SESSION_COOKIE_DOMAIN = ''''demo.yourdomain.com''''

	For setting session cookie name, we have to add the line in settings.py
	SESSION_COOKIE_NAME = ''''demo''''    
	
	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_PATH = ''''/''''

	For setting session cookie path, we have to add the line in settings.py
	SESSION_COOKIE_SECURE = True
	"""

	//For adding session cookie
	request.session[''''test''''] = ''''test''''','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (206,'Password storage(salting stretching hashing)',' Password storage(salting/stretching/hashing)


 Example:


    """
    Django provides a flexible password storage system and uses PBKDF2 by default.

    Password is of the format: 
    <algorithm>$<iterations>$<salt>$<hash>
	"""


	//For the encryption of passwords with salt
	from django.contrib.auth.hashers import make_password

	pwd = make_password(''''some_password'''')
	
	
	//Validate your password
	from django.contrib.auth.hashers import check_password

	check_password(password, pwd_hash)','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (207,'Sandboxing',' Sandboxing


 Example:


	<iframe sandbox="value">

		/*
		sandbox=""  Applies all restrictions
		allowforms  Reenables form submission
		allowpointerlock  Reenables APIs
		allowpopups  Reenables popups
		allowsameorigin  Allows the iframe content to be treated as being from the same origin
		allowscripts  Reenables scripts
		allowtopnavigation  Allows the iframe content to navigate its toplevel browsing context
		*/
	</iframe>
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (208,'Identifier based authorization',' Identifierbased authorization


 Example:

    """
    Define the whitelist pattern and validation type and input parameter like:
    identity("page1,page2", "alphanumeric", page)
    """

    def identity(request, whiteListPattern, validationType, inputParameter):

    	continue = True

    	"""
    	First, we want to filter the filenames for expected values. For this example we use only az/09
    	Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
    	for more information about validation see "input validations" in the code examples:
    	"""

    	if inputValidation(inputParameter, validationType, "Invalid userinput", "HIGH", countLevel) == False:
            continue = False

    	"""
    	Second, we want to whitelist the filenames for expected values, in this example they are,
    	page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
    	"""

    	if whitelisting(whiteListPattern, inputParameter) == False:
            continue = False

    	"""
    	Whenever you are checking whether a user is restricted to review certain data,
    	the access restrictions should be processed server side.
    	The userID could be stored inside a session variable on login, and should be used to
    	retrieve user data from the database:
    	"""
    	
        if continue == True : 

    		"""
    		We count the number of connections towards the database,
    		See "aggregate user controls" code example for more information:
    		"""

            countAccess(1)
            current_user = request.user
            data = Table.objects.filter(id=current_user.id, page=inputParameter).first()
            
            return data
        else:
            return False

','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (209,'Charsets',' Charsets


 Example:


    """
    In order to set the "Charsets" header you''''ll have to add the following code to the head of your application, the following code could be used in your controller: For Example, text/html
    """

    //You add directly into the HTML markup
    <meta httpequiv="ContentType" content="text/html; charset=utf8">

    """
    In order to set the "ContentType" header and charset you''''ll have to add the following code
    to the head of your application

    For adding ContentType in every page we have to add a middleware
    Make a middleware in yourapp/middleware.py
    """

    class MyMiddleware:

    	def __init__(self, get_response):
        	self.get_response = get_response

    	def __call__(self, request):
        	response = self.get_response(request)
        	
        	//For HTML, the content type is text/html
			response[''''ContentType''''] = ''''text/html; charset=UTF8''''

        	return response
   	
   	//For adding middleware in the project, add in yourproject/settings.py
   	MIDDLEWARE = [
    	...,
    	''''yourapp.middleware.MyMiddleware'''',
    	...,
	]	

	"""
	For adding in the individual response page using render_to_response
	"""

	response = render_to_response("template.html", {})
	//For HTML, the content type is text/html
	response[''''ContentType''''] = ''''text/html; charset=UTF8''''
	
	return response

	"""
	For adding in the individual response page using render
	"""

	response = render(request, "template.html", {})	
	//For HTML, the content type is text/html
	response[''''ContentType''''] = ''''text/html; charset=UTF8''''

	return response  ','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (210,'Content type headers',' Content type headers


 Example:


	"""
    In order to set the "ContentType" header you''''ll have to add the following code to the head of your application

    For adding ContentType in every page we have to add a middleware
    Make a middleware in yourapp/middleware.py
    """

    class MyMiddleware:

    	def __init__(self, get_response):
        	self.get_response = get_response

    	def __call__(self, request):
        	response = self.get_response(request)
        	
        	//For HTML, the content type is text/html
			response[''''ContentType''''] = ''''text/html; charset=UTF8''''
			
			//For Json, the content type is application/json
			response[''''ContentType''''] = ''''application/json''''
        	
        	return response
   	
   	//For adding middleware in the project, add in yourproject/settings.py
   	MIDDLEWARE = [
    	...,
    	''''yourapp.middleware.MyMiddleware'''',
    	...,
	]	

	"""
	For adding in the individual response page using render_to_response
	"""

	response = render_to_response("template.html", {})

	//For HTML, the content type is text/html
	response[''''ContentType''''] = ''''text/html; charset=UTF8''''
	//For Json, the content type is application/json
	response[''''ContentType''''] = ''''application/json''''
	
	return response

	"""
	For adding in the individual response page using render
	"""

	response = render(request, "template.html", {})
	
	//For HTML, the content type is text/html
	response[''''ContentType''''] = ''''text/html; charset=UTF8''''
	//For Json, the content type is application/json
	response[''''ContentType''''] = ''''application/json''''
	
	return response   ','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (211,'XML injection prevention',' XML injection prevention



 Example:


    """
	
	Whenever you are using XML parsers you must sanitize or encode al userinput before
	including this input into your XML file.

	Some methods like below, the Dom document already encodes the input before storing it
	into the XML. But beware, since this encoded input is still a threat whenever you are
	displaying the this data on screen as HTML output. This encoded data should be escaped
	at all times before displaying.

	Whenever your XML function does not encode your data on the fly, you may want to write
	your own function for achieving this. See the code examples and search for "Input encoding"
	for more detailed information.
	"""


	//Let us take an easy example where we store your favorite number name into a XML file.
	from lxml import etree

	//Create Root Element employees

	root = etree.Element("employees")
	
	//Create child Element for employees
	employee = etree.SubElement(root, "employee")
	name = etree.SubElement(employee, "name")
	
	//Insert the text in name tag
	name.text = request.form[''''name'''']

	//Save it in xml file
	with open("test.xml", "w") as f:
		f.write(etree.tostring(root, pretty_print=True))

	"""
	We will try to insert <script>alert(123);</script> into the XML file,
	Now after inserting the employee name into the XML file it will look like:


		<?xml version="1.0"?>
		<employees>
			<employee>
				<name>&lt;script&gt;alert(123);&lt;/script&gt;</name>
			</employee>
		</employees>

		As you can see de input has been encoded but still can trigger an XSS whenever we
		extract the data as shown in the example below:

	NOTE: if you ever want to include the xml files by means of userselected sources,
	be aware of the fact that an attacker could also include sources from external websites
	and even execute External entity injections on your applications. See the "XSLT injection prevention"
	code example for more detailed information on how to implement this type of functionality since
	the same principle''''s apply to both functions.
	"""
	
		//Read from a XML file
		x = etree.parse("test.xml")


		for element in x.iter("name"):
   	 		//This example is vulnerable to XSS
   	 		print element.text

   	 		//This example is escaped
   	 		print escape(element.text)

	"""
	We recommend to not rely solely on the encoding of the input by the Dom document.
	So before you insert userinput into the XML file you want to have it sanitized.
	See the "Encoding" and "input validation" code examples for more detailed information
	"""

 
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (212,'File upload',' File upload


 Example:

        
	"""
	In Django the file data is placed in request.FILES

	Forms should be always submitted using POST request

	It is mandatory for the HTML form to have enctype="multipart/formdata" otherwise the 
	request.FILES will be empty

	Django have proper models to handle the uploaded files : FileField and ImageField, they 
	have the reference the location where the file is  stored
	"""

	//set MEDIA_URL and MEDIA_ROOT in project''''s settings.py
	MEDIA_URL = ''''/media/''''
	MEDIA_ROOT = os.path.join(BASE_DIR, ''''media'''')

	//Add the urls.py file 
	from django.conf import settings
	from django.conf.urls.static import static

	urlpatterns = [
    	//Project url patterns...
	]

	//While development you may need to serve the user uploaded files
	if settings.DEBUG:
    	urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


    """
   	File Upload with model Forms

    In model form approach we can store the data about the reference of the file, details such 
    description when was it uploaded. It is more convenient to perform input validation, build
    absolute path and solve the issue of file name conflict.
    """

    //Create a Model Document to store the detail
    from django.db import models

    def user_directory_path(instance, filename):
    	//file will be uploaded to MEDIA_ROOT/user_<id>/<filename>
    	return ''''user_{0}/{1}''''.format(instance.user.id, filename)

	class Document(models.Model):
    	description = models.CharField(max_length=255, blank=True)
    	document = models.FileField(upload_to=user_directory_path, validators=[validate_file_extension])
    	uploaded_at = models.DateTimeField(auto_now_add=True)

    //Add validators.py for Input Validation
    import os
    from django.core.exceptions import ValidationError	

    def validate_file_extension(value):
        //[0] returns path+filename
    	ext = os.path.splitext(value.name)[1]  
    	
        //Adding valid extensions
        valid_extensions = [''''.jpg'''', ''''.png'''']
    	
        if not ext.lower() in valid_extensions:
            //Adding logging for extension error
            log.error(''''Wrong Extension Uploaded: {user} via ip: {ip}''''.format(
                user=user,
                ip=ip
            ))

        	raise ValidationError(u''''Unsupported file extension.'''')

    //Create a forms.py which will process the forms
    from django import forms
	from .models import Document

	class DocumentForm(forms.ModelForm):
    	class Meta:
        	model = Document
        	fields = (''''description'''', ''''document'''', ) 

    //Template for upload.html 
    {% block content %}
  	<form method="post" enctype="multipart/formdata">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Upload</button>
  	</form>

  	<p><a href="{% url ''''home'''' %}">Return to home</a></p>
	{% endblock %}


    //Create a view for upload functionality
    
    def model_form_upload(request):
    	if request.method == ''''POST'''':
        	form = DocumentForm(request.POST, request.FILES)
        	
            //Check whether the form is valid
            if form.is_valid():
                //Save the form data
            	form.save()

                //Upload Successful
                log.info(''''Uploaded Successful : {user} via ip: {ip}''''.format(
                    user=user,
                    ip=ip
                ))
                return redirect(''''home'''')
    	else:
        	form = DocumentForm()
    	return render(request, ''''app/upload.html'''', {
            ''''form'''': form
    	})','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (213,'Privilege based authentication',' Privilege based authentication


 Example:


    """
    For privilege based authentication we will use the table permissions.

    TABLE permissions
    
    |       *Name*      |       *Type*      |    *Extra*       |
    
    |         ID        |       Int(11)     |   AUTO_INCREMENT |
    
    |  content_type_id  |       Int(11)     |                  |
    
    |      codename     |    Varchar(255)   |                  |
    
    |        name       |    varchar(30)    |                  |
    

    Permissions are associated with models, and define the operations that can be performed on a model instance by a user who has the permission . Django automatically gives add, change, and delete permissions to all models by default.
    """

    //Adding certain privileges to user
    //Selecting particular User and adding permission
    user = User.objects.filter(username=''''user1'''').first()
    user.user_permissions = [Permission.objects.get(codename=''''change_choice'''')]

    """
    Permissions can be checked in both templates and views.
    In templates, Current user''''s permission are checked in template variable {{ perms }}
    In Views, Permissions can be tested in function view using the permission_required decorator or in class based view we can use PermissionRequiredMixin
    """
    
    //In templates
    {% if perms.polls.change_choice %}
      <! Add appropriate code. >
    {% endif %}

    //In Views 
    @permission_required(''''polls.change_choice'''')
    @permission_required(''''polls.can_edit'''')
    def my_view(request):
      ...

    //Permissionrequired for class based views
    from django.contrib.auth.mixins import PermissionRequiredMixin

    class MyView(PermissionRequiredMixin, View):
        permission_required = ''''catalog.can_mark_returned''''
        ...','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (214,'HTML output',' HTML output


 Example:


    """
    Whenever user input is displayed in the application, whether, as content or a parameter value
    submitted towards the url, all user input should be properly escaped to prevent XSS injections.
    
    Django has automatic HTML escaping, 5 characters are escaped : 
    < is converted to &lt;
    > is converted to &gt;
    '''' (single quote) is converted to &39;
    " (double quote) is converted to &quot;
    & is converted to &amp;
    """

    //If data = "<b>"
    //Template to show HTML escaping
    This will be escaped: {{ data }}
    This will not be escaped: {{ data|safe }}

    //Output for HTML escaping
    This will be escaped: &lt;b&gt;
    This will not be escaped: <b>

    //For removing dangerous characters : 
    wordDict = {''''&'''': ''''&amp;'''', ''''<'''' : ''''&lt;'''', ''''>'''' : ''''&gt;'''' , ''''"'''' : ''''&quot;'''', "''''" : ''''&x27;'''', ''''/'''' : &x2F;, ''''\'''' : ''''\\''''}

    for key in wordDict:
        input = input.replace(key, wordDict[key])

    //For UNTRUSTED DATA in <a href="/site/search?value=UNTRUSTED DATA">clickme</a>
    //URL Encoding for defense

    import urllib
    input = urllib.quote_plus(input) 

    """
    Security consists of different layers of protection, in order to guarantee the integrity
    of your application. This means that the value submitted from the user should
    already be sanitized before being submitted towards the database in order to prevent XSS.
    As an example, you are expecting only alphanumerical value here:
    """
    
    match = re.findall("^[azAZ09]+$", value)
    if match:
        return True
    else:
        raise Exception("User supplied value not in the range " + range)

    """
    This type of approach should be used whenever you are allowing userinput in
    your DOM like for example, let''''s say a user was allowed to upload an image and
    set an alt text. when you do not sanitize his input a possible attack string could be:
    """
    
    this is an image" onload="alert(''''XSS'''');"

    """
    whenever this string now is added to the users image this will be the outcome, leading
    to xss:
    """

    <img src="http://image.com/image.jpg" alt="this is an image" onload="alert(''''XSS'''')"" />

    """
    After this sanitation malicious code can no longer exist in the $_POST[''''value''''] variable.

    Another possibility for attackers to execute an XSS injection, is to pass malicious code directly
    into the URL by means of a "href", e.g.:
    javascript:alert(document.cookie);
    or
    data:text/html;base64,base64xssinjection

    In the following scenario escaping with htmlspecialchars() is not sufficient to block the injection.
    By checking the URL to see if it starts with either http:// or https:// whenever a link has
    been submitted to the web application by a user.

    def before_request(url):
        if url.startswith(''''http://'''') or url.startswith(''''https://''''):
            return True
        else:
            raise Exception("Not a valid URL : " + url)

    

    
','django-needs-reviewing',1);
INSERT INTO "code_items" VALUES (215,'X XSS Protection Header','XXSSProtection Header


 Example:

	const (
	  XSSProtectionHeader = "XXSSProtection"
	  XSSProtectionValue  = "1; mode=block"
	)

	func ExampleHandler(w http.ResponseWriter, r *http.Request) {
	  // Add XXSSProtection header
	  w.Header().Add(XSProtectionHeader, XSSProtectionValue)

	  // Respond with request
	  w.Write([]byte("Hello World."))
	}
','go-needs-reviewing',1);
INSERT INTO "code_items" VALUES (216,'X Content Type Options Header','XContentTypeOptions Header


 Example:

	const (
	  ContentTypeOptionsHeader = "XContentTypeOptions"
	  ContentTypeOptionsValue  = "nosniff"
	)

	func ExampleHandler(w http.ResponseWriter, r *http.Request) {
	  // Add XContentTypeOptions header
	  w.Header().Add(ContentTypeOptionsHeader, ContentTypeOptionsValue)

	  // Respond with request
	  w.Write([]byte("I have XContentTypeOptions header set to nosniff!"))
	}
','go-needs-reviewing',1);
INSERT INTO "code_items" VALUES (217,'Anti Caching Headers','Anticaching Headers


 Example:

	const (
	  CacheControlHeader = "CacheControl"
		CacheControlValue = "nocache, nostore, mustrevalidate"
		PragmaHeader = "Pragma"
		PragmaValue = "nocache"
		ExpiresHeader = "Expires"
		ExpiresValue = "0"
	)

	func ExampleHandler(w http.ResponseWriter, r *http.Request) {
	  // Add CacheControl header
		// HTTP 1.1
	  w.Header().Add(CacheControlHeader, CacheControlValue)

		// Add Pragma header
		// HTTP 1.0
		w.Header().Add(PragmaHeader, PragmaValue)

		// Add Expires header
		// Proxies
		w.Header().Add(ExpiresHeader, ExpiresValue)

	  // Respond with request
	  w.Write([]byte("I have anticaching headers!"))
	}
','go-needs-reviewing',1);
INSERT INTO "code_items" VALUES (218,'Anti Clickjacking Headers','Anti Clickjacking Headers


 Example:

The preferred method to prevent against clickjacking is to use "security headers".
There are three options for setting the "anticlickjacking" headers in your application:

	const (
		XFrameOptionsHeader = "XFrameOptions"
		XFrameOptionsDeny  = "DENY"
		XFrameOptionsSameOrigin = "SAMEORIGIN"
		XFrameOptionsFromUri = "FROMURI http://www.example.com"
	)

	func ExampleHandler(w http.ResponseWriter, r *http.Request) {

		// Prevent page from being displayed in an iframe
	  	w.Header().Add(XFrameOptionsHeader, XFrameOptionsDeny)

		// Prevent page from being displayed in an iframe on other sites
		// w.Header().Add(XFrameOptionsHeader, XFrameOptionsSameOrigin)

		// Allow page at specified URI to display page in an iframe
		// NOTE: Limited support in modern browsers
		// w.Header().Add(XFrameOptionsHeader, XFrameOptionsFromUri)

		// Respond with request
	  	w.Write([]byte("I have security headers!"))
	}
','go-needs-reviewing',1);
INSERT INTO "code_items" VALUES (219,'Content Type Headers','ContentType Headers


 Example:

	const (
	  ContentTypeHeader = "ContentType:text/html"
	  ContentTypeValue  = "charset=UTF8"
	)

	func ExampleHandler(w http.ResponseWriter, r *http.Request) {
	  // Add ContentType header
	  w.Header().Add(ContentTypeHeader, ContentTypeValue)

	  // Respond with request
	  w.Write([]byte("I have a ContentType of text/html in UTF8!"))
	}
','go-needs-reviewing',1);
INSERT INTO "code_items" VALUES (220,'X XSS Protection header',' XXSSProtection header


 Example:


    // Ruby on Rails sets XXSSProtection header with "1; mode=block" option by default.
    // If in your case it doesn''''t, you can add the header manually.

    // Add the following code to APP_DIR/config/environments/production.rb

    config.action_dispatch.default_headers = {
      ''''XXSSProtection'''' => ''''1; mode=block''''
    }
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (221,'Enforce secure passwords',' Enforce secure passwords


 Example:


    // It is highly recommended to use Devise gem that handles authentication on your RoR app.
    // more info: https://github.com/plataformatec/devise
    // Then install Devise Security Extension gem (https://github.com/phatworx/devise_security_extension)
    // Follow the installing instructions mentioned on Github

    // Now it''''s time to configure the gem in APP_DIR/config/initializers/devise.rb
    // Uncomment and customize following lines of code

    // Configuration of the gem core
    config.password_length = 10..128

    // Configuration of the gem extenstion
    config.password_regex = /(?=.*\d)(?=.*[az])(?=.*[AZ])/ // at least one number, big letter and small letter
    config.password_archiving_count = 5
    config.deny_old_passwords = true

    // Now update your model
    // For example:
    class User < ApplicationRecord
      has_many :posts

      // add :secure_validatable. Remember not to use :secure_validatable with :validatable
      devise :database_authenticatable, :registerable,
            :recoverable, :rememberable, :trackable, :secure_validatable
    end

','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (222,'Re authentication',' Re authentication


 Example:


	// Whenever a user wants to change his credentials or do other important data exchanges such as
	// transferring money he should always be challenged to reauthenticate himself before
	// allowing them to perform these actions.

	// Enforcing reauthentication before changing the password is provided by default in Devise gem. All you have
	// To do is add such link in your view
	<%= link_to "Change your password", edit_user_registration_path %


	// Other action may require adding your before_action method in specific controller
	class SpecificController < ApplicationController
		before_action :re_entered_password?, only: [:edit] 

		private
		def re_entered_password? 
			if session[:reauthenticated_at] == nil or session[:reauthenticated_at] > 2.minute
				// Redirect to view that requires entering your password
				redirect_to action: => "re_authenticate" 
			end
		end
	end

	// After successful authentication set 
	session[:reauthenticated_at] = Time.now
    ','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (223,'XSL injection prevention',' XSL Injection prevention


 Example:


    // In order to prevent XSL injections you must enforce strict policy''''s whenever the
    // files are loaded from a source controlled by an possible attacker.

    // Let''''s say for example that the user can choose from several XSL files on your application.

    // ABC.xsl arranges your employee names on alphabetical order
    // CBA.xsl does not care and just shows the input by order of your XML file.

    // Before we want to attach the XSL files to the style sheet we first want to
    // do validation on the request to make sure the included file was one of our own pre
    // defined files, example:
    // check_pattern(params[:xslfile], "file1.xsl,file2.xsl,etc")

    require ''''nokogiri''''

    // Include the classes of which you want to use objects from
    require_relative ''''classes''''

    class IncludeXSL
      def including(param, white_list)
        // check "Whitelisting" for method declaration
        if check_pattern(param, white_list)
          document = Nokogiri::XML(File.read(''''input.xml''''))
          template = Nokogiri::XSLT(File.read(''''template.xslt''''))

          transformed_document = template.transform(document)
        end
      end
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (224,'Session cookies (domain)',' Session cookies (domain)


 Example:


    // Whenever a session is started, and you want to share it over different domains,
    // the domain value should be set to the specific domain:

    // Add "domain: DOMAIN_NAME" option to APP_DIR/config/initializers/session_store.rb
    Rails.application.config.session_store :cookie_store, key: ''''SESSIONID'''', domain: "DOMAIN_NAME"','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (225,'Directory listing',' Directory Listing


 Example:


    // Directory Listing is a server based feature not Ruby''''s based. If you are using
    // Apache and other Web Application Server (like popular Passenger), follow
    // this tutorial

    // To disable or prevent directory access, add following line in your .htaccess file. If
    // user points the browsers to a directory that does not have an index file, then a
    // "403 Forbidden" error will be displayed:

    // Add this line of code to your .htaccess file:
    Options Indexes','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (226,'RFD and file download injection prevention',' RFD and file download injection prevention


 Example:


    def get_files(input_parameter, pattern)
      validator = Validation.new

      // First, we want to filter the filenames for expected values. For this example we use only az/09
      // Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
      // for more information about validation see "input validations" in the code examples:
      return false unless validator.alphanumeric?(input_parameter)

      // Second, we want to whitelist the filenames for expected values, in this example they are,
      // file1,file2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
      // pass the pattern to the check pattern, for instance pattern = %w[file1 file2]
      return false unless check_pattern(input_parameter, pattern)

      // Set proper headers
      response.headers[''''CacheControl''''] = ''''nostore, nocache, mustrevalidate, maxage=0''''
      response.headers[''''XContentTypeOptions''''] = ''''nosniff''''
      response.headers[''''Pragma''''] = ''''nocache''''

      // If all went good we can send file based on user''''s given name
      send_file input_parameter
      true
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (227,'X Content Type Options header',' XContentTypeOptions header


 Example:


    // Ruby on Rails sets XContentTypeOptions header with "nosniff" option by default.
    // If in your case it doesn''''t, you can add the header manually.

    // Add the following code to APP_DIR/config/environments/production.rb

    config.action_dispatch.default_headers = {
      ''''XContentTypeOptions'''' => ''''nosniff''''
    }
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (228,'Audit logs',' Audit Logs


 Example:


    // Logging is turned on in Ruby on Rails by default. Every request is logged that is nice but it may 
    // cause security issues like information disclosure. If attacker gets access to web server, it''''s possible
    // to read all requests containing confidential data like logins, passwords, card numbers etc. That''''s why it
    // is recommended to define which values shouldn''''t be stored in logs.

    // Add following line of code to APP_DIR/config/initializers/filter_parameter_logging.rb in order to filter
    // confidential data being saved in logs.

    Rails.application.config.filter_parameters += [:confidential_parameter]','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (229,'CSRF tokens',' CSRF Tokens


 Example:

          
    // Handling CrossSite Request Forgery is as simple as adding following line of code into 
    // your APP_DIR/controllers/application_controller.rb

    class ApplicationController < ActionController::Base
      protect_from_forgery with: :exception
    end

    // It''''s important to know that RoR is REST based framework and CSRF protection does not work on HTTP GET requests.','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (230,'Logout function',' Logout function


 Example:


    // It is highly recommended to use Devise gem that handles authentication on your RoR app.
    // more info: https://github.com/plataformatec/devise

    // When all authentication is done by Devise gem the implement logout function is as simple as
    // adding the link into your base template. For my application this is 
    // APP_DIR/views/layouts/application.html.haml

    %ul.nav.navbarnav.navbarright
     if user_signed_in?
      %li= link_to "New Post", new_post_path
      %li= link_to "Sign out", destroy_user_session_path, method: :delete // Logout function
     else
      %li= link_to "Sign in", new_user_session_path
      %li= link_to "Sign up", new_user_registration_path

    // Also, remember about authenticate in controllers before performing any action in specific controllers
    before_action :authenticate_user!, only: [Methods_here] ','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (231,'Timeout a session',' Timeout a session


 Example:


    // Add "expire_after: 1.hour option to APP_DIR/config/initializers/session_store.rb
    Rails.application.config.session_store :cookie_store, key: ''''SESSIONID'''', secure: true, expire_after: 1.hour','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (232,'White listing',' White listing


 Example:

    
    def check_pattern(param, list = [])
      // List should be an array of allowed patterns
      // list = ["value1", "value2"]
      if list.include? param
        Rails.logger.info "//{session.id} > Good whitelist validation"
        true
      else
        Rails.logger.warn "//{session.id} > Bad whitelist validation"
        false
      end
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (233,'Session hijacking and fixation',' Session hijacking and fixation


 Example:


    // In order to secure your session, you have to turn on SECURE and HTTPONLY cookies'''' flags
    // More info in: "Session cookies HTTPOnly" and "Secure session cookies"

    // Turn on `force_ssl` in config/environments/production.rb
    Rails.application.configure do
      // redirects all HTTP to HTTPS and also adds secure flag to your cookies
      config.force_ssl = true

      config.ssl_options = {
        // HTTP Strict Transport Security configuration
        hsts: {
          // default
          expires: 180.days,

          // default  if all present and future subdomains will be HTTPS
          subdomains: true,

          // Recommended: If the site owner would like their domain to be included in the HSTS preload list
          // defaults to false
          preload: true
        }
      }

      // more information can be found here: http://api.rubyonrails.org/classes/ActionDispatch/SSL.html
    end

    // After that add :trackable symbol to the devise configuration in users'''' model

    // For example:
    class User < ApplicationRecord
      has_many :posts

      // Be sure that :trackable is added
      devise :database_authenticatable, :registerable,
            :recoverable, :rememberable, :trackable, :secure_validatable
    end

    // Now update controllers that need authenticated users to perform actions.
    class ContollerWithAuthenticatedUsers < ApplicationController
      before_action :authenticate_user!
      before_action :check_ip

      private
      // After this modification current users'''' IP address will be compared to
      // the last IP that was used to log in on the account. If they dont match  
      // user will be warned. This check will be performed every single user action.
      def check_ip
        if current_user.last_sign_in_ip != request.remote_ip
          flash[:warning] = "There are other active sessions on other IP addresses. " +
          "Your session could be hijacked. Press logout in order to authenticate again " +
          "for security reasons!"
        end
      end  
    end

','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (234,'Random password token generation',' Random password token generation


 Example:


    // A good random password would be:
    password = SecureRandom.hex(32)

    // A good random number would be:
    number = SecureRandom.random_number

    //A good random bytes would be:
    bytes = SecureRandom.random_bytes(32)','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (235,'Directory path traversal',' Directory/path traversal


 Example:

      
    def get_files(input_parameter, pattern)
      validator = Validation.new

      // First, we want to filter the filenames for expected values. For this example we use only az/09
      // Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
      // for more information about validation see "input validations" in the code examples:
      return false unless validator.alphanumeric?(input_parameter)

      // Second, we want to whitelist the filenames for expected values, in this example they are,
      // page1,page2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
      // pass the pattern to the check pattern, for instance  pattern = %w[page1 page2]
      return false unless check_pattern(input_parameter, pattern)

      //If all went good we can send file based on user''''s given name
      send_file input_parameter
      true
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (236,'Input validation',' Input validation


 Example:

    
	// This class is where you store all your input validation controls.
	// It makes it easy to maintain whenever you want to apply changes for
	// certain input validation roles and reduces the chance of mistakes in your regexes.

	class Validation

		// Application has to protect itself. Every bad input the counter will increment. If the counter
		// hits 3 user''''s session must be terminated. 
		attr_reader :counter

		def initialize
			@counter = 0
		end

		def validation_failed
				@counter += 1

				// Every bad input validation has to be logged.
				Rails.logger.warn "//{session.id} > Bad user input"

				if @counter >= 3
					// DO LOGOUT HERE
				end
		end

		def numeric?(input)
			unless input =~ /^[09]+$/
				self.validation_failed
				return false
			end

			return true 
		end

		def alphanumeric?(input)
			unless input =~ /^[azAZ]+$/
				self.validation_failed
				return false
			end

			return true 
		end
	end','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (237,'Enforce sequential step order shopping',' Enforce sequential step order 


 Example:


	// Whenever an functionality consists out of following several steps to achieve some goal i.e,
	// "User adds items to chart", "User enters shipping information", "User pays for goods",
	// "Items will be shipped." You want to make sure the user can not skip the payment step in
	// order to receive his goods.

	class Product < ApplicationRecord
	end

	class Order < ApplicationRecord
		has_many :products, through: :products_orders

		belongs_to :customer
		belongs_to :payment
	end

	// As you can see above we have a very simplified database structure for your average
	// web shop. now we can walk through the different steps needed to enforce the user to take
	// all steps before payment.
	//
	// We wont cover the entire shopping cart functions since that would become a rather big
	// example so let''''s cover the basics of enforcing the sequential steps.
	//
	// Step1: would be, the user adding items to his cart.
	//
	// Step2: would be, the user adding products to checkout. Whenever he is done shopping
	// we''''ll change the state of the Order
	//
	// For managing the state we could use a Ruby gem that implements an interface
	// for a state machine, like Statesman (https://github.com/gocardless/statesman)
	// It even provides adapters for ActiveRecord models and can save the entire
	// state transition history for later audit.

	// First, we should create a state machine:
	class OrderStateMachine
		include Statesman::Machine

		state :pending, initial: true
		state :checking_out
		state :purchased
		state :cancelled

		transition from: :pending,      to: [:checking_out, :cancelled]
	transition from: :checking_out, to: [:purchased, :cancelled]
	end

	// Then, we can link it to our ActiveRecord model:
	class Order < ApplicationRecord
		include Statesman::Adapters::ActiveRecordQueries

		has_many :order_transitions, autosave: false
		has_many :products, through: :products_orders

		belongs_to :customer
		belongs_to :payment

		// Optionally delegate some methods
		delegate :can_transition_to?, :transition_to!, :transition_to, :current_state,
			to: :state_machine

		def state_machine
			@state_machine ||= OrderStateMachine.new(self, transition_class: OrderTransition)
		end

		def self.transition_class
			OrderTransition
		end

		def self.initial_state
			:pending
		end
		private_class_method :initial_state
	end

	// Next, lets create an AR model to represent state transitions:
	class OrderTransition < ActiveRecord::Base
	include Statesman::Adapters::ActiveRecordTransition

	belongs_to :order, inverse_of: :order_transitions
	end

	// And lets put the following code into confing/initializers/statesman.rb
	// So that Statesman knows it should persist the state to DB
	Statesman.configure do
	storage_adapter(Statesman::Adapters::ActiveRecord)
	end

	// Now in your controllers you can use the following methods:
	//  Machine//can_transition_to?(state): true|false
	//  Machine//transition_to(state): true|false
	//  Machine//transition_to!(state): true|Statesman::TransitionFailedError|Statesman::GuardFailedError
	order = Order.create!

	order.current_state
	// => pending

	order.can_transition_to?(:purchased)
	// => false

	order.transition_to(:purchased)
	// => false

	// order still in the pending state:
	order.current_state
	// => pending

	// You definitely should check out the gem''''s Github page (https://github.com/gocardless/statesman)
	// as it has a great README with a more broad example
    ','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (238,'System commands',' System commands


 Example:


    // Define the whitelist pattern and validation type andz input parameter like:
    // get_files("value1,value2,etc", "alphanumeric", params[''''filename''''], "3")
    class SystemCommands
      // Ruby implementation of PHP escapeshellcmd written by Prof. Edgar Gonzalez
      def escape_shell_command(cmd)
        cmd.gsub(/(["''''//&;`|*?~<>^()\[\]{}$\\\x0A\xFF])/) { '''''''' }
      end

      // Whenever a system command is finished, you should properly sanitize and escape this user input.
      // System command methods examples are: %x{command}, `command`, system("command")

      // First, we want to filter the filenames for expected values. For this example we use only az/09
      // Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
      // for more information about validation see "input validations" in the code examples:
      def exec(param, validation_type, pattern)
        validator = Validation.new

        case validation_type
        when numeric
          return false unless validator.numeric?(command)
        when alphanumeric
          return false unless validator.alphanumeric?(command)
        else
          return false
        end

        return false unless check_pattern(param, pattern)

        // If all went good we include the filename
        // Even though there is a match we still escape the shellcommand:
        command = ''''./configure '''' + param
        escaped_command = self.escape_shell_command(command)

        // Only after validation do we put the shell command into the system() method:
        system(escaped_command)
      end
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (239,'Session cookies HttpOnly',' Session cookies HTTPOnly


 Example:


    // Add "httponly: true" option to APP_DIR/config/initializers/session_store.rb
    Rails.application.config.session_store :cookie_store, key: ''''SESSIONID'''', httponly: true','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (240,'SQL query',' SQL Query


 Example:

    
    // You should try to use Active Record''''s prepared methods to handle SQL Queries.
    // Example 1: Take client with id = 40 from the database
    client = Client.find(40)

    // Example 2: Take last 5 clients
    client = Client.last(5)

    // Example 3: Find client by first name
    client = Client.find_by first_name: "Wojciech"

    // Example 4: Where conditions
    // With 1 parameter
    Client.where("parameter = ?", params[:parameter]) 
    Client.where("parameter1 = ? AND parameter2 = ?", params[:parameter1], params[:parameter2])

    // !!!!!
    // Using SQL Queries like this Client.where("param1 LIKE ''''%//{params[:param1]}%''''")
    // leads to SQL Injection attack. Never do that!
    // !!!!!


    // Example 5: Range conditions
    Client.where(created_at: (Time.now.midnight  1.day)..Time.now.midnight)

    // For more methods and examples check http://guides.rubyonrails.org/active_record_querying.html

','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (241,'Open forwards & redirects',' Open forwards & redirects


 Example:


	// When using forwards & redirects you should make sure the URL is being explicitly
	// declared in the code and cannot be manipulated by an attacker like:

	redirect_to params[:redirect]

	// Generally you should avoid getting input into the redirect which could contain
	// userinput by any means. if for any reason this may not be feasible than you
	// should make a whitelist input validation for the redirect

	def redirecting
		if params[:redirect] =~ %r{^https\:\/\/trustedsite.com\/.+$}
			redirect_to params[:redirect]
		end
	end','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (242,'X path query',' X Path query


 Example:


    require ''''nokogiri''''

    class XPathControl
      // Define the allowed characters and input parameter and count level for the
      // user lockout like:
      // call(params[:filename], "<''''>&")

      def call(user, input_param, allowed_characters)
        encoder = Encoder.new
        encoded = encoder.encode(user, input_param, allowed_characters)

        if encoded
          doc = Nokogiri::XML(File.read(''''file.xml''''))

          // Assuming that you used the encoder function also for adding users, it will now retrieve the
          // user O''''reily from the query
          query_result = doc.xpath("//lemonade[@supplier=\"//{doc}\"]/price")
        end
      end
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (243,'Anti caching headers',' Anti caching headers


 Example:

    
    // Add the following code to APP_DIR/config/environments/production.rb in order to prevent the browser from caching
    config.action_controller.perform_caching = false
    config.public_file_server.headers = {
      ''''CacheControl'''' => ''''nocache, nostore''''
    }
    // Add the pragma header also for enforcing older browsers
    config.action_dispatch.default_headers = {  
      ''''Pragma'''' => ''''nocache'''' 
    } 
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (244,'Secure session cookies',' Secure session cookies


 Example:

    
    // Add "secure: true" option to APP_DIR/config/initializers/session_store.rb
    Rails.application.config.session_store :cookie_store, key: ''''SESSIONID'''', expire_after: 1.hour, secure: true','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (245,'Password forget and disallow old passwords',' Enforce secure passwords


 Example:


    // It is highly recommended to use Devise gem that handles authentication on your RoR app.
    // more info: https://github.com/plataformatec/devise
    // Then install Devise Security Extension gem (https://github.com/phatworx/devise_security_extension)
    // Follow the installing instructions mentioned on Github

    // After successful installation you should have created user''''s views and controllers

    // Firstly, configure the mail settings

    // APP_DIR/config/environments/production.rb
    config.action_mailer.delivery_method = :smtp
    config.action_mailer.smtp_settings = {
    :address              => "smtp.yoursite.com",
    :port                 => 587,
    :user_name            => ENV[''''email_username''''], // it is not recommended to hardcode sensitive data
    :password             => ENV[''''email_password''''],
    :ssl                  => true,
    :enable_starttls_auto => true
    }

    // Now it''''s time to configure the gem in APP_DIR/config/initializers/devise.rb
    // Uncomment and customize following lines of code
    config.password_archiving_count = 5
    config.deny_old_passwords = true


    // Now update your model
    // For example:
    class User < ApplicationRecord
      has_many :posts

      // add :recoverable that allows user reset the password
      devise :database_authenticatable, :registerable,
            :recoverable, :rememberable, :trackable, :secure_validatable
    end

','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (246,'XML External entities',' XML External entities


 Example:

    
    // Typically parsing XML files is done by using external gems like Nokogiri. In Nokogiri using external entities
    // is turned off by default. Always check it in the documentation. If you want to be sure  turn off parsing external
    // entities explicitly.

    // Example of turning off parsing external entities in Nokogiri gem
    require ''''nokogiri''''
    xml = ''''<!DOCTYPE root [ <!ENTITY ent SYSTEM \"file:///etc/passwd\"> ]>\n<root><e>&ent;</e></root>''''
    // "nonet" stands for No External Entities
    parsed_xml = Nokogiri::XML.parse(xml) { |config| config.nonet } 
    
    // parsed_xml.children.children.children.text should return now empty string
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (247,'Anti clickjacking headers',' Anti clickjacking headers


 Example:


    // Ruby on Rails sets XFrameOptions header with "SAMEORIGIN" option by default.
    // If in your case it doesn''''t or you want to enforce "DENY" options, you can add that headers manually.

    // Add the following code to APP_DIR/config/environments/production.rb

    config.action_dispatch.default_headers = {
      ''''XFrameOptions'''' => ''''DENY'''' // this will completely prevent your page from being displayed in an iframe.
    }

    // OR

    config.action_dispatch.default_headers = {
      ''''XFrameOptions'''' => ''''SAMEORIGIN'''' // this will completely prevent your page from being displayed in an iframe on other sites.
    }
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (248,'Debug enabling',' Debug enabling


 Example:

    
    //By default debugging is disabled if the environment is set to "production".
    //If you want to make sure  check APP_DIR/config/environments/production.rb for:
    config.consider_all_requests_local = false // "true" enables debugging','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (249,'Login functionality',' Login functionality


 Example:


    // Like in other authenthication cases  Ruby on Rails use a gem called "Devise" to handle login functionality. 
    // Use generators below to create required staff
    $> rails generate devise:install
    $> rails g devise:views
    $> rails generate devise User
    $> rake db:migrate

    // Update your User model in APP_DIR/app/models/user.rb
    devise :database_authenticatable, :registerable,
        :recoverable, :rememberable, :trackable, :validatable

    // Set routes in APP_DIR/config/routes.rb
    devise_for :users

    // And finally create login view
    <h2>Log in</h2>

    <%= simple_form_for(resource, as: resource_name, url: session_path(resource_name)) do |f| %>
      <div class="forminputs">
        <%= f.input :email, required: false, autofocus: true %>
        // Remember turning off autocomplete on password field
        <%= f.input :password, required: false, autocomplete: off %> 
        <%= f.input :remember_me, as: :boolean if devise_mapping.rememberable? %>
      </div>

      <div class="formactions">
        <%= f.button :submit, "Log in" %>
      </div>
    <% end %>

    <%= render "devise/shared/links" %>

    // Also, remember turning on HTTPS on login site and setting cookies properly. More info: Secure session cookies.','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (250,'User registration SQL truncation',' User registration SQL truncation


 Example:


    // Ruby on Rails uses special gem called Devise to handle whole registration (and authentication). This gem makes you invulnerable to SQL truncation.
    // Always remember to enforce better security in the User model (more info: "Password storage"). It is highly recommended to enforce
    // SSL connection during user''''s signing up and signing in (more info: "Secure session cookies").

    // Examples of models, views and controllers containing registration

    // User model
    class User < ApplicationRecord
      has_many :posts
      // Include default devise modules. Others available are:
      // :confirmable, :lockable, :timeoutable and :omniauthable
      devise :database_authenticatable, :registerable,
            :recoverable, :rememberable, :trackable
    end


    // Registration//new view
    <h2>Sign up</h2>

    <%= simple_form_for(resource, as: resource_name, url: registration_path(resource_name)) do |f| %>
      <%= f.error_notification %>

      <div class="forminputs">
        <%= f.input :email, required: true, autofocus: true %>
        <%= f.input :password, required: true, hint: ("//{@minimum_password_length} characters minimum" if @minimum_password_length) %>
        <%= f.input :password_confirmation, required: true %>
      </div>

      <div class="formactions">
        <%= f.button :submit, "Sign up" %>
      </div>
    <% end %>

    <%= render "devise/shared/links" %>

    // Devise has it own registration controller that can be seen here: https://github.com/plataformatec/devise/blob/master/app/controllers/devise/registrations_controller.rb','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (251,'Encoder',' Encoder


 Example:


    // This is the encoder method for whenever you have to allow certain
    // possibly dangerous characters into your code for i.e names such as O''''reily

    class Encoder
      // include SanitizeHelper for the implementation of sanitize method
      include ActionView::Helpers::SanitizeHelper
      // and this one to provide sign_out
      include Devise::Controllers::SignInOut

      PATTERN = ''''^[azAZ09%s]+$''''.freeze

      attr_reader :store

      // If your application is running on multiple processes or machines make sure you use a keyvalue backend for Rails cache
      // like Redis or Memcached. If you''''re using Unicorn/Passenger/Puma in clustered mode you''''re already running multiple processes!
      // Alternatively you can provide your own implementation backed by either a keyvalue store or just your database.
      def initialize(store = Rails.cache)
        @store = store
      end

      def encode(user, input, allowed_characters)
        pattern = PATTERN % allowed_characters

        regex = Regexp.compile(pattern)

        unless input =~ regex
          cache_key = cache_key(user)
          store.increment(cache_key)

          // Every bad input validation has to be logged.
          Rails.logger.warn "//{user.id} > Bad user input"

          if store.fetch(cache_key) >= 3
            sign_out(user)
            store.delete(cache_key)
          end

          return false
        end

        sanitize(input)
      end

      private

      def cache_key(user)
        "//{user.cache_key}/input_counter"
      end
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (252,'Aggregate user controls',' Aggregate user controls


 Example:


		// First of all, you have to know that Devise gem is AUTHENTICATION gem, not AUTHORIZATION.
		// Using "before_action" in specific controllers will provide only authentication.

		// It is recommended to use authorization gem like Pundit over creating your own code
		// more info: https://github.com/elabs/pundit

		// Quick introduction:

		// 1. Install gem and run generator  `rails g pundit:install`
		// 2. Create policies and update controllers
		// Policy example
			class PostPolicy
				attr_reader :user, :post

				def initialize(user, post)
					@user = user
					@post = post
				end

				def update?
					user.admin? || !post.published?
				end
			end

			// Controller authorization example
			def admin_list
				authorize Post // we don''''t have a particular post to authorize
				// Rest of controller action
			end

		// 3. Make scopes for policies
		// 4. Ensure if policies and scopes are used
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (253,'Password storage(salting stretching hashing)',' Password storage (salting sretching hashing)


 Example:

    
    // It is highly recommended to use Devise gem that handles authentication on your RoR app.
    // more info: https://github.com/plataformatec/devise

    // Configure the gem in APP_DIR/config/initializers/devise.rb
    config.stretches = Rails.env.test? ? 3 : 11

    // By default password hashing algorithm is set to BCRYPT which is good  it means that u can
    // leave it with default settings

    // Now update your model
    // For example:
    class User < ApplicationRecord
      has_many :posts

      // add :database_authenticatable to turn on password safe storing
      devise :database_authenticatable, :registerable,
            :recoverable, :rememberable, :trackable, :secure_validatable
    end

','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (254,'Sandboxing',' Sandboxing


 Example:


<iframe sandbox="value">

		// sandbox=""  Applies all restrictions
		// allowforms  Reenables form submission
		// allowpointerlock  Reenables APIs
		// allowpopups  Reenables popups
		// allowsameorigin  Allows the iframe content to be treated as being from the same origin
		// allowscripts  Reenables scripts
		// allowtopnavigation  Allows the iframe content to navigate its toplevel browsing context','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (255,'Identifier based authorization',' Identifier based authorization


 Example:


    def identifier_based_authorization(input_parameter, pattern, id_to_auth)
      validator = Validation.new

      // First, we want to filter the filenames for expected values. For this example we use only numeric
      // Whenever the values are tampered with, we can assume an attacker is trying to inject malicious input.
      // for more information about validation see "input validations" in the code examples:
      return false unless validator.numeric?(input_parameter)

      // Second, we want to whitelist the filenames for expected values, in this example they are,
      // file1,file2 etc.. for more information about whitelisting see "whitelisting" in the code examples:
      // pass the pattern to the check pattern, for instance  pattern = %w[file1 file2]
      return false unless check_pattern(input_parameter, pattern)

      // Whenever you are checking whether a user is restricted to review certain data,
      // the access restrictions should be processed serverside.
      user = User.find_by(auth_id: input_parameter)

      return true if id_to_auth == user.auth_id

      false
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (256,'Charsets',' XXSSProtection header


 Example:


    // Ruby on Rails sets encoding header with "utf8" option by default.
    // If in your case it doesn''''t or you want to set different encoding, you can do it manually.

    // Add the following code to APP_DIR/config/environments/production.rb
    config.encoding = ''''utf8''''
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (257,'Content Type Headers',' XContentType header


 Example:


    // Ruby on Rails sets XContentTypeOptions header with "nosniff" option by default.
    // If in your case it doesn''''t, you can add the header manually.

    // Add the following code to APP_DIR/app/controllers/YOUR_CONTROLLER.rb

    class YourController < ApplicationController
      def rendering_inline
        render inline: ''''Content of the file'''', content_type: ''''application/foo''''
      end

      def rendering_from_file
        render file: filename, content_type: ''''application/foo''''
      end
    end

','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (258,'XML injection prevention',' XML Injection Prevention


 Example:


    // Whenever you are using XML parsers you must sanitize or encode all userinput before
    // including this input into your XML file.

    // Some methods like below, the Dom document already encodes the input before storing it
    // into the XML. But beware, since this encoded input is still a threat whenever you are
    // displaying the this data on screen as HTML output. This encoded data should be escaped
    // at all times before displaying.

    // Whenever your XML function does not encode your data on the fly, you may want to write
    // your own function for achieving this. See the code examples and search for "Input encoding"
    // for more detailed information.

    require ''''nokogiri''''

    xml_doc = Nokogiri::XML(''''<employees><employee><name></name></employee></employees>'''')

    xml_doc.css(''''employees employee name'''').first.content = params[:name]

    // In Nokogiri gem HTML Encoding is done by default. Printing xml_doc.to_xml should return
    // => "<?xml version=\"1.0\"?>\n<employees>\n  <employee>\n    <name>&lt;script&gt;alert(\"1\")&lt;/script&gt;</name>\n  </employee>\n</employees>\n"

    // Always check if user input is properly encoded, because displaying XML may lead to multiple vulnerabilities, for instance  XSS.
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (259,'Crossdomain.xml',' Crossdomain.xml


 Example:


		// A bad example of a crossdomain.xml would be:

			<?xml version="1.0" ?>
			<crossdomainpolicy>
				<sitecontrol permittedcrossdomainpolicies="masteronly"/>
				<allowaccessfrom domain="*"/>
				<allowhttprequestheadersfrom domain="*" headers="*"/>
			</crossdomainpolicy>

		//	Because it allows acces from all other domains.

		//	Instead of this approach you might want to use the following restrictions. 
		//	Example by twitter''''s crossdomain.xml:

			<?xml version="1.0" encoding="UTF8"?>
			<crossdomainpolicy xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance" 
			xsi:noNamespaceSchemaLocation="http://www.adobe.com/xml/schemas/PolicyFile.xsd">
				<allowaccessfrom domain="twitter.com" />
				<allowaccessfrom domain="api.twitter.com" />
				<allowaccessfrom domain="search.twitter.com" />
				<allowaccessfrom domain="static.twitter.com" />
				<sitecontrol permittedcrossdomainpolicies="masteronly"/>
				<allowhttprequestheadersfrom domain="*.twitter.com" headers="*" secure="true"/>
			</crossdomainpolicy>','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (260,'File upload',' File upload


 Example:


    // Most of Ruby on Rails developers use specific gem to handle file upload. The most popular gem is to do this is Paperclip.

    // To install Paperclip follow instructions at https://github.com/thoughtbot/paperclip
    // Configuring gem is typical  creating proper model, views and controller.

    // Now something about security  create strong validation rules in model. For example:

    // File: APP_DIR/app/models/photo.rb
    validates_attachment :image,
                        presence: true,  validates if file is proper image
                        content_type: {content_type: %w(image/jpeg image/gif image/png)},  whitelist content type
                        size: {in: 0..10.kilobytes}  set maximum size of uploading
    validates_attachment_file_name :image, matches: [/^[azAZ09]$/]  allow only alphanumerical file names
    // Always upload files outside the website root directory 

    // Paperclip logs every upload action by default. If you want to turn logging on explicite add following line of code
    // to your APP_DIR/config/environments/production.rb
    Paperclip.options[:log] = true
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (261,'Privilege based authentication',' Aggregate user controls


 Example:


    // First of all, you have to know that Devise gem is AUTHENTICATION gem, not AUTHORIZATION.
    // Using "before_action" in specific controllers will provide only authentication.

    // It is recommended to use authorization gem like Pundit over creating your own code
    // more info: https://github.com/elabs/pundit

    // However, for simple privilege based authentication we can use simpler gem like Petergate
    // more info: https://github.com/elorest/petergate

    // Quick introduction to Petergate gem:
    // 1. Use this generators
    $> rails g petergate:install
    $> rake db:migrate
    // 2. Configure roles in user.rb
    petergate(roles: [:admin, :editor], multiple: false)
    // 3. Setup permissions in the specific controller
    def YourController < ApplicationController
      access all: [:show, :index], user: {except: [:destroy]}, company_admin: :all
    end
','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (262,'HTML output',' HTML output


 Example:


	// Whenever user input is displayed in the application, whether, as content or a parameter value
	// submitted towards the url, all user input should be properly escaped to prevent XSS injections.

	// For normal output it is recommended use sanitize with the most restrict options
	<%= sanitize(test, tags: [], attributes: []) %>

	// Security consists of different layers of protection, in order to guarantee the integrity
	// of your application. This means that the value submitted from the user should
	// already be sanitized before being submitted towards the database in order to prevent XSS.
	// As an example, you are expecting only alphanumerical value here:

	unless /^[azAZ09]+$/ =~ sanitize(input, tags: [], attributes: [])
		//do logout here
	end

	// This type of approach should be used whenever you are allowing userinput in
	// your DOM like for example, let''''s say a user was allowed to upload an image and
	// set an alt text. when you do not sanitize his input a possible attack string could be:

	this is an image" onload="alert(''''XSS'''');"

	// whenever this string now is added to the users image this will be the outcome, leading
	// to xss:

	<img src="http://image.com/image.jpg" alt="this is an image" onload="alert(''''XSS'''')"" />

	// After this sanitation malicious code can no longer exist in the post_params array.

	// Another possibility for attackers to execute an XSS injection, is to pass malicious code directly
	// into the URL by means of a "href", e.g.:
	// javascript:alert(document.cookie);
	// or
	// data:text/html;base64,base64xssinjection

	// In the following scenario escaping with sanitize() is not sufficient to block the injection.
	// By checking the URL to see if it starts with either http:// or https:// whenever a link has
	// been submitted to the web application by a user.','ruby-needs-reviewing',1);
INSERT INTO "code_items" VALUES (263,'Password forget and disallow old passwords',' Password forget and disallow of old passwords

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
Whenever you are developing a password forget function, these are the steps to follow in order to create hardened defenses. 

```
TABLE users
| userID | userName | password | emailAddress | access |
|  |  |  |  |  |
| 1 | Admin | securely hashed password | info@admin.com | TRUE |
| 2 | User | securely hashed password | info@user.com | FALSE |
| 3 | Guest | securely hashed password | info@guest.com | FALSE |


`TABLE passwordForget`
| forgotPasswordID | token | userID | active | oldPasswordHashes |
|  |  |  |  |  |
| 1 | c3ab8ff13720e.... | 1 | Yes | <......> |
| 2 | 7dd39466b3c89.... | 1 | No | <......> |
| 3 | 83d4a3960714c.... | 3 | No | <......> |
```

As you can see we also store the old passwords into the password forget table. This is done in order to prevent the user from using old passwords later on in the process.

Also use a CRON job to make sure that the generated tokens for the password reset expire after a certain amount of time like 20 minutes.

THIS CODE NEEDS TO BE CLEANED UP

```js
app.post(''''/forgot'''', function(req, res, next) {
      async.waterfall([
        function(done) {
          crypto.randomBytes(20, function(err, buf) {
            var token = buf.toString(''''hex'''');
            done(err, token);
          }); 
        },
        function(token, done) {
          User.findOne({ email: req.body.email }, 
            function(err, user) { // get user by email
              if (!user) {
                req.flash(''''Success'''', ''''You should receive an email with your password reset link shortly'''');
                return res.redirect(''''/forgot'''');
              }
              user.resetPasswordToken = token;
              user.resetPasswordExpires = Date.now() + PASSWORD_EXPIRY_TOKEN_DURATION; // 1 hour
              user.save(function(err) {
                done(err, token, user);
              });
            });
        },
        function(token, user, done) {
          send_reset_password_email()
        }
      ])
    }, 
    function(err) {
      if (err) return next(err);
      res.redirect(''''/forgot'''');
    });

    app.get(''''/reset/:token'''', function(req, res) {
      User.findOne({ resetPasswordToken: req.params.token, resetPasswordExpires: { $gt: Date.now() } }, function(err, user) {
        if (!user) {
          req.flash(''''error'''', ''''Password reset token is invalid or has expired.'''');
          return res.redirect(''''/forgot'''');
        }
        res.render(''''reset'''', {
          user: req.user
        });
      });
    });

    app.post(''''/reset/:token'''', function(req, res) {
      async.waterfall([
        function(done) {
          User.findOne({ 
            resetPasswordToken: req.params.token, resetPasswordExpires: { $gt: Date.now() }, 
            function(err, user) {
              if (!user) {
                req.flash(''''error'''', ''''Password reset token is invalid or has expired.'''');
                return res.redirect(''''back'''');
              }
              if (req.body.password ) {
                hash = password_hash(req.body.password)
                user.resetPasswordToken = undefined;
                user.resetPasswordExpires = undefined;
                user.save(function(err) {
                  req.logIn(user, function(err) {
                    done(err, user);
                  });
                });
              });
            }
          });
        }
        function(user, done) {
          send_pass_change_confirmation_email()
        }
      ]), 
      function(err) {
        res.redirect(''''/'''');
      })  
    });
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (264,'Timeout Sessions',' Session timeout 

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example:
```
app.use(express.session({
             secret : ''''your_cookie_secret'''',
             cookie:{_expires : (10 * 60 * 1000)}, // time im ms, this is 10 minutes
             })
        ); 
     
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (265,'Prepared Statements SQL',' Encoder (SQL  Parameterized Inputs)

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
Execute prepared statement with parameterized user inputs using [`mysql` module](https://www.npmjs.com/package/mysql):
```js
const sqlQuery = ''''SELECT * FROM accounts WHERE username=? AND password=?'''';

connection.query(sqlQuery, [username, passwordHash], (err, rows, fields) => {
	// handle both success and failure for query result 
});

connection.end();
```

 Considerations
TBA
	
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (266,'CSRF Token csurf',' CSRF Tokens

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General

If you''''re using JSON over REST to mutate server state and the application doesn''''t support plain HTML form submissions and your CORS configuration bans crossdomain requests then Express has builtin CSRF protection.

If you support plain HTML form submissions, read on.

**Hint:** you can check if you support plain HTML form submissions by searching for:

```js
const bodyParser = require(''''bodyparser'''');
bodyParser.urlencoded();
```

 Example

The following handlebar template snippet shows the code used to place the antiCSRF token inside a html page.

When the page renders, the `<cu:antiCSRF/>` is created as a viewstate encoded html input tag which then carries the antiCSRF token. While in process of rendering the page, a new token is generated and added into the existing session.

When the user presses the commandButton then CSRF token parameter is compared with the CSRF session parameter. 

```hbs
<form action="/process" method="POST">
	<input type="hidden" name="_csrf" value="{{csrfToken}}">
	...
	<button type="submit">Submit</button>
</form>
```

The following snippet is used to generate and check the token:

```js
const csrf = require(''''csurf''''); //csrf module
const csrfProtection = csrf({ cookie: true }); // setup route middlewares

// This is required because "cookie" is true in csrfProtection
app.use(cookieParser());

// Error handler(Optional) shows custom error message when token is missing or mismatches
app.use((err, req, res, next) => {
	// on token validation fail, error is thrown with code ''''CSRFERROR''''
	if (err.code !== ''''CSRFERROR'''') return next(err);
	res.status(403);
	res.send(''''csrf error'''');
});

// We need to pass the middleware to each route 
app.get(''''/form'''', csrfProtection, (req, res) => {
	// generate and pass the csrfToken to the view
	res.render(''''send'''', { csrfToken: req.csrfToken() });
});

// and check it when the request is being processed  
app.post(''''/process'''', parseForm, csrfProtection, (req, res) => {
	res.send(''''data is being processed'''');
});
```

 Considerations 
`csurf` doesn''''t protect by default requests such as `GET`, `OPTIONS`, `HEAD`.
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (267,'Directory path traversal attack',' Directory Path traversal

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
First, we want to filter the filenames for expected values. For this example the filenames should consist of only alphanumeric characters, which we validate with the following regex  `/^[azAZ09]+$/`.
```js
const isValidPath = path => {
    const filenamesRegex = /^[azAZ09]+$/;
    return filenamesRegex.test(path);
};
```

Then we whitelist the path to only the allowed locations using the [path](https://nodejs.org/api/path.html) library. `dirWhitelist` is an array of directory pathnames (such as `/foo/bar/baz`) the application is allowed to load resources from:
```js
const isAllowedLocation = path =>
    dirWhitelist.includes(path.dirname(path));
```

Together the methods shown above can be used as follows:
```js
app.get(''''/readfile'''', (req, res) => {
    const filePath = req.query.filename;
    if(isValidPath(filePath) && isAllowedLocation(filePath)) {
        // serve request
    } else {
        // return error
    }
});
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (268,'Logout',' Logout Functionality

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General

 Example
Using [Passport](http://www.passportjs.org/docs/logout/) as a middleware call logOut() or logout() on your req object.
```
app.get(''''/logout'''', function(req, res){
  req.logout();
  res.redirect(''''/'''');
});

```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (269,'File uploading',' File Uploading 

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
TBA

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (270,'Sandboxing',' Iframe Sandboxing

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
Sandboxing applies a set of restrictions to the iframes in order to tighten security. It can be declared as follows:
```html
<iframe sandbox="value">
```

Full list of permitted values is available in [MDN iframe documentation](https://developer.mozilla.org/enUS/docs/Web/HTML/Element/iframeattrsandbox).

 Example
To enable full sandbox mode please use the following code:
```html
<iframe sandbox>...</iframe>
``` 

Desired restriction can be lifted as shown below: 
```html
<iframe sandbox="allowforms allowscripts">...</iframe>
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (271,'Hashing',' Hashing

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
For this you can use [`bcrypt` module](https://www.npmjs.com/package/bcrypt):
```js
const bcrypt = require(''''bcrypt'''')
	
const hash = password => {
	const saltRounds = 10;
	return bcrypt.hash(myPlaintextPassword, saltRounds);
}
```

Asynchronous method:
```js
const validatePassword = (user, password) => {
	bcrypt.compare(myPlaintextPassword, hash, (err, res) => {
		if(res) {
			// Passwords match, handle success
		} else {
			// Passwords don''''t match, handle failure
		} 
	});
};
```

Synchronous method:
```js
const validatePassword = (user, password) => {
	if(bcrypt.compareSync(''''somePassword'''', hash)) {
		// Passwords match, handle success
		return true;
	} else {
		// Passwords don''''t match, handle failure
		return false;
	}
}
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (272,'Anti clickjacking',' Anticlickjacking

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
One way to defend against clickjacking is to include a `framebreaker` script in each page that should not be framed. The following methodology will prevent a webpage from being framed even in legacy browsers, that do not support the `XFrameOptionsHeader`.

In the document `HEAD` element please add the following code:
1. Apply an ID to the style element itself:
```html
<style id="antiClickjack">
    body {
        display:none !important;
    }
</style>
```
2. And then delete that style by its ID immediately after in the script:
```html
 <script type="text/javascript">
    if(self === top) {
        const antiClickjack = document.getElementById("antiClickjack");
        antiClickjack.parentNode.removeChild(antiClickjack);
    } else {
        top.location = self.location;
    }
</script>
```

The second option is to use security headers. There are two options for setting the `anticlickjacking` headers in your application:.

This will completely prevent your page from being displayed in an iframe:
```js
response.addHeader(''''XFrameOptions'''', ''''deny'''');
```

This will completely prevent your page from being displayed in an iframe on other sites:
```js
response.addHeader(''''XFrameOptions'''', ''''SAMEORIGIN'''');
```

Alternatively you can use [`helmet` module]( https://www.npmjs.com/package/helmet) which sets `XFRAME` headers along with a host of other security headers.

If you only want `XFRAMEOPTIONS` please use [`frameguard`](https://github.com/helmetjs/frameguard).
```js
const frameguard = require(''''frameguard'''');

// Don''''t allow me to be in ANY frames:
app.use(frameguard({ action: ''''deny'''' }));

// Only let me be framed by people of the same origin:
app.use(frameguard({ action: ''''sameorigin'''' }));
app.use(frameguard());  // defaults to sameorigin

// Allow from a specific host:
app.use(frameguard({
    action: ''''allowfrom'''',
    domain: ''''http://example.com''''
}));
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (273,'Anti caching headers',' Anticashing headers 

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
Add the following headers to your response head in order to prevent the browser from caching:

 HTTP 1.1
```js
resp.set(''''CacheControl'''', ''''nocache, nostore, mustrevalidate'''');
```

 HTTP 1.0
```js
res.set(''''Pragma'''', ''''nocache'''');
```

 Proxies
```js
res.set(''''Expires'''', ''''0'''');
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (274,'session hijacking and fixation',' Session hijacking and fixation 

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
First you need to implement the strict transport security header. This is done in order to prevent users from accessing your application over an unprotected connection.

Strict transport security header can be set as shown below:
```js
response.setHeader(''''StrictTransportSecurity'''', ''''maxage=31536000'''');
```

If all present and future subdomains will be `HTTPS`:
```js
response.setHeader(''''StrictTransportSecurity'''', ''''maxage=31536000; includeSubdomains;'''');
```

We recoomend to have your domain included in the `HSTS` preload list maintained by Chrome (and used by Firefox and Safari). To achieve this you need to do the following: 
```js
response.setHeader(''''StrictTransportSecurity'''', ''''maxage=31536000; includeSubdomains; preload'''');
```

The `preload` flag indicates the site owner''''s consent to have their domain preloaded. The preload list
enforces the browser to always present your application on HTTPS even on the first time the user hits your application.

Then you should set the `httpOnly` flag (please see "HttpOnly" in the code examples for more details about implementation).

Then set the flag for session timeout (please see "Timeout" in the code examples for more details about implementation).

Then set the session `secure` flag (see "Secure flag" in the code examples for more details about implementation).

On login we also need to add another cookie with a random value to the application in order to prevent an attacker to fixate an `JSSESSION` id on your users and hijack their sessions (This code example can be found in the "Login functionality" for more detailed information).

Now imagine the scenario after the login of the user (see the "Login functionality" in the code examples for more details). Whenever the user is logged in, the users IP address, user agent string and session id are also stored in the database these values are used in order to verify if there are multiple users active on the same session. 

If so, we can let the user decide to terminate the session and terminate theother assigned sessions.
```js
const login = (**args**) => {
		/* Passport prevents session fixation but doesn''''t track concurrent long lived sessions, this is custom code on top of passport
		*/
}
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (275,'Randomizer function',' Randomizer function

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
Please see [documentation for randomizer function](https://nodejs.org/api/crypto.htmlcrypto_crypto_randombytes_size_callback).

 Example
Asynchronous:
```js
const crypto = require(''''crypto'''');

crypto.randomBytes(256, (err, buf) => {
    //buf holds your bytes
    if (err) throw err;

    console.log(`${buf.length} bytes of random data: ${buf.toString(''''hex'''')}`);
});
```

Synchronous:
```js
const crypto = require(''''crypto'''');
const buf = crypto.randomBytes(256);

console.log(`${buf.length} bytes of random data: ${buf.toString(''''hex'''')}`);
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (276,'Charsets',' Charsets

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
Charset header should be set on the response your server sends back to the client. For example, in the case of `text/html` this can be achieved by the following code: 
```js
res.charset = ''''utf8''''; //utf8 is the default encoding for json
```

Or directly in your HTML markup:
```html
<meta httpequiv="ContentType" content="text/html; charset=utf8">
```

 Considerations
TBA
    		','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (277,'X Content Type Options header',' `XContentTypeOptions` header

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
In order to set the `XContentTypeOptions` header you''''ll have to add the following code to the head of your application:
```js
res.set(''''XContentTypeOptions'''', ''''nosniff'''');
```

Alternatively you can use [`dontsniffmimetype` module](https://www.npmjs.com/package/dontsniffmimetype):
```js
const nosniff = require(''''dontsniffmimetype'''');

app.use(nosniff());
```

The same can be achieved by using [`helmet` module]( https://www.npmjs.com/package/helmet) which sets XFRAME headers along with a host of other security headers.

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (278,'XSS Filtering',' XSS filtering

 [General](general)
 [Example](example)
   [Dangerous methods in frameworks](dangerousmethodsinframeworks)
 [Considerations](considerations)

 General
TBA

 Example:
If you''''re creating server  side pages you can use [`dompurify`](https://www.npmjs.com/package/dompurify) to sanitize strings as shown below:
```js
const dompurify = require(''''dompurify'''');
...
const clean = DOMPurify.sanitize(dirty);
```
Then you can use sanitized string as normal.

 Dangerous methods in frameworks
If you''''re using a template engine or a framework, then **AVOID** using the following methods:

 {{ mustache }} and Handlebars
```hbs
{{{ raw html }}}
```

 EJS
```
<% raw html %>
```

 Nunjucks
```
{% raw html %}
```

 Angular
```
<div ngbindhtml="raw html" />
```

 React
```
<div dangerouslySetInnerHTML={raw html} />
```

 Vue.js
```
<div vhtml="raw html" />
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (279,'User Registration SQL truncation prevention',' User registration SQL truncation prevention

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
In order to prevent Column truncation SQL injection we have to make sure that the applications structural logic does not mismatches with the database structural logic.

To achieve this imagine the follow example of a user model:

```
// models/user.js
// load the things we need
var database = require(''''my_favorite_database'''');


// define the schema for our user model
var userSchema = database.Schema({

    local            : {
        email        : String,
        password     : String,
        firstname    : String,
        lastname     : String,
    }
});
```

Then we need to define some methods to hash passwords and check password validity

```
var bcrypt   = require(''''bcryptnodejs'''');
// to hash
userSchema.methods.generateHash = function(password) {
    return bcrypt.hashSync(password, bcrypt.genSaltSync(8), null);
};

// to validate
userSchema.methods.validPassword = function(password) {
    return bcrypt.compareSync(password, this.local.password);
};

// create the model for users and expose it to our app
module.exports = database.model(''''User'''', userSchema);

```
Then you can config the [Passport](http://www.passportjs.org/) middleware to handle your local authentication strategy

```
// authentication.js

// load all the things we need
var LocalStrategy   = require(''''passportlocal'''').Strategy;

// load up the user model
var User = require(''''models/user'''');

// expose this function to our app using module.exports
module.exports = function(passport) {

    // passport needs ability to serialize and unserialize users out of session

    // used to serialize the user for the session
    passport.serializeUser(function(user, done) {
        done(null, user.id);
    });

    // used to deserialize the user
    passport.deserializeUser(function(id, done) {
        User.findById(id, function(err, user) {
            done(err, user);
        });
    });
    
    passport.use(''''localsignup'''', new LocalStrategy({
        usernameField : ''''email'''',
        passwordField : ''''password'''',
        passReqToCallback : true
    },
    function(req, email, password, firstname, lastname done) {
        process.nextTick(function() {
            User.findOne({ ''''local.email'''' :  email }, function(err, user) {
                if (err)
                  return done(err);
      
                if (user) {
                    return done(null, false, req.flash(''''signupMessage'''', ''''User exists''''));
                } else {
                    var user             = new User();
                    user.local.email     = email;
                    user.local.password  = user.generateHash(password);
                    user.local.firstname = firstname;
                    user.local.lastname  = lastname

                // save the user
                newUser.save(function(err) {
                    if (err)
                        throw err;
                    return done(null, user);
                });
            }

        });    

        });

    }));

};

```

Then in the app routes

```
 // signup form processing
    app.post(''''/register'''', passport.authenticate(''''localsignup'''', {
        successRedirect : ''''/profile'''', // redirect to the secure profile section
        failureRedirect : ''''/register'''', // redirect back to the signup page if there is an error
        failureFlash : true // allow flash messages
    }));


```


 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (280,'Open Forwards and redirects',' Open Forwards and Redirects 

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
When using forwards and redirects you should make sure the URL is being explicitly declared in the code and cannot be manipulated by an attacker like in the case of `redirectTo` being dynamically set based on user input:
```js
app.get(''''/offers'''', (req, res, next) => {
    const redirectTo = req.query.redirect;
    res.redirect(redirectTo);
});
```

Generally you should avoid getting parameters which could contain user input into the redirect by any means. If for any reason this is not feasible, then you should make a whitelist input validation for the redirect as shown below:
```js
const validRedirectURLs = [...]; // list of URLs permitted for redirection

app.get(''''/offers'''', (req, res, next) => {
    const redirectTo = req.query.redirect;

    if(validRedirectURLs.includes(redirectTo)) {
        res.redirect(redirectTo);
    } else {
        return res.status(500).send({ error: ''''Invalid redirection URL'''' });
    }
});
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (281,'Secure Session Cookies',' Secure flag for session cookies

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
In [`expresssession` module](https://www.npmjs.com/package/expresssession) it is possible to supply `secure` flag as a part of `cookie` configuration.

This flag instructs the browser to never send cookies over an `HTTP` request. The cookie will only be sent over `HTTPS` even if the user manually types in a request for `HTTP`. The HTTP request itself will be sent, but the browser will not send any cookies.

 Example
A session with secured cookies can be created in the following way:
```js
app.use(session({
    name: ''''session'''',
    keys: [''''key1'''', ''''key2''''],
    cokkie: {
        secure: true
        httpOnly: true,
        domain: ''''complete.subdomain.example.com'''',
        path: ''''foo/bar'''',
        expires: expiryDate
    } 
}));
```

 Considerations
The `HTTP` request is still sent and thus could be manipulated by a man in the middle to perform convincing phishing attacks (please see Strict Transport Security for a recommended solution).

Setting the `domain` attribute to a too permissive value, such as `example.com`, allows an attacker to launch attacks on the session IDs between different hosts and web applications belonging to the same domain, known as crosssubdomain cookies. For example, vulnerabilities in `example.com` might allow an attacker to get access to the session IDs from `secure.example.com`.
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (282,'Login function',' Login Functionality 

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
TBA

 Example
Using the [Passport middleware](http://www.passportjs.org/)

The following example assumes username/password authentication.

First, configure the middleware:
```
 var auth_manager = require(''''passport'''')
  , LocalStrategy = require(''''passportlocal'''').Strategy;

auth_manager.use(new LocalStrategy(
  function(username, password, done) {
    User.findOne({ username: username }, function(err, user) {
      if (err) { return done(err); }
      if (!user) {
        return done(null, false, { message: ''''Incorrect username.'''' });
      }
      if (!user.validPassword(password)) {
        return done(null, false, { message: ''''Incorrect password.'''' });
      }
      return done(null, user);
    });
  }
));
```

Then, register the route handling authentication can be:
```
app.post(''''/login'''',
  auth_manager.authenticate(''''local'''', { successRedirect: ''''/'''',
                                   failureRedirect: ''''/login''''
				   })
);
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (283,'HttpOnly flag',' `httpOnly` flag

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
`httpOnly` flag can be added to the `SetCookie` response header in order to dissalow clientside scripts from accessing or modifying the cookie in question. This can help to mitigate most common XSS attacks by protecting the cookie data.

 Example
When setting sessions with [`expresssession` module](https://www.npmjs.com/package/expresssession) you can add the `cookie` portion of the configuration as shown below in order to protect session ID cookie:
```js
const session = require(''''expresssession'''');

app.use(session({
  secret: ''''some random and long value'''',
  key: ''''sessionId'''',
  cookie: {
    httpOnly: true,
    secure: true
  }
}));
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (284,'RFD and file download injections',' RFD and file download injections

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
You should **not** accept random filenames for downloading from users and use path sanitizations as shown earlier with RBAC to make sure that the user owns the file being downloaded.

 Example:
TBA

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (285,'Identifier based authorization',' Identifierbased authorization

 [General](general)
 [Example](example)
 [Considerations](considerations)

 General
Database expected is MS SQL server making use of [mssql](https://www.npmjs.com/package/mssql).
`file_access` is formatted as so:
| user_id | file_id |
|||
| 1       | 2       |
Where both ids are foreign keys and the primary key is made of a composite of the two.

 Example
```js
const express = require(''''express'''');
const session = require(''''expresssession'''')
const FileStore = require(''''sessionfilestore'''')(session);
const bodyParser = require(''''bodyparser'''');
const passport = require(''''passport'''');
const LocalStrategy = require(''''passportlocal'''').Strategy;
const sql = require(''''mssql'''')

//Made up external files
const validator = require(''''./validator''''); //Handles validating logins
const files = require(''''./files''''); //Gets files from DB or store



// configure passport.js to use the local strategy
passport.use(new LocalStrategy(
	{ usernameField: ''''email'''' }, (email, password, done) => {
		const user = validator.login(email, password); //Validator returns false if invalid
		return done(null, user)
	}
));

// tell passport how to serialize the user
passport.serializeUser((user, done) => {
  	done(null, user.id);
});

passport.deserializeUser((id, done) => {
	const user = users.getUserById(id);
  	done(null, user);
});

// create the server
const app = express();

// add & configure middleware
app.use(bodyParser.urlencoded({ extended: false }))
app.use(bodyParser.json())
app.use(session({
  store: new FileStore(),
  secret: process.env.sessionKey, //always use environment variables to pass in keys.
  resave: false,
  saveUninitialized: true
}))
app.use(passport.initialize());
app.use(passport.session());

//Login excluded

app.get(''''/post'''',  passport.authenticate(''''local'''', { failureRedirect: ''''/login'''' }), //authenticates the user using session
   async function(req, res) {
	  	const data = req.body;
	  	let pool = await sql.connect(config)
		let result = await pool.request()
			.input(''''user_id'''', sql.Int, req.user.id) //sql.Int validates that only a integer value can be in the variable
			.input(''''file_id'''', sql.Int, data.id)
            .query(''''select * from file_access where user_id = @user_id and file_id = @file_id''''); //variables inlined into sql query

		if(result.recordsets.length === 1) { //If the result exists the user has access
			res.send(files.getFile(data.id)) //sends file
		} else {
			res.redirect(''''/invalidFile''''); //redirects to a generic invalid file
		}
  });
```

 Considerations
TBA
','nodejs-express-needs-reviewing',1);
INSERT INTO "code_items" VALUES (286,'SEMGREP',' SEMGREP


 Example:

    Lang support:
    Go, Java, JavaScript, JSON, Python, Ruby (beta,) C (alpha), OCaml (alpha)

     A simple, customizable, and fast static analysis tool for finding bugs
     Combines the speed and customizability of grep with the precision of traditional static analysis tools
     No painful domainspecific language; Semgrep rules look like the source code you’re targeting
     Runs offline on uncompiled code in CI, at precommit, or in the editor
     Opensource maintained and commercially supported by r2c

    Out of the box Semgrep has a good ruleset but the trick is to write
    your own to automatically govern your ASVS controls.

    Rule example python:
    ```
    rules:
     id: unsafeexec
      pattern: |
        exec(...);
      message: |
        Avoid use of exec; it can lead to a remote code execution.
      fix: |
        
      severity: WARNING
      ```


    Follow the link to find more rulesets, how to run semgrep on
    PR''''s in CI.

    [link to Semgrep](https://semgrep.dev/)

    [link to Semgrep Github](https://github.com/returntocorp/semgrep)','testing',1);
INSERT INTO "code_items" VALUES (287,'SONARQUBE',' Sonarqube


 Example:

        SonarQube® is an automatic code review tool to detect bugs, vulnerabilities, and
        code smells in your code. It can integrate with your existing workflow to 
        enable continuous code inspection across your project branches and pull requests

        Out of the box Sonarqube has a good ruleset but the trick is to write
        your own to automatically govern your ASVS controls.

        There are two ways to extend coding rules:

         Writing coding rules using Java via a SonarQube plugin
         Adding XPath rules directly through the SonarQube web interface

        [Adding code rules docs](https://docs.sonarqube.org/latest/extend/addingcodingrules/)

        To run sonarqube and sonarscanner containerized
        [Sonarqube containers](https://hub.docker.com/_/sonarqube)

        Lang support:

        ABAP, Apex, C, C/C++/ObjectiveC, COBOL, Code Quality and Security for CSS,
        Flex, Go, HTML, Java, JavaScript / TypeScript, Kotlin, PHP, PLI, PL/SQL, Python,
        RPG, Ruby, Scala, Swift, TSQL, VB.NET, VB6, XML','testing',1);
INSERT INTO "code_items" VALUES (288,'ZAP passive',' OWASP ZAP passive


 Example:

        The ZAP Baseline scan is a script that is available in the ZAP Docker images.

        It runs the ZAP spider against the specified target for (by default) 1 minute and then waits for 
        the passive scanning to complete before reporting the results.

        This means that the script doesn''''t perform any actual ‘attacks’ and will run for a relatively 
        short period of time (a few minutes at most).

        By default it reports all alerts as WARNings but you can specify a config file which can change 
        any rules to FAIL or IGNORE.

        This script is intended to be ideal to run in a CI/CD environment, even against production sites.

        [ZAP basline scan docs](https://www.zaproxy.org/docs/docker/baselinescan/)
','testing',1);
INSERT INTO "code_items" VALUES (289,'ZAP active',' OWASP ZAP active


 Example:

        The ZAP full scan is a script that is available in the ZAP Docker images.

        It runs the ZAP spider against the specified target (by default with no time limit) followed by an optional ajax spider scan and then a full active scan before reporting the results.

        This means that the script does perform actual ‘attacks’ and can potentially run for a long period of time.

        By default it reports all alerts as WARNings but you can specify a config file which can change any rules to FAIL or IGNORE. 

        [ZAP active scan docs](https://www.zaproxy.org/docs/docker/fullscan/)
        [ZAP API scan docs](https://www.zaproxy.org/docs/docker/apiscan/)','testing',1);
INSERT INTO "code_items" VALUES (290,'Dependency check',' OWASP Dependency check


 Example:

        DependencyCheck is a Software Composition Analysis (SCA) tool that attempts to detect 
        publicly disclosed vulnerabilities contained within a project’s dependencies. It does 
        this by determining if there is a Common Platform Enumeration (CPE) identifier for a 
        given dependency. If found, it will generate a report linking to the associated CVE entries.

        Dependencycheck has a command line interface, a Maven plugin, an Ant task, 
        and a Jenkins plugin. The core engine contains a series of analyzers that inspect the 
        project dependencies, collect pieces of information about the dependencies 
        (referred to as evidence within the tool). The evidence is then used to identify the 
        Common Platform Enumeration (CPE) for the given dependency. If a CPE is identified, a 
        listing of associated Common Vulnerability and Exposure (CVE) entries are listed in a report. 
        Other 3rd party services and data sources such as the NPM Audit API, the OSS Index, 
        RetireJS, and Bundler Audit are utilized for specific technologies.

        [Dependency check project page](https://owasp.org/wwwprojectdependencycheck/)
','testing',1);
INSERT INTO "code_items" VALUES (291,'Dependency track',' OWASP Dependency track


 Example:

        DependencyTrack is an intelligent Supply Chain Component Analysis platform that allows 
        organizations to identify and reduce risk from the use of thirdparty and open source components. 
        DependencyTrack takes a unique and highly beneficial approach by leveraging the capabilities of 
        Software Bill of Materials (SBOM). This approach provides capabilities that traditional Software
        Composition Analysis (SCA) solutions cannot achieve

        DependencyTrack monitors component usage across all versions of every application in 
        its portfolio in order to proactively identify risk across an organization. 
        The platform has an APIfirst design and is ideal for use in Continuous Integration 
        (CI) and Continuous Delivery (CD) environments.

        [Main OWASP page](https://owasp.org/wwwprojectdependencytrack/)
','testing',1);
INSERT INTO "code_items" VALUES (292,'Selenium',' OWASP Dependency track


 Example:

        Selenium automates browsers. That''''s it!
        What you do with that power is entirely up to you.
        Primarily it is for automating web applications for testing purposes, 
        but is certainly not limited to just that. We can also use it
        to interactivly use it for testing security requirements.


        [Selenium main site](https://www.selenium.dev/)
        [Python Selenium](https://seleniumpython.readthedocs.io/)
','testing',1);
INSERT INTO "code_items" VALUES (293,'ZAP ZEST',' OWASP Dependency track


 Example:

        Zest is an experimental specialized scripting language (also known as a domainspecific language) 
        developed by the Mozilla security team and is intended to be used in web oriented security tools.

        It is included by default with ZAP.

        ZEST can be used to record and replay attacks to your applications in
        a running state to identify the existence of attacks.

        When security teams find vulnerabilities they typically describe them to developers using words, for example in a PDF or via a bug tracker. Unfortunately in many cases developers may lack the security knowledge to understand or reproduce the problem. Also security teams often use tools which the developers do not have access to or have no experience with. And developers sometime fail to solve the underlying problems.

        While it will still be necessary to describe vulnerabilities, Zest allows security teams to create reproducible test cases which they can then share with the developers. These test cases can be used by the developers to reproduce the issues and test their fixes.

        Ideally security engineers will be able to use their favourite security tools to create Zest scripts while developers will be able to rerun those scripts using the tools that they are familiar with.

        In this case the sequence of events could be:

        1. The security team discovers a vulnerability using specialist security tools
        2. They use those tools to create a Zest script which reproduces the problem
        3. They hand the script over to the developer
        4. The developer adjusts the script to match their local environment
        5. They run the script and see the vulnerability
        6. They fix the vulnerability
        7. They rerun the script to check that the vulnerability is fixed
        8. The fix is applied to the system that the security team is testing
        9. The security team rerun the script as an initial check
        10. They then perform any manual testing they think is necessary
        11. Note that the developers could also include the script in the regression tests to make sure that it doesnt reoccur.

        [ZEST main site](https://www.zaproxy.org/docs/desktop/addons/zest/)
        [ZEST more info](https://developer.mozilla.org/enUS/docs/Mozilla/Projects/Zest)','testing',1);
INSERT INTO "code_items" VALUES (294,'O Saft',' OWASP Osaft


 Example:

        DESCRIPTION
        This tools lists  information about remote target''''s  SSL  certificate
        and tests the remote target according given list of ciphers.

        UNIQUE FEATURES
        ===============
        working in closed environments, i.e. without internet connection
        checking availability of ciphers independent of installed library
        checking for all possible ciphers up to 65535 per SSL protocol
        needs just perl without modules for checking ciphers and protocols
        mainly same results on all platforms

        [OSaft Github](https://github.com/OWASP/OSaft)','testing',1);
INSERT INTO "code_items" VALUES (295,'CODEQL',' CODEQL


 Example:

        Lang support:
        Go, Java, JavaScript, TypeScript, Python, C, C++, C

         CodeQL is the industryleading semantic code analysis engine.
         CodeQL lets you query code as though it were data.
         Write a query to find all variants of a vulnerability, using an objectoriented logic programming language, and reusing builtin libraries for data flow and taint tracking analysis. 
         Then share your query to help others do the same, by contributing to the open source repository.

        CodeQL is free for research and open source.

        Out of the box, CodeQL provides a standard set of queries created by GitHub, language experts, and security researchers. As the queries are open source, the community maintains and updates them to improve analysis and reduce false positives.

        Example: [Clientside crosssite scripting in JavaScript](https://lgtm.com/rules/2022121412/)
        ```
        import javascript
        import semmle.javascript.security.dataflow.DomBasedXss::DomBasedXss
        import DataFlow::PathGraph

        from Configuration cfg, DataFlow::PathNode source, DataFlow::PathNode sink
        where cfg.hasFlowPath(source, sink)
        select sink.getNode(), source, sink,
            sink.getNode().(Sink).getVulnerabilityKind() + " vulnerability due to $@.", source.getNode(),
            "userprovided value"
        ```

        You can benefit from the power of the CodeQL analysis on your GitHub repository with GitHub code scanning. Just visit ["Enabling code scanning for a repository"](https://docs.github.com/en/freeproteam@latest/github/findingsecurityvulnerabilitiesanderrorsinyourcode/enablingcodescanningforarepository), to get the standard set of CodeQL queries protecting your code, on a given schedule, or during a Pull Request, so that the vulnerability never reaches your main branch. 

        [link to CodeQL](https://codeql.com)

        [link to CodeQL open source queries](https://github.com/codeql)

        [link to CodeQL open source queries for GO](https://github.com/github/codeqlgo)
','testing',1);
INSERT INTO "checklist_types" VALUES (1,'Architecture, Design and Threat Modeling Requirements','Security architecture has almost become a lost art in many organizations. The days of the enterprise architect have passed in the age of DevSecOps. The application security field must catch up and adopt agile security principles while re-introducing leading security architecture principles to software practitioners. Architecture is not an implementation, but a way of thinking about a problem that has potentially many different answers, and no one single "correct" answer. All too often, security is seen as inflexible and demanding that developers fix code in a particular way, when the developers may know a much better way to solve the problem. There is no single, simple solution for architecture, and to pretend otherwise is a disservice to the software engineering field.',1,1);
INSERT INTO "checklist_types" VALUES (2,'Authentication Verification Requirements','Authentication is the act of establishing, or confirming, someone (or something) as authentic and that claims made by a person or about a device are correct, resistant to impersonation, and prevent recovery or interception of passwords.',1,1);
INSERT INTO "checklist_types" VALUES (3,'Session Management Verification Requirements','One of the core components of any web-based application or stateful API is the mechanism by which it controls and maintains the state for a user or device interacting with it. Session management changes a stateless protocol to stateful, which is critical for differentiating different users or devices.',1,1);
INSERT INTO "checklist_types" VALUES (4,'Access Control Verification Requirements','Authorization is the concept of allowing access to resources only to those permitted to use them. Ensure that a verified application satisfies the following high level requirements:• Persons accessing resources hold valid credentials to do so.* Users are associated with a well-defined set of roles and privileges.• Role and permission metadata is protected from replay or tampering.',1,1);
INSERT INTO "checklist_types" VALUES (5,'Validation, Sanitization and Encoding Verification Requirements','The most common web application security weakness is the failure to properly validate input coming from the client or the environment before directly using it without any output encoding. This weakness leads to almost all of the significant vulnerabilities in web applications, such as Cross-Site Scripting (XSS), SQL injection, interpreter injection, locale/Unicode attacks, file system attacks, and buffer overflows.',1,1);
INSERT INTO "checklist_types" VALUES (6,'Stored Cryptography Verification Requirements','Ensure that a verified application satisfies the following high level requirements: • All cryptographic modules fail in a secure manner and that errors are handled correctly. • A suitable random number generator is used. • Access to keys is securely managed. V6.1 Data Classification',1,1);
INSERT INTO "checklist_types" VALUES (7,'Error Handling and Logging Verification Requirements','The primary objective of error handling and logging is to provide useful information for the user, administrators, and incident response teams. The objective is not to create massive amounts of logs, but high quality logs, with more signal than discarded noise.',1,1);
INSERT INTO "checklist_types" VALUES (8,'Data Protection Verification Requirements','There are three key elements to sound data protection: Confidentiality, Integrity and Availability (CIA). This standard assumes that data protection is enforced on a trusted system, such as a server, which has been hardened and has sufficient protections.',1,1);
INSERT INTO "checklist_types" VALUES (9,'Communications Verification Requirements','Leading industry advice on secure TLS configuration changes frequently, often due to catastrophic breaks in existing algorithms and ciphers. Always use the most recent versions of TLS configuration review tools (such as SSLyze or other TLS scanners) to configure the preferred order and algorithm selection. Configuration should be periodically checked to ensure that secure communications configuration is always present and effective.',1,1);
INSERT INTO "checklist_types" VALUES (10,'Malicious Code Verification Requirements','Finding malicious code is proof of the negative, which is impossible to completely validate. Best efforts should be undertaken to ensure that the code has no inherent malicious code or unwanted functionality.',1,1);
INSERT INTO "checklist_types" VALUES (11,'Business Logic Verification Requirements','Ensure that a verified application satisfies the following high level requirements: • The business logic flow is sequential, processed in order, and cannot be bypassed. • Business logic includes limits to detect and prevent automated attacks, such as continuous small funds transfers, or adding a million friends one at a time, and so on. • High value business logic flows have considered abuse cases and malicious actors, and have protections against spoofing, tampering, repudiation, information disclosure, and elevation of privilege attacks.',1,1);
INSERT INTO "checklist_types" VALUES (12,'File and Resources Verification Requirements','Ensure that a verified application satisfies the following high level requirements: • Untrusted file data should be handled accordingly and in a secure manner. • Untrusted file data obtained from untrusted sources are stored outside the web root and with limited permissions.',1,1);
INSERT INTO "checklist_types" VALUES (13,'API and Web Service Verification Requirements','Ensure that a verified application that uses trusted service layer APIs (commonly using JSON or XML or GraphQL) has: • Adequate authentication, session management and authorization of all web services. • Input validation of all parameters that transit from a lower to higher trust level. • Effective security controls for all API types, including cloud and Serverless API Please read this chapter in combination with all other chapters at this same level; we no longer duplicate authentication or API session management concerns.',1,1);
INSERT INTO "checklist_types" VALUES (14,'Configuration Verification Requirements','Ensure that a verified application has: • A secure, repeatable, automatable build environment. • Hardened third party library, dependency and configuration management such that out of date or insecure components are not included by the application. • A secure-by-default configuration, such that administrators and users have to weaken the default security posture. Configuration of the application out of the box should be safe to be on the Internet, which means a safe out of the box configuration.',1,1);
INSERT INTO "checklist_types" VALUES (15,'Architecture, Design and Threat Modeling Requirements','In a perfect world, security would be considered throughout all phases of development. In reality however, security is often only a consideration at a late stage in the SDLC. Besides the technical controls, the MASVS requires processes to be in place that ensure that the security has been explicitly addressed when planning the architecture of the mobile app, and that the functional and security roles of all components are known. Since most mobile applications act as clients to remote services, it must be ensured that appropriate security standards are also applied to those services - testing the mobile app in isolation is not sufficient.',1,2);
INSERT INTO "checklist_types" VALUES (16,'Data Storage and Privacy Requirements','The protection of sensitive data, such as user credentials and private information, is a key focus in mobile security. Firstly, sensitive data can be unintentionally exposed to other apps running on the same device if operating system mechanisms like IPC are used improperly. Data may also unintentionally leak to cloud storage, backups, or the keyboard cache. Additionally, mobile devices can be lost or stolen more easily compared to other types of devices, so an adversary gaining physical access is a more likely scenario. In that case, additional protections can be implemented to make retrieving the sensitive data more difficult.',1,2);
INSERT INTO "checklist_types" VALUES (17,'Cryptography Requirements','Cryptography is an essential ingredient when it comes to protecting data stored on a mobile device. It is also a category where things can go horribly wrong, especially when standard conventions are not followed. The purpose of the controls in this chapter is to ensure that the verified application uses cryptography according to industry best practices.',1,2);
INSERT INTO "checklist_types" VALUES (18,'Authentication and Session Management Requirements','In most cases, users logging into a remote service is an integral part of the overall mobile app architecture. Even though most of the logic happens at the endpoint, MASVS defines some basic requirements regarding how user accounts and sessions are to be managed.',1,2);
INSERT INTO "checklist_types" VALUES (19,'Network Communication Requirements','The purpose of the controls listed in this section is to ensure the confidentiality and integrity of information exchanged between the mobile app and remote service endpoints. At the very least, a mobile app must set up a secure, encrypted channel for network communication using the TLS protocol with appropriate settings. Level 2 lists additional defense-in-depth measure such as SSL pinning.',1,2);
INSERT INTO "checklist_types" VALUES (20,'Platform Interaction Requirements','The controls in this group ensure that the app uses platform APIs and standard components in a secure manner. Additionally, the controls cover communication between apps (IPC).',1,2);
INSERT INTO "checklist_types" VALUES (21,'Code Quality and Build Setting Requirements','The goal of this control is to ensure that basic security coding practices are followed in developing the app, and that "free" security features offered by the compiler are activated.',1,2);
INSERT INTO "checklist_types" VALUES (22,'Resilience Requirements','This section covers defense-in-depth measures recommended for apps that process, or give access to, sensitive data or functionality. Lack of any of these controls does not cause a vulnerability - instead, they are meant to increase the apps resilience against reverse engineering and specific client-side attacks. The controls in this section should be applied as needed, based on an assessment of the risks caused by unauthorized tampering with the app and/or reverse engineering of the code. We suggest consulting the OWASP document "Technical Risks of Reverse Engineering and Unauthorized Code Modification Reverse Engineering and Code Modification Prevention" (see references below) for a list of business risks as well as associated technical threats.',1,2);
INSERT INTO "groups" VALUES (1,1,'privateGroup','2020-10-20 15:14');
INSERT INTO "checklists_kb" VALUES (1,'1.0','Architecture, Design and Threat Modeling Requirements',NULL,NULL,NULL,0,1,1);
INSERT INTO "checklists_kb" VALUES (2,'1.1.1','Verify the use of a secure software development lifecycle that addresses security in all stages of development.','https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html',2,1,0,272,1);
INSERT INTO "checklists_kb" VALUES (3,'1.1.2','Verify the use of threat modeling for every design change or sprint planning to identify threats, plan for countermeasures, facilitate appropriate risk responses, and guide security testing.','https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1053',2,1,1,1053,1);
INSERT INTO "checklists_kb" VALUES (4,'1.1.3','Verify that all user stories and features contain functional security constraints, such as "As a user, I should be able to view and edit my profile. I should not be able to view or edit anyone else\s profile','https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1110',2,1,1,1110,1);
INSERT INTO "checklists_kb" VALUES (5,'1.1.4','Verify documentation and justification of all the application\s trust boundaries, components, and significant data flows.','https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1059',2,1,0,1059,1);
INSERT INTO "checklists_kb" VALUES (6,'1.1.5','Verify definition and security analysis of the application\s high-level architecture and all connected remote services. ','https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1059',2,1,0,1059,1);
INSERT INTO "checklists_kb" VALUES (7,'1.1.6','Verify implementation of centralized, simple (economy of design) vetted, secure, and reusable security controls to avoid duplicate, missing, ineffective, or insecure controls.','https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/637',2,1,1,184,1);
INSERT INTO "checklists_kb" VALUES (8,'1.1.7','Verify availability of a secure coding checklist, security requirements, guideline, or policy to all developers and testers.','https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/637',2,1,0,637,1);
INSERT INTO "checklists_kb" VALUES (9,'1.2.1','Verify the use of unique or special low-privilege operating system accounts for all application components, services, and servers.','https://cwe.mitre.org/data/definitions/250',2,2,0,250,1);
INSERT INTO "checklists_kb" VALUES (10,'1.2.2','Verify that communications between application components, including APIs, middleware and data layers, are authenticated. Components should have the least necessary privileges needed.','https://cwe.mitre.org/data/definitions/306',2,2,0,306,1);
INSERT INTO "checklists_kb" VALUES (11,'1.2.3','Verify that the application uses a single vetted authentication mechanism that is known to be secure, can be extended to include strong authentication, and has sufficient logging and monitoring to detect account abuse or breaches.','https://cwe.mitre.org/data/definitions/306',2,2,0,306,1);
INSERT INTO "checklists_kb" VALUES (12,'1.2.4','Verify that all authentication pathways and identity management APIs implement consistent authentication security control strength, such that there are no weaker alternatives per the risk of the application.','https://cwe.mitre.org/data/definitions/306',2,2,0,306,1);
INSERT INTO "checklists_kb" VALUES (13,'1.4.1','Verify that trusted enforcement points such as at access control gateways, servers, and serverless functions enforce access controls. Never enforce access controls on the client.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/602',2,3,0,602,1);
INSERT INTO "checklists_kb" VALUES (14,'1.4.2','Verify that the chosen access control solution is flexible enough to meet the application\s needs.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/284',2,3,0,284,1);
INSERT INTO "checklists_kb" VALUES (15,'1.4.3','Verify enforcement of the principle of least privilege in functions, data files, URLs, controllers, services, and other resources. This implies protection against spoofing and elevation of privilege.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/272',2,3,0,272,1);
INSERT INTO "checklists_kb" VALUES (16,'1.4.4','Verify the application uses a single and well-vetted access control mechanism for accessing protected data and resources. All requests must pass through this single mechanism to avoid copy and paste or insecure alternative paths.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/284',2,3,0,284,1);
INSERT INTO "checklists_kb" VALUES (17,'1.4.5','Verify that attribute or feature-based access control is used whereby the code checks the user\s authorization for a feature/data item rather than just their role.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/275',2,3,0,274,1);
INSERT INTO "checklists_kb" VALUES (18,'1.5.1','Verify that input and output requirements clearly define how to handle and process data based on type, content, and applicable laws, regulations, and other policy compliance.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1029',2,4,0,20,1);
INSERT INTO "checklists_kb" VALUES (19,'1.5.2','Verify that serialization is not used when communicating with untrusted clients. If this is not possible, ensure that adequate integrity controls (and possibly encryption if sensitive data is sent) are enforced to prevent deserialization attacks including object injection.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/502',2,4,0,502,1);
INSERT INTO "checklists_kb" VALUES (20,'1.5.3','Verify that input validation is enforced on a trusted service layer.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/602',2,4,0,602,1);
INSERT INTO "checklists_kb" VALUES (21,'1.5.4','Verify that output encoding occurs close to or by the interpreter for which it is intended.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/116',2,4,0,116,1);
INSERT INTO "checklists_kb" VALUES (22,'1.6.1','Verify that there is an explicit policy for management of cryptographic keys and that a cryptographic key lifecycle follows a key management standard such as NIST SP 800-57.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/320',2,5,0,320,1);
INSERT INTO "checklists_kb" VALUES (23,'1.6.2','Verify that consumers of cryptographic services protect key material and other secrets by using key vaults or API based alternatives.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/320',2,5,1,320,1);
INSERT INTO "checklists_kb" VALUES (24,'1.6.3','Verify that all keys and passwords are replaceable and are part of a well-defined process to re-encrypt sensitive data.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/320',2,5,0,204,1);
INSERT INTO "checklists_kb" VALUES (25,'1.6.4','Verify that symmetric keys, passwords, or API secrets generated by or shared with clients are used only in protecting low risk secrets, such as encrypting local storage, or temporary ephemeral uses such as parameter obfuscation. Sharing secrets with clients is clear-text equivalent and architecturally should be treated as such.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/320',2,5,0,277,1);
INSERT INTO "checklists_kb" VALUES (26,'1.7.1','Verify that a common logging format and approach is used across the system.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1009',2,6,0,1009,1);
INSERT INTO "checklists_kb" VALUES (27,'1.7.2','Verify that logs are securely transmitted to a preferably remote system for analysis, detection, alerting, and escalation.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html',2,6,0,2,1);
INSERT INTO "checklists_kb" VALUES (28,'1.8.1','Verify that all sensitive data is identified and classified into protection levels.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html',2,7,0,278,1);
INSERT INTO "checklists_kb" VALUES (29,'1.8.2','Verify that all protection levels have an associated set of protection requirements, such as encryption requirements, integrity requirements, retention, privacy and other confidentiality requirements, and that these are applied in the architecture.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html',2,7,0,278,1);
INSERT INTO "checklists_kb" VALUES (30,'1.9.1','Verify the application encrypts communications between components, particularly when these components are in different containers, systems, sites, or cloud providers.','https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/319',2,8,0,319,1);
INSERT INTO "checklists_kb" VALUES (31,'1.9.2','Verify that application components verify the authenticity of each side in a communication link to prevent person-in-the-middle attacks. For example, application components should validate TLS certificates and chains.','https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/295',2,8,0,295,1);
INSERT INTO "checklists_kb" VALUES (32,'1.10.1','Verify that a source code control system is in use, with procedures to ensure that check-ins are accompanied by issues or change tickets. The source code control system should have access control and identifiable users to allow traceability of any changes.','https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Virtual_Patching_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/284',2,9,0,284,1);
INSERT INTO "checklists_kb" VALUES (33,'1.11.1','Verify the definition and documentation of all application components in terms of the business or security functions they provide.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1059',2,70,0,1059,1);
INSERT INTO "checklists_kb" VALUES (34,'1.11.2','Verify that all high-value business logic flows, including authentication, session management and access control, do not share unsynchronized state.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/362',2,70,0,362,1);
INSERT INTO "checklists_kb" VALUES (35,'1.11.3','Verify that all high-value business logic flows, including authentication, session management and access control are thread safe and resistant to time-of-check and time-of-use race conditions.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/362',3,70,0,362,1);
INSERT INTO "checklists_kb" VALUES (36,'1.12.1','Verify that user-uploaded files are stored outside of the web root.','https://cwe.mitre.org/data/definitions/552',2,71,0,552,1);
INSERT INTO "checklists_kb" VALUES (37,'1.12.2','Verify that user-uploaded files - if required to be displayed or downloaded from the application - are served by either octet stream downloads, or from an unrelated domain, such as a cloud file storage bucket. Implement a suitable content security policy to reduce the risk from XSS vectors or other attacks from the uploaded file.','https://cwe.mitre.org/data/definitions/646',2,71,0,646,1);
INSERT INTO "checklists_kb" VALUES (38,'1.14.1','Verify the segregation of components of differing trust levels through well-defined security controls, firewall rules, API gateways, reverse proxies, cloud-based security groups, or similar mechanisms.','https://cwe.mitre.org/data/definitions/923',2,72,0,923,1);
INSERT INTO "checklists_kb" VALUES (39,'1.14.2','Verify that if deploying binaries to untrusted devices makes use of binary signatures, trusted connections, and verified endpoints.','https://cwe.mitre.org/data/definitions/494',2,72,0,494,1);
INSERT INTO "checklists_kb" VALUES (40,'1.14.3','Verify that the build pipeline warns of out-of-date or insecure components and takes appropriate actions.','https://cwe.mitre.org/data/definitions/1104',2,72,0,1104,1);
INSERT INTO "checklists_kb" VALUES (41,'1.14.4','Verify that the build pipeline contains a build step to automatically build and verify the secure deployment of the application, particularly if the application infrastructure is software defined, such as cloud environment build scripts.','https://cwe.mitre.org/',2,72,0,281,1);
INSERT INTO "checklists_kb" VALUES (42,'1.14.5','Verify that application deployments adequately sandbox, containerize and/or isolate at the network level to delay and deter attackers from attacking other applications, especially when they are performing sensitive or dangerous actions such as deserialization.','https://cwe.mitre.org/data/definitions/265',2,72,0,265,1);
INSERT INTO "checklists_kb" VALUES (43,'1.14.6','Verify the application does not use unsupported, insecure, or deprecated client-side technologies such as NSAPI plugins, Flash, Shockwave, ActiveX, Silverlight, NACL, or client-side Java applets.','https://cwe.mitre.org/data/definitions/477',2,72,0,477,1);
INSERT INTO "checklists_kb" VALUES (44,'2.0','Authentication Verification Requirements',NULL,NULL,NULL,0,1,2);
INSERT INTO "checklists_kb" VALUES (45,'2.1.1','Verify that user set passwords are at least 12 characters in length. (C6)','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (46,'2.1.2','Verify that passwords 64 characters or longer are permitted.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (47,'2.1.3','Verify that passwords can contain spaces and truncation is not performed. Consecutive multiple spaces MAY optionally be coalesced.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (48,'2.1.4','Verify that Unicode characters are permitted in passwords. A single Unicode code point is considered a character, so 12 emoji or 64 kanji characters should be valid and permitted.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (49,'2.1.5','Verify users can change their password.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/620',1,10,0,620,2);
INSERT INTO "checklists_kb" VALUES (50,'2.1.6','Verify that password change functionality requires the user\s current and new password.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/620',1,10,0,620,2);
INSERT INTO "checklists_kb" VALUES (51,'2.1.7','Verify that passwords submitted during account registration, login, and password change are checked against a set of breached passwords either locally (such as the top 1,000 or 10,000 most common passwords which match the system\s password policy) or using an external API. If using an API a zero knowledge proof or other mechanism should be used to ensure that the plain text password is not sent or used in verifying the breach status of the password. If the password is breached, the application must require the user to set a new non-breached password.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (52,'2.1.8','Verify that a password strength meter is provided to help users set a stronger password.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (53,'2.1.9','Verify that there are no password composition rules limiting the type of characters permitted. There should be no requirement for upper or lower case or numbers or special characters.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (54,'2.1.10','Verify that there are no periodic credential rotation or password history requirements.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/263',1,10,0,263,2);
INSERT INTO "checklists_kb" VALUES (55,'2.1.11','Verify that "paste" functionality, browser password helpers, and external password managers are permitted.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (56,'2.1.12','Verify that the user can choose to either temporarily view the entire masked password, or temporarily view the last typed character of the password on platforms that do not have this as native functionality.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/521',1,10,0,521,2);
INSERT INTO "checklists_kb" VALUES (57,'2.2.1','Verify that anti-automation controls are effective at mitigating breached credential testing, brute force, and account lockout attacks. Such controls include blocking the most common breached passwords, soft lockouts, rate limiting, CAPTCHA, ever increasing delays between attempts, IP address restrictions, or risk-based restrictions such as location, first login on a device, recent attempts to unlock the account, or similar. Verify that no more than 100 failed attempts per hour is possible on a single account.','https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/307',1,11,0,307,2);
INSERT INTO "checklists_kb" VALUES (58,'2.2.2','Verify that the use of weak authenticators (such as SMS and email) is limited to secondary verification and transaction approval and not as a replacement for more secure authentication methods. Verify that stronger methods are offered before weak methods, users are aware of the risks, or that proper measures are in place to limit the risks of account compromise.','https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/304',1,11,0,304,2);
INSERT INTO "checklists_kb" VALUES (59,'2.2.3','Verify that secure notifications are sent to users after updates to authentication details, such as credential resets, email or address changes, logging in from unknown or risky locations. The use of push notifications - rather than SMS or email - is preferred, but in the absence of push notifications, SMS or email is acceptable as long as no sensitive information is disclosed in the notification.','https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/620',1,11,0,620,2);
INSERT INTO "checklists_kb" VALUES (60,'2.2.4','Verify impersonation resistance against phishing, such as the use of multi-factor authentication, cryptographic devices with intent (such as connected keys with a push to authenticate), or at higher AAL levels, client-side certificates.','https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/308',3,11,0,308,2);
INSERT INTO "checklists_kb" VALUES (61,'2.2.5','Verify that where a credential service provider (CSP) and the application verifying authentication are separated, mutually authenticated TLS is in place between the two endpoints.','https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/319',3,11,0,319,2);
INSERT INTO "checklists_kb" VALUES (62,'2.2.6','Verify replay resistance through the mandated use of OTP devices, cryptographic authenticators, or lookup codes.','https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/308',3,11,0,308,2);
INSERT INTO "checklists_kb" VALUES (63,'2.2.7','Verify intent to authenticate by requiring the entry of an OTP token or user-initiated action such as a button press on a FIDO hardware key.','https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/308',3,11,0,308,2);
INSERT INTO "checklists_kb" VALUES (64,'2.3.1','Verify system generated initial passwords or activation codes SHOULD be securely randomly generated, SHOULD be at least 6 characters long, and MAY contain letters and numbers, and expire after a short period of time. These initial secrets must not be permitted to become the long term password.','https://cwe.mitre.org/data/definitions/330',1,12,0,330,2);
INSERT INTO "checklists_kb" VALUES (65,'2.3.2','Verify that enrollment and use of subscriber-provided authentication devices are supported, such as a U2F or FIDO tokens.','https://cwe.mitre.org/data/definitions/308',2,12,0,308,2);
INSERT INTO "checklists_kb" VALUES (66,'2.3.3','Verify that renewal instructions are sent with sufficient time to renew time bound authenticators.','https://cwe.mitre.org/data/definitions/287',2,12,0,287,2);
INSERT INTO "checklists_kb" VALUES (67,'2.4.1','Verify that passwords are stored in a form that is resistant to offline attacks. Passwords SHALL be salted and hashed using an approved one- way key derivation or password hashing function. Key derivation and password hashing functions take a password, a salt, and a cost factor as inputs when generating a password hash.','https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/916',2,13,0,916,2);
INSERT INTO "checklists_kb" VALUES (68,'2.4.2','Verify that the salt is at least 32 bits in length and be chosen arbitrarily to minimize salt value collisions among stored hashes. For each credential, a unique salt value and the resulting hash SHALL be stored.','https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/916',2,13,0,916,2);
INSERT INTO "checklists_kb" VALUES (69,'2.4.3','Verify that if PBKDF2 is used, the iteration count SHOULD be as large as verification server performance will allow, typically at least 100,000 iterations.','https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/916',2,13,0,916,2);
INSERT INTO "checklists_kb" VALUES (70,'2.4.4','Verify that if bcrypt is used, the work factor SHOULD be as large as verification server performance will allow, typically at least 13','https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/916',2,13,0,916,2);
INSERT INTO "checklists_kb" VALUES (71,'2.4.5','Verify that an additional iteration of a key derivation function is performed, using a salt value that is secret and known only to the verifier. Generate the salt value using an approved random bit generator [SP 800-90Ar1] and provide at least the minimum security strength specified in the latest revision of SP 800-131A. The secret salt value SHALL be stored separately from the hashed passwords (e.g., in a specialized device like a hardware security module).','https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/916',2,13,0,916,2);
INSERT INTO "checklists_kb" VALUES (72,'2.5.1','Verify that a system generated initial activation or recovery secret is not sent in clear text to the user.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/640',1,14,0,640,2);
INSERT INTO "checklists_kb" VALUES (73,'2.5.2','Verify password hints or knowledge-based authentication (so-called "secret questions") are not present.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/640',1,14,0,640,2);
INSERT INTO "checklists_kb" VALUES (74,'2.5.3','Verify password credential recovery does not reveal the current password in any way.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/640',1,14,0,640,2);
INSERT INTO "checklists_kb" VALUES (75,'2.5.4','Verify shared or default accounts are not present (e.g. "root", "admin", or "sa").','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/16',1,14,0,276,2);
INSERT INTO "checklists_kb" VALUES (76,'2.5.5','Verify that if an authentication factor is changed or replaced, that the user is notified of this event.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/304',1,14,0,304,2);
INSERT INTO "checklists_kb" VALUES (77,'2.5.6','Verify forgotten password, and other recovery paths use a secure recovery mechanism, such as TOTP or other soft token, mobile push, or another offline recovery mechanism. ','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/640',1,14,0,640,2);
INSERT INTO "checklists_kb" VALUES (78,'2.5.7','Verify that if OTP or multi-factor authentication factors are lost, that evidence of identity proofing is performed at the same level as during enrollment.','https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/308',2,14,0,308,2);
INSERT INTO "checklists_kb" VALUES (79,'2.6.1','Verify that lookup secrets can be used only once.','https://cwe.mitre.org/data/definitions/308',2,15,0,290,2);
INSERT INTO "checklists_kb" VALUES (80,'2.6.2','Verify that lookup secrets have sufficient randomness (112 bits of entropy), or if less than 112 bits of entropy, salted with a unique and random 32-bit salt and hashed with an approved one-way hash','https://cwe.mitre.org/data/definitions/330',2,15,0,330,2);
INSERT INTO "checklists_kb" VALUES (81,'2.6.3','Verify that lookup secrets are resistant to offline attacks, such as predictable values.','https://cwe.mitre.org/data/definitions/310',2,15,0,310,2);
INSERT INTO "checklists_kb" VALUES (82,'2.7.1','Verify that clear text out of band (NIST "restricted") authenticators, such as SMS or PSTN, are not offered by default, and stronger alternatives such as push notifications are offered first.','https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/287',1,16,0,287,2);
INSERT INTO "checklists_kb" VALUES (83,'2.7.2','Verify that the out of band verifier expires out of band authentication requests, codes, or tokens after 10 minutes.','https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/287',1,16,0,287,2);
INSERT INTO "checklists_kb" VALUES (84,'2.7.3','Verify that the out of band verifier authentication requests, codes, or tokens are only usable once, and only for the original authentication request.','https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/287',1,16,0,287,2);
INSERT INTO "checklists_kb" VALUES (85,'2.7.4','Verify that the out of band authenticator and verifier communicates over a secure independent channel.','https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/523',1,16,0,523,2);
INSERT INTO "checklists_kb" VALUES (86,'2.7.5','Verify that the out of band verifier retains only a hashed version of the authentication code.','https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/256',2,16,0,256,2);
INSERT INTO "checklists_kb" VALUES (87,'2.7.6','Verify that the initial authentication code is generated by a secure random number generator, containing at least 20 bits of entropy (typically a six digital random number is sufficient).','https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/310',2,16,0,310,2);
INSERT INTO "checklists_kb" VALUES (88,'2.8.1','Verify that time-based OTPs have a defined lifetime before expiring.','https://cwe.mitre.org/data/definitions/613',1,17,0,613,2);
INSERT INTO "checklists_kb" VALUES (89,'2.8.2','Verify that symmetric keys used to verify submitted OTPs are highly protected, such as by using a hardware security module or secure operating system based key storage.','https://cwe.mitre.org/data/definitions/320',2,17,0,320,2);
INSERT INTO "checklists_kb" VALUES (90,'2.8.3','Verify that approved cryptographic algorithms are used in the generation, seeding, and verification.','https://cwe.mitre.org/data/definitions/326',2,17,0,326,2);
INSERT INTO "checklists_kb" VALUES (91,'2.8.4','Verify that time-based OTP can be used only once within the validity period.','https://cwe.mitre.org/data/definitions/287',2,17,0,287,2);
INSERT INTO "checklists_kb" VALUES (92,'2.8.5','Verify that if a time-based multi factor OTP token is re-used during the validity period, it is logged and rejected with secure notifications being sent to the holder of the device.','https://cwe.mitre.org/data/definitions/287',2,17,0,287,2);
INSERT INTO "checklists_kb" VALUES (93,'2.8.6','Verify physical single factor OTP generator can be revoked in case of theft or other loss. Ensure that revocation is immediately effective across logged in sessions, regardless of location.','https://cwe.mitre.org/data/definitions/613',2,17,0,613,2);
INSERT INTO "checklists_kb" VALUES (94,'2.8.7','Verify that biometric authenticators are limited to use only as 308 5.2.3 secondary factors in conjunction with either something you have and something you know.','https://cwe.mitre.org/data/definitions/308',3,17,0,308,2);
INSERT INTO "checklists_kb" VALUES (95,'2.9.1','Verify that cryptographic keys used in verification are stored securely and protected against disclosure, such as using a TPM or HSM, or an OS service that can use this secure storage.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/320',2,18,0,320,2);
INSERT INTO "checklists_kb" VALUES (96,'2.9.2','Verify that the challenge nonce is at least 64 bits in length, and statistically unique or unique over the lifetime of the cryptographic device.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/330',2,18,0,330,2);
INSERT INTO "checklists_kb" VALUES (97,'2.9.3','Verify that approved cryptographic algorithms are used in the generation, seeding, and verification.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/327',2,18,0,327,2);
INSERT INTO "checklists_kb" VALUES (98,'2.10.1','Verify that integration secrets do not rely on unchanging passwords, such as API keys or shared privileged accounts.','https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/287',2,19,0,287,2);
INSERT INTO "checklists_kb" VALUES (99,'2.10.2','Verify that if passwords are required, the credentials are not a default account','https://cwe.mitre.org/data/definitions/255',2,19,0,287,2);
INSERT INTO "checklists_kb" VALUES (100,'2.10.3','Verify that passwords are stored with sufficient protection to prevent offline recovery attacks, including local system access.','https://cwe.mitre.org/data/definitions/522',2,19,0,522,2);
INSERT INTO "checklists_kb" VALUES (101,'2.10.4','Verify passwords, integrations with databases and third-party systems, seeds and internal secrets, and API keys are managed securely and not included in the source code or stored within source code repositories. Such storage SHOULD resist offline attacks. The use of a secure software key store (L1), hardware trusted platform module (TPM), or a hardware security module (L3) is recommended for password storage.','https://cwe.mitre.org/data/definitions/798',2,19,0,798,2);
INSERT INTO "checklists_kb" VALUES (102,'3.0','Session Management Verification Requirements',NULL,NULL,NULL,0,1,3);
INSERT INTO "checklists_kb" VALUES (103,'3.1.1','Verify the application never reveals session tokens in URL parameters or error messages.','https://cwe.mitre.org/data/definitions/598',1,20,0,598,3);
INSERT INTO "checklists_kb" VALUES (104,'3.2.1','Verify the application generates a new session token on user authentication.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/384',1,21,0,384,3);
INSERT INTO "checklists_kb" VALUES (105,'3.2.2','Verify that session tokens possess at least 64 bits of entropy.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/311',1,21,0,311,3);
INSERT INTO "checklists_kb" VALUES (106,'3.2.3','Verify the application only stores session tokens in the browser using secure methods such as appropriately secured cookies (see section 3.4) or HTML 5 session storage.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/539',1,21,0,539,3);
INSERT INTO "checklists_kb" VALUES (107,'3.2.4','Verify that session token are generated using approved cryptographic algorithms','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/331',2,21,0,331,3);
INSERT INTO "checklists_kb" VALUES (108,'3.3.1','Verify that logout and expiration invalidate the session token, such that the back button or a downstream relying party does not resume an authenticated session, including across relying parties.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/613',1,22,0,613,3);
INSERT INTO "checklists_kb" VALUES (109,'3.3.2','If authenticators permit users to remain logged in, verify that re-authentication occurs periodically both when actively used or after an idle period.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/613',1,22,0,613,3);
INSERT INTO "checklists_kb" VALUES (110,'3.3.3','Verify that the application terminates all other active sessions after a successful password change, and that this is effective across the application, federated login (if present) and any relying parties.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/613',2,22,0,613,3);
INSERT INTO "checklists_kb" VALUES (111,'3.3.4','Verify that users are able to view and log out of any or all currently active sessions and devices.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/613',2,22,0,613,3);
INSERT INTO "checklists_kb" VALUES (112,'3.4.1','Verify that cookie-based session tokens have the \Secure\ attribute set.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/614',1,23,0,614,3);
INSERT INTO "checklists_kb" VALUES (113,'3.4.2','Verify that cookie-based session tokens have the \HttpOnly\ attribute set.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1004',1,23,0,1004,3);
INSERT INTO "checklists_kb" VALUES (114,'3.4.3','Verify that cookie-based session tokens utilize the \SameSite\ attribute to limit exposure to cross-site request forgery attacks.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/16',1,23,0,2,3);
INSERT INTO "checklists_kb" VALUES (115,'3.4.4','Verify that cookie-based session tokens use "__Host-" prefix (see references) to provide session cookie confidentiality.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/16',1,23,0,2,3);
INSERT INTO "checklists_kb" VALUES (116,'3.4.5','Verify that if the application is published under a domain name with other applications that set or use session cookies that might override or disclose the session cookies, set the path attribute in cookie-based session tokens using the most precise path possible.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/16',1,23,0,2,3);
INSERT INTO "checklists_kb" VALUES (117,'3.5.1','Verify the application does not treat OAuth and refresh tokens — on their own — as the presence of the subscriber and allows users to terminate trust relationships with linked applications.','https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/290',2,24,0,290,3);
INSERT INTO "checklists_kb" VALUES (118,'3.5.2','Verify the application uses session tokens rather than static API secrets and keys, except with legacy implementations.','https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/798',2,24,0,798,3);
INSERT INTO "checklists_kb" VALUES (119,'3.5.3','Verify that stateless session tokens use digital signatures, encryption, and other countermeasures to protect against tampering, enveloping, replay, null cipher, and key substitution attacks.','https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/345',2,24,0,345,3);
INSERT INTO "checklists_kb" VALUES (120,'3.7.1','Verify the application ensures a valid login session or requires re-authentication or secondary verification before allowing any sensitive transactions or account modifications.','https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transaction_Authorization_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/778',1,25,0,778,3);
INSERT INTO "checklists_kb" VALUES (121,'4.0','Access Control Verification Requirements',NULL,NULL,NULL,0,1,4);
INSERT INTO "checklists_kb" VALUES (122,'4.1.1','Verify that the application enforces access control rules on a trusted service layer, especially if client-side access control is present and could be bypassed.','https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Testing_Automation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/602',1,26,0,602,4);
INSERT INTO "checklists_kb" VALUES (123,'4.1.2','Verify that all user and data attributes and policy information used by access controls cannot be manipulated by end users unless specifically authorized.','https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Testing_Automation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/639',1,26,0,639,4);
INSERT INTO "checklists_kb" VALUES (124,'4.1.3','Verify that the principle of least privilege exists - users should only be able to access functions, data files, URLs, controllers, services, and other resources, for which they possess specific authorization. This implies protection against spoofing and elevation of privilege.','https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Testing_Automation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/285',1,26,0,285,4);
INSERT INTO "checklists_kb" VALUES (125,'4.1.4','Verify that the principle of deny by default exists whereby new users/roles start with minimal or no permissions and users/roles do not receive access to new features until access is explicitly assigned. ','https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Testing_Automation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/276',1,26,0,276,4);
INSERT INTO "checklists_kb" VALUES (126,'4.1.5','Verify that access controls fail securely including when an exception occurs.','https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Testing_Automation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/285',1,26,0,285,4);
INSERT INTO "checklists_kb" VALUES (127,'4.2.1','Verify that sensitive data and APIs are protected against direct object attacks targeting creation, reading, updating and deletion of records, such as creating or updating someone else\s record, viewing everyone\s records, or deleting all records.','https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Testing_Automation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/639',1,27,0,639,4);
INSERT INTO "checklists_kb" VALUES (128,'4.2.2','Verify that the application or framework enforces a strong anti-CSRF mechanism to protect authenticated functionality, and effective anti-automation or anti-CSRF protects unauthenticated functionality.','https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Testing_Automation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/352',1,27,0,352,4);
INSERT INTO "checklists_kb" VALUES (129,'4.3.1','Verify administrative interfaces use appropriate multi-factor authentication to prevent unauthorized use.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/419',1,28,0,419,4);
INSERT INTO "checklists_kb" VALUES (130,'4.3.2','Verify that directory browsing is disabled unless deliberately desired. Additionally, applications should not allow discovery or disclosure of file or directory metadata, such as Thumbs.db, .DS_Store, .git or .svn folders.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/548',1,28,0,548,4);
INSERT INTO "checklists_kb" VALUES (131,'4.3.3','Verify the application has additional authorization (such as step up or adaptive authentication) for lower value systems, and / or segregation of duties for high value applications to enforce anti-fraud controls as per the risk of application and past fraud.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/732',1,28,0,732,4);
INSERT INTO "checklists_kb" VALUES (132,'5.0','Validation, Sanitization and Encoding Verification Requirements',NULL,NULL,NULL,0,1,5);
INSERT INTO "checklists_kb" VALUES (133,'5.1.1','Verify that the application has defenses against HTTP parameter pollution attacks, particularly if the application framework makes no distinction about the source of request parameters (GET, POST, cookies, headers, or environment variables).','https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/235',1,29,0,235,5);
INSERT INTO "checklists_kb" VALUES (134,'5.1.2','Verify that frameworks protect against mass parameter assignment attacks, or that the application has countermeasures to protect against unsafe parameter assignment, such as marking fields private or similar.','https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/915',1,29,0,915,5);
INSERT INTO "checklists_kb" VALUES (135,'5.1.3','Verify that all input (HTML form fields, REST requests, URL parameters, HTTP headers, cookies, batch files, RSS feeds, etc) is validated using positive validation (whitelisting)','https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/20',1,29,0,20,5);
INSERT INTO "checklists_kb" VALUES (136,'5.1.4','Verify that structured data is strongly typed and validated against a defined schema including allowed characters, length and pattern (e.g. credit card numbers or telephone, or validating that two related fields are reasonable, such as checking that suburb and zip/postcode match).','https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/20',1,29,0,20,5);
INSERT INTO "checklists_kb" VALUES (137,'5.1.5','Verify that URL redirects and forwards only allow whitelisted destinations, or show a warning when redirecting to potentially untrusted content.','https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/601',1,29,0,601,5);
INSERT INTO "checklists_kb" VALUES (138,'5.2.1','Verify that all untrusted HTML input from WYSIWYG editors or similar is properly sanitized with an HTML sanitizer library or framework feature.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/116',1,30,0,116,5);
INSERT INTO "checklists_kb" VALUES (139,'5.2.2','Verify that unstructured data is sanitized to enforce safety measures such as allowed characters and length.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/138',1,30,0,138,5);
INSERT INTO "checklists_kb" VALUES (140,'5.2.3','Verify that the application sanitizes user input before passing to mail systems to protect against SMTP or IMAP injection.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/147',1,30,0,147,5);
INSERT INTO "checklists_kb" VALUES (141,'5.2.4','Verify that the application avoids the use of eval() or other dynamic code execution features. Where there is no alternative, any user input being included must be sanitized or sandboxed before being executed.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/95',1,30,0,95,5);
INSERT INTO "checklists_kb" VALUES (142,'5.2.5','Verify that the application protects against template injection attacks by ensuring that any user input being included is sanitized or sandboxed.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/94',1,30,0,94,5);
INSERT INTO "checklists_kb" VALUES (143,'5.2.6','Verify that the application protects against SSRF attacks, by validating or sanitizing untrusted data or HTTP file metadata, such as filenames and URL input fields, use whitelisting of protocols, domains, paths and ports.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/918',1,30,0,918,5);
INSERT INTO "checklists_kb" VALUES (144,'5.2.7','Verify that the application sanitizes, disables, or sandboxes user-supplied SVG scriptable content, especially as they relate to XSS resulting from inline scripts, and foreignObject.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/159',1,30,0,159,5);
INSERT INTO "checklists_kb" VALUES (145,'5.2.8','Verify that the application sanitizes, disables, or sandboxes user-supplied scriptable or expression template language content, such as Markdown, CSS or XSL stylesheets, BBCode, or similar.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/94',1,30,0,94,5);
INSERT INTO "checklists_kb" VALUES (146,'5.3.1','Verify that output encoding is relevant for the interpreter and context required. For example, use encoders specifically for HTML values, HTML attributes, JavaScript, URL Parameters, HTTP headers, SMTP, and others as the context requires, especially from untrusted inputs (e.g. names with Unicode or apostrophes, such as bla or OHara).','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/116',1,31,0,116,5);
INSERT INTO "checklists_kb" VALUES (147,'5.3.2','Verify that output encoding preserves the user\s chosen character set and locale, such that any Unicode character point is valid and safely handled.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/176',1,31,0,176,5);
INSERT INTO "checklists_kb" VALUES (148,'5.3.3','Verify that context-aware, preferably automated - or at worst, manual - output escaping protects against reflected, stored, and DOM based XSS.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/79',1,31,0,79,5);
INSERT INTO "checklists_kb" VALUES (149,'5.3.4','Verify that data selection or database queries (e.g. SQL, HQL, ORM, NoSQL) use parameterized queries, ORMs, entity frameworks, or are otherwise protected from database injection attacks.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/89',1,33,0,89,5);
INSERT INTO "checklists_kb" VALUES (150,'5.3.5','Verify that where parameterized or safer mechanisms are not present, context-specific output encoding is used to protect against injection attacks, such as the use of SQL escaping to protect against SQL injection.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/89',1,33,0,89,5);
INSERT INTO "checklists_kb" VALUES (151,'5.3.6','Verify that the application projects against JavaScript or JSON injection attacks, including for eval attacks, remote JavaScript includes, CSP bypasses, DOM XSS, and JavaScript expression evaluation.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/830',1,31,0,830,5);
INSERT INTO "checklists_kb" VALUES (152,'5.3.7','Verify that the application protects against LDAP Injection vulnerabilities, or that specific security controls to prevent LDAP Injection have been implemented.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/943',1,34,0,943,5);
INSERT INTO "checklists_kb" VALUES (153,'5.3.8','Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/78',1,35,0,78,5);
INSERT INTO "checklists_kb" VALUES (154,'5.3.9','Verify that the application protects against Local File Inclusion (LFI) or Remote File Inclusion (RFI) attacks.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/829',1,32,0,829,5);
INSERT INTO "checklists_kb" VALUES (155,'5.3.10','Verify that the application protects against XPath injection or XML injection attacks.','https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_in_Java_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/643',1,36,0,643,5);
INSERT INTO "checklists_kb" VALUES (156,'5.5.1','Verify that serialized objects use integrity checks or are encrypted to prevent hostile object creation or data tampering.','https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/502',1,37,0,502,5);
INSERT INTO "checklists_kb" VALUES (157,'5.5.2','Verify that the application correctly restricts XML parsers to only use the most restrictive configuration possible and to ensure that unsafe features such as resolving external entities are disabled to prevent XXE.','https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/611',1,37,0,611,5);
INSERT INTO "checklists_kb" VALUES (158,'5.5.3','Verify that deserialization of untrusted data is avoided or is protected in both custom code and third-party libraries (such as JSON, XML and YAML parsers).','https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/502',1,37,0,502,5);
INSERT INTO "checklists_kb" VALUES (159,'5.5.4','Verify that when parsing JSON in browsers or JavaScript-based backends, JSON.parse is used to parse the JSON document. Do not use eval() to parse JSON.','https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/95',1,37,0,95,5);
INSERT INTO "checklists_kb" VALUES (160,'6.0','Stored Cryptography Verification Requirements',NULL,NULL,NULL,0,1,6);
INSERT INTO "checklists_kb" VALUES (161,'6.1.1','Verify that regulated private data is stored encrypted while at rest, such as personally identifiable information (PII), sensitive personal information, or data assessed likely to be subject to EUs GDPR.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/311',2,38,0,311,6);
INSERT INTO "checklists_kb" VALUES (162,'6.1.2','Verify that regulated health data is stored encrypted while at rest, such as medical records, medical device details, or de-anonymized research records.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/311',2,38,0,311,6);
INSERT INTO "checklists_kb" VALUES (163,'6.1.3','Verify that regulated financial data is stored encrypted while at rest, such as financial accounts, defaults or credit history, tax records, pay history, beneficiaries, or de-anonymized market or research records.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/311',2,38,0,311,6);
INSERT INTO "checklists_kb" VALUES (164,'6.2.1','Verify that all cryptographic modules fail securely, and errors are handled in a way that does not enable Padding Oracle attacks.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/310',1,39,0,310,6);
INSERT INTO "checklists_kb" VALUES (165,'6.2.2','Verify that industry proven or government approved cryptographic algorithms, modes, and libraries are used, instead of custom coded cryptography.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/327',2,39,0,327,6);
INSERT INTO "checklists_kb" VALUES (166,'6.2.3','Verify that encryption initialization vector, cipher configuration, and block modes are configured securely using the latest advice.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',2,39,0,326,6);
INSERT INTO "checklists_kb" VALUES (167,'6.2.4','Verify that random number, encryption or hashing algorithms, key lengths, rounds, ciphers or modes, can be reconfigured, upgraded, or swapped at any time, to protect against cryptographic breaks.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',2,39,0,326,6);
INSERT INTO "checklists_kb" VALUES (168,'6.2.5','Verify that known insecure block modes (i.e. ECB, etc.), padding modes (i.e. PKCS#1 v1.5, etc.), ciphers with small block sizes (i.e. Triple-DES, Blowfish, etc.), and weak hashing algorithms (i.e. MD5, SHA1, etc.) are not used unless required for backwards compatibility.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',2,39,0,326,6);
INSERT INTO "checklists_kb" VALUES (169,'6.2.6','Verify that nonces, initialization vectors, and other single use numbers must not be used more than once with a given encryption key. The method of generation must be appropriate for the algorithm being used.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',2,39,0,326,6);
INSERT INTO "checklists_kb" VALUES (170,'6.2.7','Verify that encrypted data is authenticated via signatures, authenticated cipher modes, or HMAC to ensure that ciphertext is not altered by an unauthorized party.','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',3,39,0,326,6);
INSERT INTO "checklists_kb" VALUES (171,'6.2.8','Verify that all cryptographic operations are constant-time, with no short-circuit operations in comparisons, calculations, or returns, to avoid leaking information','https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',3,39,0,326,6);
INSERT INTO "checklists_kb" VALUES (172,'6.3.1','Verify that all random numbers, random file names, random GUIDs, and random strings are generated using the cryptographic modules approved cryptographically secure random number generator when these random values are intended to be not guessable by an attacker.','https://cwe.mitre.org/data/definitions/338',2,40,0,338,6);
INSERT INTO "checklists_kb" VALUES (173,'6.3.2','Verify that random GUIDs are created using the GUID v4 algorithm, and a cryptographically-secure pseudo-random number generator (CSPRNG). GUIDs created using other pseudo-random number generators may be predictable.','https://cwe.mitre.org/data/definitions/338',2,40,0,338,6);
INSERT INTO "checklists_kb" VALUES (174,'6.3.3','Verify that random numbers are created with proper entropy even when the application is under heavy load, or that the application degrades gracefully in such circumstances.','https://cwe.mitre.org/data/definitions/338',3,40,0,338,6);
INSERT INTO "checklists_kb" VALUES (175,'6.4.1','Verify that a secrets management solution such as a key vault is used to securely create, store, control access to and destroy secrets.','https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/798',2,41,0,798,6);
INSERT INTO "checklists_kb" VALUES (176,'6.4.2','Verify that key material is not exposed to the application but instead uses an isolated security module like a vault for cryptographic operations.','https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/320',2,41,0,320,6);
INSERT INTO "checklists_kb" VALUES (177,'7.0','Error Handling and Logging Verification Requirements',NULL,NULL,NULL,0,1,7);
INSERT INTO "checklists_kb" VALUES (178,'7.1.1','Verify that the application does not log credentials or payment details. Session tokens should only be stored in logs in an irreversible, hashed form.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/532',1,42,0,532,7);
INSERT INTO "checklists_kb" VALUES (179,'7.1.2','Verify that the application does not log other sensitive data as defined under local privacy laws or relevant security policy.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/532',1,42,0,532,7);
INSERT INTO "checklists_kb" VALUES (180,'7.1.3','Verify that the application logs security relevant events including successful and failed authentication events, access control failures, deserialization failures and input validation failures.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/778',2,42,0,778,7);
INSERT INTO "checklists_kb" VALUES (181,'7.1.4','Verify that each log event includes necessary information that would allow for a detailed investigation of the timeline when an event happens','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/778',2,42,0,778,7);
INSERT INTO "checklists_kb" VALUES (182,'7.2.1','Verify that all authentication decisions are logged, without storing sensitive session identifiers or passwords. This should include requests with relevant metadata needed for security investigations.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/778',2,43,0,778,7);
INSERT INTO "checklists_kb" VALUES (183,'7.2.2','Verify that all access control decisions can be logged and all failed decisions are logged. This should include requests with relevant metadata needed for security investigations.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/285',2,43,0,285,7);
INSERT INTO "checklists_kb" VALUES (184,'7.3.1','Verify that the application appropriately encodes user-supplied data to prevent log injection','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/117',2,44,0,117,7);
INSERT INTO "checklists_kb" VALUES (185,'7.3.2','Verify that all events are protected from injection when viewed in log viewing software','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/117',2,44,0,117,7);
INSERT INTO "checklists_kb" VALUES (186,'7.3.3','Verify that security logs are protected from unauthorized access and modification.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/200',2,44,0,200,7);
INSERT INTO "checklists_kb" VALUES (187,'7.3.4','Verify that time sources are synchronized to the correct time and time zone. Strongly consider logging only in UTC if systems are global to assist with post- incident forensic analysis.','https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html',2,44,0,2,7);
INSERT INTO "checklists_kb" VALUES (188,'7.4.1','Verify that a generic message is shown when an unexpected or security sensitive error occurs, potentially with a unique ID which support personnel can use to investigate.','https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/210',1,45,0,210,7);
INSERT INTO "checklists_kb" VALUES (189,'7.4.2','Verify that exception handling (or a functional equivalent) is used across the codebase to account for expected and unexpected error conditions.','https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/544',2,45,0,544,7);
INSERT INTO "checklists_kb" VALUES (190,'7.4.3','Verify that a last resort error handler is defined which will catch all unhandled exceptions','https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/460',2,45,0,460,7);
INSERT INTO "checklists_kb" VALUES (191,'8.0','Error Handling and Logging Verification Requirements',NULL,NULL,NULL,0,1,8);
INSERT INTO "checklists_kb" VALUES (192,'8.1.1','Verify the application protects sensitive data from being cached in server components such as load balancers and application caches.','https://cwe.mitre.org/data/definitions/532',2,46,0,532,8);
INSERT INTO "checklists_kb" VALUES (193,'8.1.2','Verify that all cached or temporary copies of sensitive data stored on the server are protected from unauthorized access or purged/invalidated after the authorized user accesses the sensitive data.','https://cwe.mitre.org/data/definitions/524',2,19,0,524,8);
INSERT INTO "checklists_kb" VALUES (194,'8.1.3','Verify the application minimizes the number of parameters in a request, such as hidden fields, Ajax variables, cookies and header values.','https://cwe.mitre.org/data/definitions/233',2,46,0,233,8);
INSERT INTO "checklists_kb" VALUES (195,'8.1.4','Verify the application can detect and alert on abnormal numbers of requests, such as by IP, user, total per hour or day, or whatever makes sense for the application.','https://cwe.mitre.org/data/definitions/525',2,46,0,525,8);
INSERT INTO "checklists_kb" VALUES (196,'8.1.5','Verify that regular backups of important data are performed and that test restoration of data is performed.','https://cwe.mitre.org/data/definitions/770',3,46,0,770,8);
INSERT INTO "checklists_kb" VALUES (197,'8.1.6','Verify that backups are stored securely to prevent data from being stolen or corrupted.','https://cwe.mitre.org/data/definitions/19',3,46,0,300,8);
INSERT INTO "checklists_kb" VALUES (198,'8.2.1','Verify the application sets sufficient anti-caching headers so that sensitive data is not cached in modern browsers.','https://cwe.mitre.org/data/definitions/525',1,25,0,525,8);
INSERT INTO "checklists_kb" VALUES (199,'8.2.2','Verify that data stored in client side storage (such as HTML5 local storage, session storage, IndexedDB, regular cookies or Flash cookies) does not contain sensitive data or PII.','https://cwe.mitre.org/data/definitions/922',1,47,0,922,8);
INSERT INTO "checklists_kb" VALUES (200,'8.2.3','Verify that authenticated data is cleared from client storage, such as the browser DOM, after the client or session is terminated.','https://cwe.mitre.org/data/definitions/922',1,47,0,922,8);
INSERT INTO "checklists_kb" VALUES (201,'8.3.1','Verify that sensitive data is sent to the server in the HTTP message body or headers, and that query string parameters from any HTTP verb do not contain sensitive data.','https://cwe.mitre.org/data/definitions/319',1,48,0,319,8);
INSERT INTO "checklists_kb" VALUES (202,'8.3.2','Verify that users have a method to remove or export their data on demand.','https://cwe.mitre.org/data/definitions/212',1,48,0,212,8);
INSERT INTO "checklists_kb" VALUES (203,'8.3.3','Verify that users are provided clear language regarding collection and use of supplied personal information and that users have provided opt-in consent for the use of that data before it is used in any way.','https://cwe.mitre.org/data/definitions/285',1,48,0,285,8);
INSERT INTO "checklists_kb" VALUES (204,'8.3.4','Verify that all sensitive data created and processed by the application has been identified, and ensure that a policy is in place on how to deal with sensitive data.','https://cwe.mitre.org/data/definitions/200',1,48,0,200,8);
INSERT INTO "checklists_kb" VALUES (205,'8.3.5','Verify accessing sensitive data is audited (without logging the sensitive data itself), if the data is collected under relevant data protection directives or where logging of access is required.','https://cwe.mitre.org/data/definitions/532',2,48,0,532,8);
INSERT INTO "checklists_kb" VALUES (206,'8.3.6','Verify that sensitive information contained in memory is overwritten as soon as it is no longer required to mitigate memory dumping attacks, using zeroes or random data.','https://cwe.mitre.org/data/definitions/226',2,48,0,226,8);
INSERT INTO "checklists_kb" VALUES (207,'8.3.7','Verify that sensitive or private information that is required to be encrypted, is encrypted using approved algorithms that provide both confidentiality and integrity','https://cwe.mitre.org/data/definitions/525',2,48,0,525,8);
INSERT INTO "checklists_kb" VALUES (208,'8.3.8','Verify that sensitive personal information is subject to data retention classification, such that old or out of date data is deleted automatically, on a schedule, or as the situation requires.','https://cwe.mitre.org/data/definitions/285',2,48,0,285,8);
INSERT INTO "checklists_kb" VALUES (209,'9.0','Communications Verification Requirements',NULL,NULL,NULL,0,1,9);
INSERT INTO "checklists_kb" VALUES (210,'9.1.1','Verify that secured TLS is used for all client connectivity, and does not fall back to insecure or unencrypted protocols.','https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/319',1,49,0,319,9);
INSERT INTO "checklists_kb" VALUES (211,'9.1.2','Verify using online or up to date TLS testing tools that only strong algorithms, ciphers, and protocols are enabled, with the strongest algorithms and ciphers set as preferred.','https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',1,49,0,326,9);
INSERT INTO "checklists_kb" VALUES (212,'9.1.3','Verify that old versions of SSL and TLS protocols, algorithms, ciphers, and configuration are disabled, such as SSLv2, SSLv3, or TLS 1.0 and TLS 1.1. The latest version of TLS should be the preferred cipher suite.','https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/326',1,49,0,326,9);
INSERT INTO "checklists_kb" VALUES (213,'9.2.1','Verify that connections to and from the server use trusted TLS certificates. Where internally generated or self-signed certificates are used, the server must be configured to only trust specific internal CAs and specific self-signed certificates. All others should be rejected.','https://cwe.mitre.org/data/definitions/295',2,50,0,295,9);
INSERT INTO "checklists_kb" VALUES (214,'9.2.2','Verify that encrypted communications such as TLS is used for all inbound and outbound connections, including for management ports, monitoring, authentication, API, or web service calls, database, cloud, serverless, mainframe, external, and partner connections. The server must not fall back to insecure or unencrypted protocols.','https://cwe.mitre.org/data/definitions/319',2,50,0,319,9);
INSERT INTO "checklists_kb" VALUES (215,'9.2.3','Verify that all encrypted connections to external systems that involve sensitive information or functions are authenticated.','https://cwe.mitre.org/data/definitions/297',2,50,0,297,9);
INSERT INTO "checklists_kb" VALUES (216,'9.2.4','Verify that proper certification revocation, such as Online Certificate Status Protocol (OCSP) Stapling, is enabled and configured.','https://cwe.mitre.org/data/definitions/299',2,50,0,299,9);
INSERT INTO "checklists_kb" VALUES (217,'9.2.5','Verify that backend TLS connection failures are logged','https://cwe.mitre.org/data/definitions/544',3,50,0,544,9);
INSERT INTO "checklists_kb" VALUES (218,'10.0','Malicious Code Verification Requirements',NULL,NULL,NULL,0,1,10);
INSERT INTO "checklists_kb" VALUES (219,'10.1.1','Verify that a code analysis tool is in use that can detect potentially malicious code, such as time functions, unsafe file operations and network connections.','https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/749',3,51,0,749,10);
INSERT INTO "checklists_kb" VALUES (220,'10.2.1','Verify that the application source code and third party libraries do not contain unauthorized phone home or data collection capabilities. Where such functionality exists, obtain the users permission for it to operate before collecting any data.','https://cwe.mitre.org/data/definitions/359',2,52,0,359,10);
INSERT INTO "checklists_kb" VALUES (221,'10.2.2','Verify that the application does not ask for unnecessary or excessive permissions to privacy related features or sensors, such as contacts, cameras, microphones, or location.','https://cwe.mitre.org/data/definitions/272',2,52,0,272,10);
INSERT INTO "checklists_kb" VALUES (222,'10.2.3','Verify that the application source code and third party libraries do not contain back doors, such as hard-coded or additional undocumented accounts or keys, code obfuscation, undocumented binary blobs, rootkits, or anti-debugging, insecure debugging features, or otherwise out of date, insecure, or hidden functionality that could be used maliciously if discovered.','https://cwe.mitre.org/data/definitions/507',3,52,0,507,10);
INSERT INTO "checklists_kb" VALUES (223,'10.2.4','Verify that the application source code and third party libraries does not contain time bombs by searching for date and time related functions.','https://cwe.mitre.org/data/definitions/511',3,52,0,511,10);
INSERT INTO "checklists_kb" VALUES (224,'10.2.5','Verify that the application source code and third party libraries does not contain malicious code, such as salami attacks, logic bypasses, or logic bombs.','https://cwe.mitre.org/data/definitions/511',3,52,0,511,10);
INSERT INTO "checklists_kb" VALUES (225,'10.2.6','Verify that the application source code and third party libraries do not contain Easter eggs or any other potentially unwanted functionality.','https://cwe.mitre.org/data/definitions/507',3,52,0,507,10);
INSERT INTO "checklists_kb" VALUES (226,'10.3.1','Verify that if the application has a client or server auto-update feature, updates should be obtained over secure channels and digitally signed. The update code must validate the digital signature of the update before installing or executing the update.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/16',1,53,0,2,10);
INSERT INTO "checklists_kb" VALUES (227,'10.3.2','Verify that the application employs integrity protections, such as code signing or sub-resource integrity. The application must not load or execute code from untrusted sources, such as loading includes, modules, plugins, code, or libraries from untrusted sources or the Internet.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/353',1,53,0,353,10);
INSERT INTO "checklists_kb" VALUES (228,'10.3.3','Verify that the application has protection from sub-domain takeovers if the application relies upon DNS entries or DNS sub-domains, such as expired domain names, out of date DNS pointers or CNAMEs, expired projects at public source code repos, or transient cloud APIs, serverless functions, or storage buckets (autogen-bucket-id.cloud.example.com) or similar. Protections can include ensuring that DNS names used by applications are regularly checked for expiry or change.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/350',1,53,0,350,10);
INSERT INTO "checklists_kb" VALUES (229,'11.0','Business Logic Verification Requirements',NULL,NULL,NULL,0,1,11);
INSERT INTO "checklists_kb" VALUES (230,'11.1.1','Verify the application will only process business logic flows for the same user in sequential step order and without skipping steps.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/841',1,54,0,841,11);
INSERT INTO "checklists_kb" VALUES (231,'11.1.2','Verify the application will only process business logic flows with all steps being processed in realistic human time, i.e. transactions are not submitted too quickly.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/779',1,54,0,779,11);
INSERT INTO "checklists_kb" VALUES (232,'11.1.3','Verify the application has appropriate limits for specific business actions or transactions which are correctly enforced on a per user basis.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/770',1,54,0,770,11);
INSERT INTO "checklists_kb" VALUES (233,'11.1.4','Verify the application has sufficient anti-automation controls to detect and protect against data exfiltration, excessive business logic requests, excessive file uploads or denial of service attacks.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/770',1,54,0,770,11);
INSERT INTO "checklists_kb" VALUES (234,'11.1.5','Verify the application has business logic limits or validation to protect against likely business risks or threats, identified using threat modelling or similar methodologies.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/841',1,54,1,841,11);
INSERT INTO "checklists_kb" VALUES (235,'11.1.6','Verify the application does not suffer from "time of check to time of use" (TOCTOU) issues or other race conditions for sensitive operations.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/367',2,54,1,367,11);
INSERT INTO "checklists_kb" VALUES (236,'11.1.7','Verify the application monitors for unusual events or activity from a business logic perspective. For example, attempts to perform actions out of order or actions which a normal user would never attempt','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/754',2,54,1,754,11);
INSERT INTO "checklists_kb" VALUES (237,'11.1.8','Verify the application has configurable alerting when automated attacks or unusual activity is detected.','https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/390',2,54,0,390,11);
INSERT INTO "checklists_kb" VALUES (238,'12.0','File and Resources Verification Requirements',NULL,NULL,NULL,0,1,12);
INSERT INTO "checklists_kb" VALUES (239,'12.1.1','Verify that the application will not accept large files that could fill up storage or cause a denial of service attack.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/400',1,55,0,400,12);
INSERT INTO "checklists_kb" VALUES (240,'12.1.2','Verify that compressed files are checked for "zip bombs" - small input files that will decompress into huge files thus exhausting file storage limits.','https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/400',2,55,0,400,12);
INSERT INTO "checklists_kb" VALUES (241,'12.1.3','Verify that a file size quota and maximum number of files per user is enforced to ensure that a single user cannot fill up the storage with too many files, or excessively large files.','https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/409',2,55,0,409,12);
INSERT INTO "checklists_kb" VALUES (242,'12.2.1','Verify that files obtained from untrusted sources are validated to be of expected type based on the files content.','https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/434',2,56,0,434,12);
INSERT INTO "checklists_kb" VALUES (243,'12.3.1','Verify that user-submitted filename metadata is not used directly with system or framework file and URL API to protect against path traversal.','https://cwe.mitre.org/data/definitions/22',1,57,0,22,12);
INSERT INTO "checklists_kb" VALUES (244,'12.3.2','Verify that user-submitted filename metadata is validated or ignored to prevent the disclosure, creation, updating or removal of local files (LFI).','https://cwe.mitre.org/data/definitions/73',1,57,0,73,12);
INSERT INTO "checklists_kb" VALUES (245,'12.3.3','Verify that user-submitted filename metadata is validated or ignored to prevent the disclosure or execution of remote files (RFI) which may also lead to SSRF.','https://cwe.mitre.org/data/definitions/98',1,57,0,98,12);
INSERT INTO "checklists_kb" VALUES (246,'12.3.4','Verify that the application protects against reflective file download (RFD) by validating or ignoring user-submitted filenames in a JSON, JSONP, or URL parameter, the response Content-Type header should be set to text/plain, and the Content-Disposition header should have a fixed filename.','https://cwe.mitre.org/data/definitions/641',1,57,0,641,12);
INSERT INTO "checklists_kb" VALUES (247,'12.3.5','Verify that untrusted file metadata is not used directly with system API or libraries, to protect against OS command injection.','https://cwe.mitre.org/data/definitions/78',1,57,0,78,12);
INSERT INTO "checklists_kb" VALUES (248,'12.3.6','Verify that the application does not include and execute functionality from untrusted sources, such as unverified content distribution networks, JavaScript libraries, node npm libraries, or server-side DLLs.','https://cwe.mitre.org/data/definitions/829',2,57,0,829,12);
INSERT INTO "checklists_kb" VALUES (249,'12.4.1','Verify that files obtained from untrusted sources are stored outside the web root, with limited permissions, preferably with strong validation.','https://cwe.mitre.org/data/definitions/922',1,58,0,922,12);
INSERT INTO "checklists_kb" VALUES (250,'12.4.2','Verify that files obtained from untrusted sources are scanned by antivirus scanners to prevent upload of known malicious content.','https://cwe.mitre.org/data/definitions/509',1,58,0,509,12);
INSERT INTO "checklists_kb" VALUES (251,'12.5.1','Verify that the web tier is configured to serve only files with specific file extensions to prevent unintentional information and source code leakage. For example, backup files (e.g. .bak) temporary working files (e.g. .swp) compressed files (.zip, .tar.gz, etc) and other extensions commonly used by editors should be blocked unless required.','https://cwe.mitre.org/data/definitions/552',1,59,0,552,12);
INSERT INTO "checklists_kb" VALUES (252,'12.5.2','Verify that direct requests to uploaded files will never be executed as HTML/JavaScript content.','https://cwe.mitre.org/data/definitions/434',1,59,0,434,12);
INSERT INTO "checklists_kb" VALUES (253,'12.6.1','Verify that the web or application server is configured with a whitelist of resources or systems to which the server can send requests or load data/files from.','https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/918',1,60,0,918,12);
INSERT INTO "checklists_kb" VALUES (254,'13.0','API and Web Service Verification Requirements',NULL,NULL,NULL,0,1,13);
INSERT INTO "checklists_kb" VALUES (255,'13.1.1','Verify that all application components use the same encodings and parsers to avoid parsing attacks that exploit different URI or file parsing behavior that could be used in SSRF and RFI attacks.','https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/116',1,61,0,116,13);
INSERT INTO "checklists_kb" VALUES (256,'13.1.2','Verify that access to administration and management functions is limited to authorized administrators.','https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/419',1,61,0,419,13);
INSERT INTO "checklists_kb" VALUES (257,'13.1.3','Verify API URLs do not expose sensitive information, such as the API key, session tokens etc.','https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/598',1,61,0,598,13);
INSERT INTO "checklists_kb" VALUES (258,'13.1.4','Verify that authorization decisions are made at both the URI, enforced by programmatic or declarative security at the controller or router, and at the resource level, enforced by model-based permissions.','https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/285',2,61,0,285,13);
INSERT INTO "checklists_kb" VALUES (259,'13.1.5','Verify that requests containing unexpected or missing content types are rejected with appropriate headers (HTTP response status 406 Unacceptable or 415 Unsupported Media Type).','https://cheatsheetseries.owasp.org/cheatsheets/Web_Service_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/434',2,61,0,434,13);
INSERT INTO "checklists_kb" VALUES (260,'13.2.1','Verify that enabled RESTful HTTP methods are a valid choice for the user or action, such as preventing normal users using DELETE or PUT on protected API or resources.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/650',1,62,0,650,13);
INSERT INTO "checklists_kb" VALUES (261,'13.2.2','Verify that JSON schema validation is in place and verified before accepting input.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/20',1,62,0,20,13);
INSERT INTO "checklists_kb" VALUES (262,'13.2.3','Verify that RESTful web services that utilize cookies are protected from Cross-Site Request Forgery via the use of at least one or more of the following: triple or double submit cookie pattern, CSRF nonces, or ORIGIN request header checks.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/352',1,62,0,352,13);
INSERT INTO "checklists_kb" VALUES (263,'13.2.4','Verify that REST services have anti-automation controls to protect against excessive calls, especially if the API is unauthenticated.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/779',2,62,0,779,13);
INSERT INTO "checklists_kb" VALUES (264,'13.2.5','Verify that REST services explicitly check the incoming Content-Type to be the expected one, such as application/xml or application/JSON.','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/436',2,62,0,436,13);
INSERT INTO "checklists_kb" VALUES (265,'13.2.6','Verify that the message headers and payload are trustworthy and not modified in transit. Requiring strong encryption for transport (TLS only) may be sufficient in many cases as it provides both confidentiality and integrity protection. Per- message digital signatures can provide additional assurance on top of the transport protections for high-security applications but bring with them additional complexity and risks to weigh against the benefits','https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/598',2,62,0,598,13);
INSERT INTO "checklists_kb" VALUES (266,'13.3.1','Verify that XSD schema validation takes place to ensure a properly formed XML document, followed by validation of each input field before any processing of that data takes place.','https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/20',1,63,0,20,13);
INSERT INTO "checklists_kb" VALUES (267,'13.3.2','Verify that the message payload is signed using WS-Security to ensure reliable transport between client and service.','https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/345',2,63,0,345,13);
INSERT INTO "checklists_kb" VALUES (268,'13.4.1','Verify that query whitelisting or a combination of depth limiting and amount limiting should be used to prevent GraphQL or data layer expression denial of service (DoS) as a result of expensive, nested queries. For more advanced scenarios, query cost analysis should be used.','https://cwe.mitre.org/data/definitions/770',2,64,0,770,13);
INSERT INTO "checklists_kb" VALUES (269,'13.4.2','Verify that GraphQL or other data layer authorization logic should be implemented at the business logic layer instead of the GraphQL layer.','https://cwe.mitre.org/data/definitions/285',2,64,0,285,13);
INSERT INTO "checklists_kb" VALUES (270,'14.0','Configuration Verification Requirements',NULL,NULL,NULL,0,1,14);
INSERT INTO "checklists_kb" VALUES (271,'14.1.1','Verify that the application build and deployment processes are performed in a secure and repeatable way, such as CI / CD automation, automated configuration management, and automated deployment scripts','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html',2,65,0,2,14);
INSERT INTO "checklists_kb" VALUES (272,'14.1.2','Verify that compiler flags are configured to enable all available buffer overflow protections and warnings, including stack randomization, data execution prevention, and to break the build if an unsafe pointer, memory, format string, integer, or string operations are found.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/120',2,65,0,120,14);
INSERT INTO "checklists_kb" VALUES (273,'14.1.3','Verify that server configuration is hardened as per the recommendations of the application server and frameworks in use.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/16',2,65,0,2,14);
INSERT INTO "checklists_kb" VALUES (274,'14.1.4','Verify that the application, configuration, and all dependencies can be re- deployed using automated deployment scripts, built from a documented and tested runbook in a reasonable time, or restored from backups in a timely fashion.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html',2,65,0,2,14);
INSERT INTO "checklists_kb" VALUES (275,'14.1.5','Verify that authorized administrators can verify the integrity of all security-relevant configurations to detect tampering.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html',3,65,0,2,14);
INSERT INTO "checklists_kb" VALUES (276,'14.2.1','Verify that all components are up to date, preferably using a dependency checker during build or compile time.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Vulnerable_Dependency_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1104',1,65,0,1104,14);
INSERT INTO "checklists_kb" VALUES (277,'14.2.2','Verify that all unneeded features, documentation, samples, configurations are removed, such as sample applications, platform documentation, and default or example users.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Vulnerable_Dependency_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/531',1,66,0,531,14);
INSERT INTO "checklists_kb" VALUES (278,'14.2.3','Verify that if application assets, such as JavaScript libraries, CSS stylesheets or web fonts, are hosted externally on a content delivery network (CDN) or external provider, Subresource Integrity (SRI) is used to validate the integrity of the asset.','https://cwe.mitre.org/data/definitions/15',1,66,0,15,14);
INSERT INTO "checklists_kb" VALUES (279,'14.2.4','Verify that third party components come from pre-defined, trusted and continually maintained repositories','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Vulnerable_Dependency_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/828',2,66,0,828,14);
INSERT INTO "checklists_kb" VALUES (280,'14.2.5','Verify that an inventory catalog is maintained of all third party libraries in use.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Vulnerable_Dependency_Management_Cheat_Sheet.html',2,66,0,2,14);
INSERT INTO "checklists_kb" VALUES (281,'14.2.6','Verify that the attack surface is reduced by sandboxing or encapsulating third party libraries to expose only the required behaviour into the application.','https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html,https://cheatsheetseries.owasp.org/cheatsheets/Vulnerable_Dependency_Management_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/265',2,66,0,265,14);
INSERT INTO "checklists_kb" VALUES (282,'14.3.1','Verify that web or application server and framework error messages are configured to deliver user actionable, customized responses to eliminate any unintended security disclosures.','https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/209',1,67,1,209,14);
INSERT INTO "checklists_kb" VALUES (283,'14.3.2','Verify that web or application server and application framework debug modes are disabled in production to eliminate debug features, developer consoles, and unintended security disclosures.','https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/497',1,67,1,497,14);
INSERT INTO "checklists_kb" VALUES (284,'14.3.3','Verify that the HTTP headers or any part of the HTTP response do not expose detailed version information of system components.','https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/200',1,67,0,200,14);
INSERT INTO "checklists_kb" VALUES (285,'14.4.1','Verify that every HTTP response contains a content type header specifying a safe character set (e.g., UTF-8, ISO 8859-1).','https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/173',1,68,0,173,14);
INSERT INTO "checklists_kb" VALUES (286,'14.4.2','Verify that all API responses contain Content-Disposition: attachment; filename="api.json" (or other appropriate filename for the content type).','https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/116',1,68,0,116,14);
INSERT INTO "checklists_kb" VALUES (287,'14.4.3','Verify that a content security policy (CSPv2) is in place that helps mitigate impact for XSS attacks like HTML, DOM, JSON, and JavaScript injection vulnerabilities.','https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/1021',1,68,0,1021,14);
INSERT INTO "checklists_kb" VALUES (288,'14.4.4','Verify that all responses contain X-Content-Type-Options: nosniff.','https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/116',1,68,0,116,14);
INSERT INTO "checklists_kb" VALUES (289,'14.4.5','Verify that HTTP Strict Transport Security headers are included on all responses and for all subdomains, such as Strict-Transport-Security: max-age=15724800; includeSubdomains.','https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/523',1,68,0,523,14);
INSERT INTO "checklists_kb" VALUES (290,'14.4.6','Verify that a suitable "Referrer-Policy" header is included, such as "no-referrer" or "same-origin".','https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/116',1,68,0,116,14);
INSERT INTO "checklists_kb" VALUES (291,'14.4.7','Verify that a suitable X-Frame-Options or Content-Security-Policy: frame-ancestors header is in use for sites where content should not be embedded in a third-party site.','https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html,https://cwe.mitre.org/data/definitions/346',1,68,0,346,14);
INSERT INTO "checklists_kb" VALUES (292,'14.5.1','Verify that the application server only accepts the HTTP methods in use by the application or API, including pre-flight OPTIONS.','https://cwe.mitre.org/data/definitions/749',1,69,0,749,14);
INSERT INTO "checklists_kb" VALUES (293,'14.5.2','Verify that the supplied Origin header is not used for authentication or access control decisions, as the Origin header can easily be changed by an attacker.','https://cwe.mitre.org/data/definitions/346',1,69,0,346,14);
INSERT INTO "checklists_kb" VALUES (294,'14.5.3','Verify that the cross-domain resource sharing (CORS) Access-Control-Allow-Origin header uses a strict white-list of trusted domains to match against and does not support the "null" origin.','https://cwe.mitre.org/data/definitions/346',1,69,0,346,14);
INSERT INTO "checklists_kb" VALUES (295,'14.5.4','Verify that HTTP headers added by a trusted proxy or SSO devices, such as a bearer token, are authenticated by the application.','https://cwe.mitre.org/data/definitions/306',2,69,0,306,14);
INSERT INTO "checklists_kb" VALUES (296,'1.0','Architecture, Design and Threat Modeling Requirements',NULL,NULL,NULL,0,1,15);
INSERT INTO "checklists_kb" VALUES (297,'2.0','Data Storage and Privacy Requirements',NULL,NULL,NULL,0,1,16);
INSERT INTO "checklists_kb" VALUES (298,'3.0','Cryptography Requirements',NULL,NULL,NULL,0,1,17);
INSERT INTO "checklists_kb" VALUES (299,'4.0','Authentication and Session Management Requirements',NULL,NULL,NULL,0,1,18);
INSERT INTO "checklists_kb" VALUES (300,'5.0','Network Communication Requirements',NULL,NULL,NULL,0,1,19);
INSERT INTO "checklists_kb" VALUES (301,'6.0','Platform Interaction Requirements',NULL,NULL,NULL,0,1,20);
INSERT INTO "checklists_kb" VALUES (302,'7.0','Code Quality and Build Setting Requirements',NULL,NULL,NULL,0,1,21);
INSERT INTO "checklists_kb" VALUES (303,'8.0','Resilience Requirements',NULL,NULL,NULL,0,1,22);
INSERT INTO "checklists_kb" VALUES (304,'1.1','All app components are identified and known to be needed.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-for-insecure-configuration-of-instant-apps-mstg-arch-1,-mstg-arch-7',1,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (305,'1.2','Security controls are never enforced only on the client side, but on the respective remote endpoints.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#verifying-that-appropriate-authentication-is-in-place-mstg-arch-2-and-mstg-auth-1,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04h-Testing-Code-Quality.md#injection-flaws-mstg-arch-2-and-mstg-platform-2',1,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (306,'1.3','A high-level architecture for the mobile app and all connected remote services has been defined and security has been addressed in that architecture.','',1,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (307,'1.4','Data considered sensitive in the context of the mobile app is clearly identified.','',1,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (308,'1.5','All app components are defined in terms of the business functions and/or security functions they provide.','',2,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (309,'1.6','A threat model for the mobile app and the associated remote services has been produced that identifies potential threats and countermeasures.','',2,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (310,'1.7','All security controls have a centralized implementation.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-for-insecure-configuration-of-instant-apps-mstg-arch-1,-mstg-arch-7',2,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (311,'1.8','There is an explicit policy for how cryptographic keys (if any) are managed, and the lifecycle of cryptographic keys is enforced. Ideally, follow a key management standard such as NIST SP 800-57.','',2,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (312,'1.9','A mechanism for enforcing updates of the mobile app exists.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#testing-enforced-updating-mstg-arch-9,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-enforced-updating-mstg-arch-9',2,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (313,'1.10','Security is addressed within all parts of the software development lifecycle.','',2,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (314,'1.11','A responsible disclosure policy is in place and effectively applied.','',2,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (315,'1.12','The app should comply with privacy laws and regulations.','',1,NULL,0,2000,15);
INSERT INTO "checklists_kb" VALUES (316,'2.1','System credential storage facilities need to be used to store sensitive data, such as PII, user credentials or cryptographic keys.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-local-storage-for-sensitive-data-mstg-storage-1-and-mstg-storage-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#testing-local-data-storage-mstg-storage-1-and-mstg-storage-2',1,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (317,'2.2','No sensitive data should be stored outside of the app container or system credential storage facilities.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-local-storage-for-sensitive-data-mstg-storage-1-and-mstg-storage-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#testing-local-data-storage-mstg-storage-1-and-mstg-storage-2',1,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (318,'2.3','No sensitive data is written to application logs.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-logs-for-sensitive-data-mstg-storage-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#checking-logs-for-sensitive-data-mstg-storage-3',1,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (319,'2.4','No sensitive data is shared with third parties unless it is a necessary part of the architecture.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#determining-whether-sensitive-data-is-sent-to-third-parties-mstg-storage-4,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#determining-whether-sensitive-data-is-sent-to-third-parties-mstg-storage-4',1,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (320,'2.5','The keyboard cache is disabled on text inputs that process sensitive data.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields-mstg-storage-5,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#finding-sensitive-data-in-the-keyboard-cache-mstg-storage-5',1,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (321,'2.6','No sensitive data is exposed via IPC mechanisms.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#determining-whether-sensitive-stored-data-has-been-exposed-via-ipc-mechanisms-mstg-storage-6,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#determining-whether-sensitive-data-is-exposed-via-ipc-mechanisms-mstg-storage-6',1,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (322,'2.7','No sensitive data, such as passwords or pins, is exposed through the user interface.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#checking-for-sensitive-data-disclosure-through-the-user-interface-mstg-storage-7,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#checking-for-sensitive-data-disclosed-through-the-user-interface-mstg-storage-7',1,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (323,'2.8','No sensitive data is included in backups generated by the mobile operating system.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#testing-backups-for-sensitive-data-mstg-storage-8',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (324,'2.9','The app removes sensitive data from views when moved to the background.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#finding-sensitive-information-in-auto-generated-screenshots-mstg-storage-9,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#testing-auto-generated-screenshots-for-sensitive-information-mstg-storage-9',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (325,'2.10','The app does not hold sensitive data in memory longer than necessary, and memory is cleared explicitly after use.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#checking-memory-for-sensitive-data-mstg-storage-10,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06d-Testing-Data-Storage.md#testing-memory-for-sensitive-data-mstg-storage-10',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (326,'2.11','The app enforces a minimum device-access-security policy, such as requiring the user to set a device passcode.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-the-device-access-security-policy-mstg-storage-11,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md#testing-local-authentication-mstg-auth-8-and-mstg-storage-11',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (327,'2.12','The app educates the user about the types of personally identifiable information processed, as well as security best practices the user should follow in using the app.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04i-Testing-user-interaction.md#testing-user-education-mstg-storage-12',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (328,'2.13','No sensitive data should be stored locally on the mobile device. Instead, data should be retrieved from a remote endpoint when needed and only be kept in memory.','',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (329,'2.14','If sensitive data is still required to be stored locally, it should be encrypted using a key derived from hardware backed storage which requires authentication.','',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (330,'2.15','The app’s local storage should be wiped after an excessive number of failed authentication attempts.','',2,NULL,0,2000,16);
INSERT INTO "checklists_kb" VALUES (331,'3.1','The app does not rely on symmetric cryptography with hardcoded keys as a sole method of encryption.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06e-Testing-Cryptography.md#testing-key-management-mstg-crypto-1-and-mstg-crypto-5,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#common-configuration-issues-mstg-crypto-1,-mstg-crypto-2-and-mstg-crypto-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05e-Testing-Cryptography.md#testing-symmetric-cryptography-mstg-crypto-1',1,NULL,0,2000,17);
INSERT INTO "checklists_kb" VALUES (332,'3.2','The app uses proven implementations of cryptographic primitives.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06e-Testing-Cryptography.md#verifying-the-configuration-of-cryptographic-standard-algorithms-mstg-crypto-2-and-mstg-crypto-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#common-configuration-issues-mstg-crypto-1,-mstg-crypto-2-and-mstg-crypto-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05e-Testing-Cryptography.md#testing-the-configuration-of-cryptographic-standard-algorithms-mstg-crypto-2,-mstg-crypto-3-and-mstg-crypto-4',1,NULL,0,2000,17);
INSERT INTO "checklists_kb" VALUES (333,'3.3','The app uses cryptographic primitives that are appropriate for the particular use-case, configured with parameters that adhere to industry best practices.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06e-Testing-Cryptography.md#verifying-the-configuration-of-cryptographic-standard-algorithms-mstg-crypto-2-and-mstg-crypto-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#common-configuration-issues-mstg-crypto-1,-mstg-crypto-2-and-mstg-crypto-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05e-Testing-Cryptography.md#testing-the-configuration-of-cryptographic-standard-algorithms-mstg-crypto-2,-mstg-crypto-3-and-mstg-crypto-4',1,NULL,0,2000,17);
INSERT INTO "checklists_kb" VALUES (334,'3.4','The app does not use cryptographic protocols or algorithms that are widely considered deprecated for security purposes.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04g-Testing-Cryptography.md#identifying-insecure-and/or-deprecated-cryptographic-algorithms-mstg-crypto-4,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05e-Testing-Cryptography.md#testing-the-configuration-of-cryptographic-standard-algorithms-mstg-crypto-2,-mstg-crypto-3-and-mstg-crypto-4',1,NULL,0,2000,17);
INSERT INTO "checklists_kb" VALUES (335,'3.5','The app doesn''t re-use the same cryptographic key for multiple purposes.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06e-Testing-Cryptography.md#testing-key-management-mstg-crypto-1-and-mstg-crypto-5,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05e-Testing-Cryptography.md#testing-the-purposes-of-keys-mstg-crypto-5',1,NULL,0,2000,17);
INSERT INTO "checklists_kb" VALUES (336,'3.6','All random values are generated using a sufficiently secure random number generator.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06e-Testing-Cryptography.md#testing-random-number-generation-mstg-crypto-6,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05e-Testing-Cryptography.md#testing-random-number-generation-mstg-crypto-6',1,NULL,0,2000,17);
INSERT INTO "checklists_kb" VALUES (337,'4.1','If the app provides users access to a remote service, some form of authentication, such as username/password authentication, is performed at the remote endpoint.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#verifying-that-appropriate-authentication-is-in-place-mstg-arch-2-and-mstg-auth-1,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-oauth-2.0-flows-mstg-auth-1-and-mstg-auth-3',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (338,'4.2','If stateful session management is used, the remote endpoint uses randomly generated session identifiers to authenticate client requests without sending the user''s credentials.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-stateful-session-management-mstg-auth-2',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (339,'4.3','If stateless token-based authentication is used, the server provides a token that has been signed using a secure algorithm.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-stateless-(token-based)-authentication-mstg-auth-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-oauth-2.0-flows-mstg-auth-1-and-mstg-auth-3',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (340,'4.4','The remote endpoint terminates the existing session when the user logs out.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-user-logout-mstg-auth-4',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (341,'4.5','A password policy exists and is enforced at the remote endpoint.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-best-practices-for-passwords-mstg-auth-5-and-mstg-auth-6',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (342,'4.6','The remote endpoint implements a mechanism to protect against the submission of credentials an excessive number of times.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-best-practices-for-passwords-mstg-auth-5-and-mstg-auth-6',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (343,'4.7','Sessions are invalidated at the remote endpoint after a predefined period of inactivity and access tokens expire.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-session-timeout-mstg-auth-7',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (344,'4.8','Biometric authentication, if any, is not event-bound (i.e. using an API that simply returns "true" or "false"). Instead, it is based on unlocking the keychain/keystore.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md#testing-local-authentication-mstg-auth-8-and-mstg-storage-11',2,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (345,'4.9','A second factor of authentication exists at the remote endpoint and the 2FA requirement is consistently enforced.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-two-factor-authentication-and-step-up-authentication-mstg-auth-9-and-mstg-auth-10',2,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (346,'4.10','Sensitive transactions require step-up authentication.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-two-factor-authentication-and-step-up-authentication-mstg-auth-9-and-mstg-auth-10',2,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (347,'4.11','The app informs the user of all sensitive activities with their account. Users are able to view a list of devices, view contextual information (IP address, location, etc.), and to block specific devices.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-login-activity-and-device-blocking-mstg-auth-11',2,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (348,'4.12','Authorization models should be defined and enforced at the remote endpoint.','',1,NULL,0,2000,18);
INSERT INTO "checklists_kb" VALUES (349,'5.1','Data is encrypted on the network using TLS. The secure channel is used consistently throughout the app.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04f-Testing-Network-Communication.md#verifying-data-encryption-on-the-network-mstg-network-1-and-mstg-network-2',1,NULL,0,2000,19);
INSERT INTO "checklists_kb" VALUES (350,'5.2','The TLS settings are in line with current best practices, or as close as possible if the mobile operating system does not support the recommended standards.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06g-Testing-Network-Communication.md#app-transport-security-mstg-network-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04f-Testing-Network-Communication.md#verifying-data-encryption-on-the-network-mstg-network-1-and-mstg-network-2',1,NULL,0,2000,19);
INSERT INTO "checklists_kb" VALUES (351,'5.3','The app verifies the X.509 certificate of the remote endpoint when the secure channel is established. Only certificates signed by a trusted CA are accepted.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md#testing-endpoint-identify-verification-mstg-network-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06g-Testing-Network-Communication.md#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-3-and-mstg-network-4',1,NULL,0,2000,19);
INSERT INTO "checklists_kb" VALUES (352,'5.4','The app either uses its own certificate store, or pins the endpoint certificate or public key, and subsequently does not establish connections with endpoints that offer a different certificate or key, even if signed by a trusted CA.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-4,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md#testing-the-network-security-configuration-settings-mstg-network-4,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06g-Testing-Network-Communication.md#testing-custom-certificate-stores-and-certificate-pinning-mstg-network-3-and-mstg-network-4',2,NULL,0,2000,19);
INSERT INTO "checklists_kb" VALUES (353,'5.5','The app doesn''t rely on a single insecure communication channel (email or SMS) for critical operations, such as enrollments and account recovery.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04f-Testing-Network-Communication.md#making-sure-that-critical-operations-use-secure-communication-channels-mstg-network-5',2,NULL,0,2000,19);
INSERT INTO "checklists_kb" VALUES (354,'5.6','The app only depends on up-to-date connectivity and security libraries.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05g-Testing-Network-Communication.md#testing-the-security-provider-mstg-network-6',2,NULL,0,2000,19);
INSERT INTO "checklists_kb" VALUES (355,'6.1','The app only requests the minimum set of permissions necessary.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#testing-app-permissions-mstg-platform-1,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-app-permissions-mstg-platform-1',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (356,'6.2','All inputs from external sources and the user are validated and if necessary sanitized. This includes data received via the UI, IPC mechanisms such as intents, custom URLs, and network sources.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04h-Testing-Code-Quality.md#injection-flaws-mstg-arch-2-and-mstg-platform-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04h-Testing-Code-Quality.md#cross-site-scripting-flaws-mstg-platform-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05d-Testing-Data-Storage.md#testing-local-storage-for-input-validation-mstg-platform-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-for-injection-flaws-mstg-platform-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-for-fragment-injection-mstg-platform-2',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (357,'6.3','The app does not export sensitive functionality via custom URL schemes, unless these mechanisms are properly protected.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#testing-custom-url-schemes-mstg-platform-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-custom-url-schemes-mstg-platform-3',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (358,'6.4','The app does not export sensitive functionality through IPC facilities, unless these mechanisms are properly protected.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#testing-for-sensitive-functionality-exposure-through-ipc-mstg-platform-4,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-for-sensitive-functionality-exposure-through-ipc-mstg-platform-4',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (359,'6.5','JavaScript is disabled in WebViews unless explicitly required.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#testing-ios-webviews-mstg-platform-5,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-javascript-execution-in-webviews-mstg-platform-5',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (360,'6.6','WebViews are configured to allow only the minimum set of protocol handlers required (ideally, only https is supported). Potentially dangerous handlers, such as file, tel and app-id, are disabled.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#testing-webview-protocol-handlers-mstg-platform-6,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-webview-protocol-handlers-mstg-platform-6',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (361,'6.7','If native methods of the app are exposed to a WebView, verify that the WebView only renders JavaScript contained within the app package.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#determining-whether-native-methods-are-exposed-through-webviews-mstg-platform-7,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#determining-whether-java-objects-are-exposed-through-webviews-mstg-platform-7',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (362,'6.8','Object deserialization, if any, is implemented using safe serialization APIs.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md#testing-object-persistence-mstg-platform-8,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05h-Testing-Platform-Interaction.md#testing-object-persistence-mstg-platform-8',1,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (363,'6.9','The app protects itself against screen overlay attacks. (Android only)','',2,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (364,'6.10','A WebView''s cache, storage, and loaded resources (JavaScript, etc.) should be cleared before the WebView is destroyed.','',2,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (365,'6.11','Verify that the app prevents usage of custom third-party keyboards whenever sensitive data is entered.','',2,NULL,0,2000,20);
INSERT INTO "checklists_kb" VALUES (366,'7.1','The app is signed and provisioned with a valid certificate, of which the private key is properly protected.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#making-sure-that-the-app-is-properly-signed-mstg-code-1,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#making-sure-that-the-app-is-properly-signed-mstg-code-1',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (367,'7.2','The app has been built in release mode, with settings appropriate for a release build (e.g. non-debuggable).','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#testing-whether-the-app-is-debuggable-mstg-code-2,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#determining-whether-the-app-is-debuggable-mstg-code-2',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (368,'7.3','Debugging symbols have been removed from native binaries.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#testing-for-debugging-symbols-mstg-code-3,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#finding-debugging-symbols-mstg-code-3',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (369,'7.4','Debugging code and developer assistance code (e.g. test code, backdoors, hidden settings) have been removed. The app does not log verbose errors or debugging messages.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#testing-for-debugging-code-and-verbose-error-logging-mstg-code-4,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#finding-debugging-code-and-verbose-error-logging-mstg-code-4',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (370,'7.5','All third party components used by the mobile app, such as libraries and frameworks, are identified, and checked for known vulnerabilities.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#checking-for-weaknesses-in-third-party-libraries-mstg-code-5,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#checking-for-weaknesses-in-third-party-libraries-mstg-code-5',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (371,'7.6','The app catches and handles possible exceptions.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#testing-exception-handling-mstg-code-6-and-mstg-code-7,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#testing-exception-handling-mstg-code-6',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (372,'7.7','Error handling logic in security controls denies access by default.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#testing-exception-handling-mstg-code-6-and-mstg-code-7',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (373,'7.8','In unmanaged code, memory is allocated, freed and used securely.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#memory-corruption-bugs-mstg-code-8,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04h-Testing-Code-Quality.md#memory-corruption-bugs-mstg-code-8,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#memory-corruption-bugs-mstg-code-8',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (374,'7.9','Free security features offered by the toolchain, such as byte-code minification, stack protection, PIE support and automatic reference counting, are activated.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05i-Testing-Code-Quality-and-Build-Settings.md#make-sure-that-free-security-features-are-activated-mstg-code-9,https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06i-Testing-Code-Quality-and-Build-Settings.md#make-sure-that-free-security-features-are-activated-mstg-code-9',1,NULL,0,2000,21);
INSERT INTO "checklists_kb" VALUES (375,'8.1','The app detects, and responds to, the presence of a rooted or jailbroken device either by alerting the user or terminating the app.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#jailbreak-detection-mstg-resilience-1',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (376,'8.2','The app prevents debugging and/or detects, and responds to, a debugger being attached. All available debugging protocols must be covered.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#testing-anti-debugging-detection-mstg-resilience-2',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (377,'8.3','The app detects, and responds to, tampering with executable files and critical data within its own sandbox.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#file-integrity-checks-mstg-resilience-3-and-mstg-resilience-11',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (378,'8.4','The app detects, and responds to, the presence of widely used reverse engineering tools and frameworks on the device.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#testing-reverse-engineering-tools-detection-mstg-resilience-4',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (379,'8.5','The app detects, and responds to, being run in an emulator.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#testing-emulator-detection-mstg-resilience-5',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (380,'8.6','The app detects, and responds to, tampering the code and data in its own memory space.','',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (381,'8.7','The app implements multiple mechanisms in each defense category (8.1 to 8.6). Note that resiliency scales with the amount, diversity of the originality of the mechanisms used.','',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (382,'8.8','The detection mechanisms trigger responses of different types, including delayed and stealthy responses.','',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (383,'8.9','Obfuscation is applied to programmatic defenses, which in turn impede de-obfuscation via dynamic analysis.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#testing-obfuscation-mstg-resilience-9',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (384,'8.10','The app implements a ''device binding'' functionality using a device fingerprint derived from multiple properties unique to the device.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#device-binding-mstg-resilience-10',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (385,'8.11','All executable files and libraries belonging to the app are either encrypted on the file level and/or important code and data segments inside the executables are encrypted or packed. Trivial static analysis does not reveal important code or data.','https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md#file-integrity-checks-mstg-resilience-3-and-mstg-resilience-11',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (386,'8.12','If the goal of obfuscation is to protect sensitive computations, an obfuscation scheme is used that is both appropriate for the particular task and robust against manual and automated de-obfuscation methods, considering currently published research. The effectiveness of the obfuscation scheme must be verified through manual testing. Note that hardware-based isolation features are preferred over obfuscation whenever possible.','',3,NULL,0,2000,22);
INSERT INTO "checklists_kb" VALUES (387,'8.13','As a defense in depth, next to having solid hardening of the communicating parties, application level payload encryption can be applied to further impede eavesdropping.','',3,NULL,0,2000,22);
INSERT INTO "groupmembers" VALUES (1,1);
INSERT INTO "project_sprints" VALUES (1,'Authentication Verification Requirements','Authentication Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (2,'Session Management Verification Requirements','Session Management Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (3,'Access Control Verification Requirements','Access Control Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (4,'Validation, Sanitization and Encoding Verification Requirements','Validation, Sanitization and Encoding Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (5,'Stored Cryptography Verification Requirements','Stored Cryptography Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (6,'Error Handling and Logging Verification Requirements','Error Handling and Logging Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (7,'Data Protection Verification Requirements','Data Protection Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (8,'Communications Verification Requirements','Communications Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (9,'Malicious Code Verification Requirements','Malicious Code Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (10,'Business Logic Verification Requirements','Business Logic Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (11,'File and Resources Verification Requirements','File and Resources Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (12,'API and Web Service Verification Requirements','API and Web Service Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (13,'Configuration Verification Requirements','Configuration Verification Requirements',1,1,NULL);
INSERT INTO "project_sprints" VALUES (14,'Architecture, Design and Threat Modeling Requirements','Architecture, Design and Threat Modeling Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (15,'Authentication Verification Requirements','Authentication Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (16,'Session Management Verification Requirements','Session Management Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (17,'Access Control Verification Requirements','Access Control Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (18,'Validation, Sanitization and Encoding Verification Requirements','Validation, Sanitization and Encoding Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (19,'Stored Cryptography Verification Requirements','Stored Cryptography Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (20,'Error Handling and Logging Verification Requirements','Error Handling and Logging Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (21,'Data Protection Verification Requirements','Data Protection Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (22,'Communications Verification Requirements','Communications Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (23,'Malicious Code Verification Requirements','Malicious Code Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (24,'Business Logic Verification Requirements','Business Logic Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (25,'File and Resources Verification Requirements','File and Resources Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (26,'API and Web Service Verification Requirements','API and Web Service Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (27,'Configuration Verification Requirements','Configuration Verification Requirements',1,2,NULL);
INSERT INTO "project_sprints" VALUES (28,'Architecture, Design and Threat Modeling Requirements','Architecture, Design and Threat Modeling Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (29,'Authentication Verification Requirements','Authentication Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (30,'Session Management Verification Requirements','Session Management Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (31,'Access Control Verification Requirements','Access Control Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (32,'Validation, Sanitization and Encoding Verification Requirements','Validation, Sanitization and Encoding Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (33,'Stored Cryptography Verification Requirements','Stored Cryptography Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (34,'Error Handling and Logging Verification Requirements','Error Handling and Logging Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (35,'Data Protection Verification Requirements','Data Protection Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (36,'Communications Verification Requirements','Communications Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (37,'Malicious Code Verification Requirements','Malicious Code Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (38,'Business Logic Verification Requirements','Business Logic Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (39,'File and Resources Verification Requirements','File and Resources Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (40,'API and Web Service Verification Requirements','API and Web Service Verification Requirements',1,3,NULL);
INSERT INTO "project_sprints" VALUES (41,'Configuration Verification Requirements','Configuration Verification Requirements',1,3,NULL);
INSERT INTO "checklist_kb_code_item" VALUES (1,45,286);
INSERT INTO "checklist_kb_code_item" VALUES (2,45,295);
INSERT INTO "checklist_kb_code_item" VALUES (3,45,287);
INSERT INTO "checklist_kb_code_item" VALUES (4,46,286);
INSERT INTO "checklist_kb_code_item" VALUES (5,46,295);
INSERT INTO "checklist_kb_code_item" VALUES (6,46,287);
INSERT INTO "checklist_kb_code_item" VALUES (7,47,286);
INSERT INTO "checklist_kb_code_item" VALUES (8,47,295);
INSERT INTO "checklist_kb_code_item" VALUES (9,47,287);
INSERT INTO "checklist_kb_code_item" VALUES (10,48,286);
INSERT INTO "checklist_kb_code_item" VALUES (11,48,295);
INSERT INTO "checklist_kb_code_item" VALUES (12,48,287);
INSERT INTO "checklist_kb_code_item" VALUES (13,49,286);
INSERT INTO "checklist_kb_code_item" VALUES (14,49,295);
INSERT INTO "checklist_kb_code_item" VALUES (15,49,287);
INSERT INTO "checklist_kb_code_item" VALUES (16,50,286);
INSERT INTO "checklist_kb_code_item" VALUES (17,50,295);
INSERT INTO "checklist_kb_code_item" VALUES (18,51,287);
INSERT INTO "checklist_kb_code_item" VALUES (19,52,292);
INSERT INTO "checklist_kb_code_item" VALUES (20,52,289);
INSERT INTO "checklist_kb_code_item" VALUES (21,53,286);
INSERT INTO "checklist_kb_code_item" VALUES (22,53,295);
INSERT INTO "checklist_kb_code_item" VALUES (23,53,287);
INSERT INTO "checklist_kb_code_item" VALUES (24,55,287);
INSERT INTO "checklist_kb_code_item" VALUES (25,55,292);
INSERT INTO "checklist_kb_code_item" VALUES (26,56,287);
INSERT INTO "checklist_kb_code_item" VALUES (27,56,292);
INSERT INTO "checklist_kb_code_item" VALUES (28,57,291);
INSERT INTO "checklist_kb_code_item" VALUES (29,59,289);
INSERT INTO "checklist_kb_code_item" VALUES (30,59,292);
INSERT INTO "checklist_kb_code_item" VALUES (31,64,286);
INSERT INTO "checklist_kb_code_item" VALUES (32,64,295);
INSERT INTO "checklist_kb_code_item" VALUES (33,64,287);
INSERT INTO "checklist_kb_code_item" VALUES (34,72,286);
INSERT INTO "checklist_kb_code_item" VALUES (35,72,295);
INSERT INTO "checklist_kb_code_item" VALUES (36,72,287);
INSERT INTO "checklist_kb_code_item" VALUES (37,74,286);
INSERT INTO "checklist_kb_code_item" VALUES (38,74,295);
INSERT INTO "checklist_kb_code_item" VALUES (39,74,287);
INSERT INTO "checklist_kb_code_item" VALUES (40,76,286);
INSERT INTO "checklist_kb_code_item" VALUES (41,76,295);
INSERT INTO "checklist_kb_code_item" VALUES (42,76,287);
INSERT INTO "checklist_kb_code_item" VALUES (43,77,286);
INSERT INTO "checklist_kb_code_item" VALUES (44,77,295);
INSERT INTO "checklist_kb_code_item" VALUES (45,77,287);
INSERT INTO "checklist_kb_code_item" VALUES (46,82,292);
INSERT INTO "checklist_kb_code_item" VALUES (47,82,289);
INSERT INTO "checklist_kb_code_item" VALUES (48,83,292);
INSERT INTO "checklist_kb_code_item" VALUES (49,83,289);
INSERT INTO "checklist_kb_code_item" VALUES (50,83,286);
INSERT INTO "checklist_kb_code_item" VALUES (51,83,295);
INSERT INTO "checklist_kb_code_item" VALUES (52,83,287);
INSERT INTO "checklist_kb_code_item" VALUES (53,84,292);
INSERT INTO "checklist_kb_code_item" VALUES (54,84,289);
INSERT INTO "checklist_kb_code_item" VALUES (55,84,286);
INSERT INTO "checklist_kb_code_item" VALUES (56,84,295);
INSERT INTO "checklist_kb_code_item" VALUES (57,84,287);
INSERT INTO "checklist_kb_code_item" VALUES (58,88,286);
INSERT INTO "checklist_kb_code_item" VALUES (59,88,295);
INSERT INTO "checklist_kb_code_item" VALUES (60,88,287);
INSERT INTO "checklist_kb_code_item" VALUES (61,103,291);
INSERT INTO "checklist_kb_code_item" VALUES (62,104,286);
INSERT INTO "checklist_kb_code_item" VALUES (63,104,295);
INSERT INTO "checklist_kb_code_item" VALUES (64,104,287);
INSERT INTO "checklist_kb_code_item" VALUES (65,106,286);
INSERT INTO "checklist_kb_code_item" VALUES (66,106,295);
INSERT INTO "checklist_kb_code_item" VALUES (67,106,287);
INSERT INTO "checklist_kb_code_item" VALUES (68,106,291);
INSERT INTO "checklist_kb_code_item" VALUES (69,107,286);
INSERT INTO "checklist_kb_code_item" VALUES (70,107,295);
INSERT INTO "checklist_kb_code_item" VALUES (71,107,287);
INSERT INTO "checklist_kb_code_item" VALUES (72,108,292);
INSERT INTO "checklist_kb_code_item" VALUES (73,108,289);
INSERT INTO "checklist_kb_code_item" VALUES (74,109,286);
INSERT INTO "checklist_kb_code_item" VALUES (75,109,295);
INSERT INTO "checklist_kb_code_item" VALUES (76,109,287);
INSERT INTO "checklist_kb_code_item" VALUES (77,112,286);
INSERT INTO "checklist_kb_code_item" VALUES (78,112,295);
INSERT INTO "checklist_kb_code_item" VALUES (79,112,287);
INSERT INTO "checklist_kb_code_item" VALUES (80,112,288);
INSERT INTO "checklist_kb_code_item" VALUES (81,113,286);
INSERT INTO "checklist_kb_code_item" VALUES (82,113,295);
INSERT INTO "checklist_kb_code_item" VALUES (83,113,287);
INSERT INTO "checklist_kb_code_item" VALUES (84,113,288);
INSERT INTO "checklist_kb_code_item" VALUES (85,114,286);
INSERT INTO "checklist_kb_code_item" VALUES (86,114,295);
INSERT INTO "checklist_kb_code_item" VALUES (87,114,287);
INSERT INTO "checklist_kb_code_item" VALUES (88,114,288);
INSERT INTO "checklist_kb_code_item" VALUES (89,115,286);
INSERT INTO "checklist_kb_code_item" VALUES (90,115,295);
INSERT INTO "checklist_kb_code_item" VALUES (91,115,287);
INSERT INTO "checklist_kb_code_item" VALUES (92,115,288);
INSERT INTO "checklist_kb_code_item" VALUES (93,116,286);
INSERT INTO "checklist_kb_code_item" VALUES (94,116,295);
INSERT INTO "checklist_kb_code_item" VALUES (95,116,287);
INSERT INTO "checklist_kb_code_item" VALUES (96,116,288);
INSERT INTO "checklist_kb_code_item" VALUES (97,124,286);
INSERT INTO "checklist_kb_code_item" VALUES (98,124,295);
INSERT INTO "checklist_kb_code_item" VALUES (99,124,287);
INSERT INTO "checklist_kb_code_item" VALUES (100,124,292);
INSERT INTO "checklist_kb_code_item" VALUES (101,124,289);
INSERT INTO "checklist_kb_code_item" VALUES (102,125,286);
INSERT INTO "checklist_kb_code_item" VALUES (103,125,295);
INSERT INTO "checklist_kb_code_item" VALUES (104,125,287);
INSERT INTO "checklist_kb_code_item" VALUES (105,126,291);
INSERT INTO "checklist_kb_code_item" VALUES (106,128,286);
INSERT INTO "checklist_kb_code_item" VALUES (107,128,295);
INSERT INTO "checklist_kb_code_item" VALUES (108,128,287);
INSERT INTO "checklist_kb_code_item" VALUES (109,129,286);
INSERT INTO "checklist_kb_code_item" VALUES (110,129,295);
INSERT INTO "checklist_kb_code_item" VALUES (111,129,287);
INSERT INTO "checklist_kb_code_item" VALUES (112,130,291);
INSERT INTO "checklist_kb_code_item" VALUES (113,129,286);
INSERT INTO "checklist_kb_code_item" VALUES (114,129,295);
INSERT INTO "checklist_kb_code_item" VALUES (115,129,287);
INSERT INTO "checklist_kb_code_item" VALUES (116,133,291);
INSERT INTO "checklist_kb_code_item" VALUES (117,134,286);
INSERT INTO "checklist_kb_code_item" VALUES (118,134,295);
INSERT INTO "checklist_kb_code_item" VALUES (119,134,287);
INSERT INTO "checklist_kb_code_item" VALUES (120,135,286);
INSERT INTO "checklist_kb_code_item" VALUES (121,135,295);
INSERT INTO "checklist_kb_code_item" VALUES (122,135,287);
INSERT INTO "checklist_kb_code_item" VALUES (123,136,286);
INSERT INTO "checklist_kb_code_item" VALUES (124,136,295);
INSERT INTO "checklist_kb_code_item" VALUES (125,136,287);
INSERT INTO "checklist_kb_code_item" VALUES (126,137,286);
INSERT INTO "checklist_kb_code_item" VALUES (127,137,295);
INSERT INTO "checklist_kb_code_item" VALUES (128,137,287);
INSERT INTO "checklist_kb_code_item" VALUES (129,138,291);
INSERT INTO "checklist_kb_code_item" VALUES (130,139,286);
INSERT INTO "checklist_kb_code_item" VALUES (131,139,295);
INSERT INTO "checklist_kb_code_item" VALUES (132,139,287);
INSERT INTO "checklist_kb_code_item" VALUES (133,141,286);
INSERT INTO "checklist_kb_code_item" VALUES (134,141,295);
INSERT INTO "checklist_kb_code_item" VALUES (135,141,287);
INSERT INTO "checklist_kb_code_item" VALUES (136,142,286);
INSERT INTO "checklist_kb_code_item" VALUES (137,142,295);
INSERT INTO "checklist_kb_code_item" VALUES (138,142,287);
INSERT INTO "checklist_kb_code_item" VALUES (139,142,291);
INSERT INTO "checklist_kb_code_item" VALUES (140,142,292);
INSERT INTO "checklist_kb_code_item" VALUES (141,142,289);
INSERT INTO "checklist_kb_code_item" VALUES (142,143,286);
INSERT INTO "checklist_kb_code_item" VALUES (143,143,295);
INSERT INTO "checklist_kb_code_item" VALUES (144,143,287);
INSERT INTO "checklist_kb_code_item" VALUES (145,143,291);
INSERT INTO "checklist_kb_code_item" VALUES (146,144,291);
INSERT INTO "checklist_kb_code_item" VALUES (147,145,291);
INSERT INTO "checklist_kb_code_item" VALUES (148,146,286);
INSERT INTO "checklist_kb_code_item" VALUES (149,146,295);
INSERT INTO "checklist_kb_code_item" VALUES (150,146,287);
INSERT INTO "checklist_kb_code_item" VALUES (151,146,291);
INSERT INTO "checklist_kb_code_item" VALUES (152,147,286);
INSERT INTO "checklist_kb_code_item" VALUES (153,147,295);
INSERT INTO "checklist_kb_code_item" VALUES (154,147,287);
INSERT INTO "checklist_kb_code_item" VALUES (155,147,291);
INSERT INTO "checklist_kb_code_item" VALUES (156,148,286);
INSERT INTO "checklist_kb_code_item" VALUES (157,148,295);
INSERT INTO "checklist_kb_code_item" VALUES (158,148,287);
INSERT INTO "checklist_kb_code_item" VALUES (159,148,291);
INSERT INTO "checklist_kb_code_item" VALUES (160,149,286);
INSERT INTO "checklist_kb_code_item" VALUES (161,149,295);
INSERT INTO "checklist_kb_code_item" VALUES (162,149,287);
INSERT INTO "checklist_kb_code_item" VALUES (163,149,291);
INSERT INTO "checklist_kb_code_item" VALUES (164,150,286);
INSERT INTO "checklist_kb_code_item" VALUES (165,150,295);
INSERT INTO "checklist_kb_code_item" VALUES (166,150,287);
INSERT INTO "checklist_kb_code_item" VALUES (167,150,291);
INSERT INTO "checklist_kb_code_item" VALUES (168,151,286);
INSERT INTO "checklist_kb_code_item" VALUES (169,151,295);
INSERT INTO "checklist_kb_code_item" VALUES (170,151,287);
INSERT INTO "checklist_kb_code_item" VALUES (171,151,291);
INSERT INTO "checklist_kb_code_item" VALUES (172,152,286);
INSERT INTO "checklist_kb_code_item" VALUES (173,152,295);
INSERT INTO "checklist_kb_code_item" VALUES (174,152,287);
INSERT INTO "checklist_kb_code_item" VALUES (175,152,291);
INSERT INTO "checklist_kb_code_item" VALUES (176,153,286);
INSERT INTO "checklist_kb_code_item" VALUES (177,153,295);
INSERT INTO "checklist_kb_code_item" VALUES (178,153,287);
INSERT INTO "checklist_kb_code_item" VALUES (179,153,291);
INSERT INTO "checklist_kb_code_item" VALUES (180,154,286);
INSERT INTO "checklist_kb_code_item" VALUES (181,154,295);
INSERT INTO "checklist_kb_code_item" VALUES (182,154,287);
INSERT INTO "checklist_kb_code_item" VALUES (183,154,291);
INSERT INTO "checklist_kb_code_item" VALUES (184,155,286);
INSERT INTO "checklist_kb_code_item" VALUES (185,155,295);
INSERT INTO "checklist_kb_code_item" VALUES (186,155,287);
INSERT INTO "checklist_kb_code_item" VALUES (187,155,291);
INSERT INTO "checklist_kb_code_item" VALUES (188,164,294);
INSERT INTO "checklist_kb_code_item" VALUES (189,178,286);
INSERT INTO "checklist_kb_code_item" VALUES (190,178,295);
INSERT INTO "checklist_kb_code_item" VALUES (191,178,287);
INSERT INTO "checklist_kb_code_item" VALUES (192,179,286);
INSERT INTO "checklist_kb_code_item" VALUES (193,179,295);
INSERT INTO "checklist_kb_code_item" VALUES (194,179,287);
INSERT INTO "checklist_kb_code_item" VALUES (195,188,286);
INSERT INTO "checklist_kb_code_item" VALUES (196,188,295);
INSERT INTO "checklist_kb_code_item" VALUES (197,188,287);
INSERT INTO "checklist_kb_code_item" VALUES (198,198,286);
INSERT INTO "checklist_kb_code_item" VALUES (199,198,295);
INSERT INTO "checklist_kb_code_item" VALUES (200,198,287);
INSERT INTO "checklist_kb_code_item" VALUES (201,198,288);
INSERT INTO "checklist_kb_code_item" VALUES (202,199,286);
INSERT INTO "checklist_kb_code_item" VALUES (203,199,295);
INSERT INTO "checklist_kb_code_item" VALUES (204,199,287);
INSERT INTO "checklist_kb_code_item" VALUES (205,199,288);
INSERT INTO "checklist_kb_code_item" VALUES (206,199,292);
INSERT INTO "checklist_kb_code_item" VALUES (207,199,289);
INSERT INTO "checklist_kb_code_item" VALUES (208,201,286);
INSERT INTO "checklist_kb_code_item" VALUES (209,201,295);
INSERT INTO "checklist_kb_code_item" VALUES (210,201,287);
INSERT INTO "checklist_kb_code_item" VALUES (211,202,286);
INSERT INTO "checklist_kb_code_item" VALUES (212,202,295);
INSERT INTO "checklist_kb_code_item" VALUES (213,202,287);
INSERT INTO "checklist_kb_code_item" VALUES (214,203,286);
INSERT INTO "checklist_kb_code_item" VALUES (215,203,295);
INSERT INTO "checklist_kb_code_item" VALUES (216,203,287);
INSERT INTO "checklist_kb_code_item" VALUES (217,203,292);
INSERT INTO "checklist_kb_code_item" VALUES (218,203,289);
INSERT INTO "checklist_kb_code_item" VALUES (219,210,288);
INSERT INTO "checklist_kb_code_item" VALUES (220,211,294);
INSERT INTO "checklist_kb_code_item" VALUES (221,211,294);
INSERT INTO "checklist_kb_code_item" VALUES (222,227,291);
INSERT INTO "checklist_kb_code_item" VALUES (223,230,292);
INSERT INTO "checklist_kb_code_item" VALUES (224,230,289);
INSERT INTO "checklist_kb_code_item" VALUES (225,231,292);
INSERT INTO "checklist_kb_code_item" VALUES (226,231,289);
INSERT INTO "checklist_kb_code_item" VALUES (227,232,292);
INSERT INTO "checklist_kb_code_item" VALUES (228,232,289);
INSERT INTO "checklist_kb_code_item" VALUES (229,233,292);
INSERT INTO "checklist_kb_code_item" VALUES (230,233,289);
INSERT INTO "checklist_kb_code_item" VALUES (231,233,291);
INSERT INTO "checklist_kb_code_item" VALUES (232,239,286);
INSERT INTO "checklist_kb_code_item" VALUES (233,239,295);
INSERT INTO "checklist_kb_code_item" VALUES (234,239,287);
INSERT INTO "checklist_kb_code_item" VALUES (235,243,286);
INSERT INTO "checklist_kb_code_item" VALUES (236,243,295);
INSERT INTO "checklist_kb_code_item" VALUES (237,243,287);
INSERT INTO "checklist_kb_code_item" VALUES (238,243,291);
INSERT INTO "checklist_kb_code_item" VALUES (239,244,286);
INSERT INTO "checklist_kb_code_item" VALUES (240,244,295);
INSERT INTO "checklist_kb_code_item" VALUES (241,244,287);
INSERT INTO "checklist_kb_code_item" VALUES (242,244,291);
INSERT INTO "checklist_kb_code_item" VALUES (243,245,286);
INSERT INTO "checklist_kb_code_item" VALUES (244,245,295);
INSERT INTO "checklist_kb_code_item" VALUES (245,245,287);
INSERT INTO "checklist_kb_code_item" VALUES (246,245,291);
INSERT INTO "checklist_kb_code_item" VALUES (247,246,286);
INSERT INTO "checklist_kb_code_item" VALUES (248,246,295);
INSERT INTO "checklist_kb_code_item" VALUES (249,246,287);
INSERT INTO "checklist_kb_code_item" VALUES (250,246,291);
INSERT INTO "checklist_kb_code_item" VALUES (251,247,286);
INSERT INTO "checklist_kb_code_item" VALUES (252,247,295);
INSERT INTO "checklist_kb_code_item" VALUES (253,247,287);
INSERT INTO "checklist_kb_code_item" VALUES (254,247,291);
INSERT INTO "checklist_kb_code_item" VALUES (255,249,286);
INSERT INTO "checklist_kb_code_item" VALUES (256,249,295);
INSERT INTO "checklist_kb_code_item" VALUES (257,249,287);
INSERT INTO "checklist_kb_code_item" VALUES (258,249,291);
INSERT INTO "checklist_kb_code_item" VALUES (259,250,286);
INSERT INTO "checklist_kb_code_item" VALUES (260,250,295);
INSERT INTO "checklist_kb_code_item" VALUES (261,250,287);
INSERT INTO "checklist_kb_code_item" VALUES (262,251,286);
INSERT INTO "checklist_kb_code_item" VALUES (263,251,295);
INSERT INTO "checklist_kb_code_item" VALUES (264,251,287);
INSERT INTO "checklist_kb_code_item" VALUES (265,251,291);
INSERT INTO "checklist_kb_code_item" VALUES (266,252,292);
INSERT INTO "checklist_kb_code_item" VALUES (267,252,289);
INSERT INTO "checklist_kb_code_item" VALUES (268,253,286);
INSERT INTO "checklist_kb_code_item" VALUES (269,253,295);
INSERT INTO "checklist_kb_code_item" VALUES (270,253,287);
INSERT INTO "checklist_kb_code_item" VALUES (271,255,286);
INSERT INTO "checklist_kb_code_item" VALUES (272,255,295);
INSERT INTO "checklist_kb_code_item" VALUES (273,255,287);
INSERT INTO "checklist_kb_code_item" VALUES (274,255,291);
INSERT INTO "checklist_kb_code_item" VALUES (275,257,291);
INSERT INTO "checklist_kb_code_item" VALUES (276,260,292);
INSERT INTO "checklist_kb_code_item" VALUES (277,260,289);
INSERT INTO "checklist_kb_code_item" VALUES (278,261,292);
INSERT INTO "checklist_kb_code_item" VALUES (279,261,289);
INSERT INTO "checklist_kb_code_item" VALUES (280,262,286);
INSERT INTO "checklist_kb_code_item" VALUES (281,262,295);
INSERT INTO "checklist_kb_code_item" VALUES (282,262,287);
INSERT INTO "checklist_kb_code_item" VALUES (283,262,291);
INSERT INTO "checklist_kb_code_item" VALUES (284,266,286);
INSERT INTO "checklist_kb_code_item" VALUES (285,266,295);
INSERT INTO "checklist_kb_code_item" VALUES (286,266,287);
INSERT INTO "checklist_kb_code_item" VALUES (287,266,291);
INSERT INTO "checklist_kb_code_item" VALUES (288,276,290);
INSERT INTO "checklist_kb_code_item" VALUES (289,276,293);
INSERT INTO "checklist_kb_code_item" VALUES (290,282,292);
INSERT INTO "checklist_kb_code_item" VALUES (291,282,289);
INSERT INTO "checklist_kb_code_item" VALUES (292,283,292);
INSERT INTO "checklist_kb_code_item" VALUES (293,283,289);
INSERT INTO "checklist_kb_code_item" VALUES (294,284,288);
INSERT INTO "checklist_kb_code_item" VALUES (295,285,288);
INSERT INTO "checklist_kb_code_item" VALUES (296,286,291);
INSERT INTO "checklist_kb_code_item" VALUES (297,287,286);
INSERT INTO "checklist_kb_code_item" VALUES (298,287,295);
INSERT INTO "checklist_kb_code_item" VALUES (299,287,287);
INSERT INTO "checklist_kb_code_item" VALUES (300,287,288);
INSERT INTO "checklist_kb_code_item" VALUES (301,288,286);
INSERT INTO "checklist_kb_code_item" VALUES (302,288,295);
INSERT INTO "checklist_kb_code_item" VALUES (303,288,287);
INSERT INTO "checklist_kb_code_item" VALUES (304,288,288);
INSERT INTO "checklist_kb_code_item" VALUES (305,289,286);
INSERT INTO "checklist_kb_code_item" VALUES (306,289,295);
INSERT INTO "checklist_kb_code_item" VALUES (307,289,287);
INSERT INTO "checklist_kb_code_item" VALUES (308,289,288);
INSERT INTO "checklist_kb_code_item" VALUES (309,290,286);
INSERT INTO "checklist_kb_code_item" VALUES (310,290,295);
INSERT INTO "checklist_kb_code_item" VALUES (311,290,287);
INSERT INTO "checklist_kb_code_item" VALUES (312,290,288);
INSERT INTO "checklist_kb_code_item" VALUES (313,291,286);
INSERT INTO "checklist_kb_code_item" VALUES (314,291,295);
INSERT INTO "checklist_kb_code_item" VALUES (315,291,287);
INSERT INTO "checklist_kb_code_item" VALUES (316,291,288);
INSERT INTO "checklist_kb_code_item" VALUES (317,292,286);
INSERT INTO "checklist_kb_code_item" VALUES (318,292,295);
INSERT INTO "checklist_kb_code_item" VALUES (319,292,287);
INSERT INTO "checklist_kb_code_item" VALUES (320,292,288);
INSERT INTO "checklist_kb_code_item" VALUES (321,293,286);
INSERT INTO "checklist_kb_code_item" VALUES (322,293,295);
INSERT INTO "checklist_kb_code_item" VALUES (323,293,287);
INSERT INTO "checklist_kb_code_item" VALUES (324,293,288);
INSERT INTO "checklist_kb_code_item" VALUES (325,294,286);
INSERT INTO "checklist_kb_code_item" VALUES (326,294,295);
INSERT INTO "checklist_kb_code_item" VALUES (327,294,287);
INSERT INTO "checklist_kb_code_item" VALUES (328,294,288);
INSERT INTO "checklist_kb_code_item" VALUES (329,45,130);
INSERT INTO "checklist_kb_code_item" VALUES (330,46,130);
INSERT INTO "checklist_kb_code_item" VALUES (331,47,130);
INSERT INTO "checklist_kb_code_item" VALUES (332,51,130);
INSERT INTO "checklist_kb_code_item" VALUES (333,53,130);
INSERT INTO "checklist_kb_code_item" VALUES (334,99,143);
INSERT INTO "checklist_kb_code_item" VALUES (335,64,142);
INSERT INTO "checklist_kb_code_item" VALUES (336,67,143);
INSERT INTO "checklist_kb_code_item" VALUES (337,68,143);
INSERT INTO "checklist_kb_code_item" VALUES (338,70,143);
INSERT INTO "checklist_kb_code_item" VALUES (339,71,143);
INSERT INTO "checklist_kb_code_item" VALUES (340,87,142);
INSERT INTO "checklist_kb_code_item" VALUES (341,108,139);
INSERT INTO "checklist_kb_code_item" VALUES (342,108,163);
INSERT INTO "checklist_kb_code_item" VALUES (343,112,148);
INSERT INTO "checklist_kb_code_item" VALUES (344,116,133);
INSERT INTO "checklist_kb_code_item" VALUES (345,128,138);
INSERT INTO "checklist_kb_code_item" VALUES (346,131,131);
INSERT INTO "checklist_kb_code_item" VALUES (347,135,140);
INSERT INTO "checklist_kb_code_item" VALUES (348,137,140);
INSERT INTO "checklist_kb_code_item" VALUES (349,137,150);
INSERT INTO "checklist_kb_code_item" VALUES (350,142,129);
INSERT INTO "checklist_kb_code_item" VALUES (351,155,151);
INSERT INTO "checklist_kb_code_item" VALUES (352,155,168);
INSERT INTO "checklist_kb_code_item" VALUES (353,149,149);
INSERT INTO "checklist_kb_code_item" VALUES (354,153,147);
INSERT INTO "checklist_kb_code_item" VALUES (355,154,144);
INSERT INTO "checklist_kb_code_item" VALUES (356,157,156);
INSERT INTO "checklist_kb_code_item" VALUES (357,198,152);
INSERT INTO "checklist_kb_code_item" VALUES (358,230,146);
INSERT INTO "checklist_kb_code_item" VALUES (359,239,169);
INSERT INTO "checklist_kb_code_item" VALUES (360,243,144);
INSERT INTO "checklist_kb_code_item" VALUES (361,244,169);
INSERT INTO "checklist_kb_code_item" VALUES (362,246,135);
INSERT INTO "checklist_kb_code_item" VALUES (363,249,169);
INSERT INTO "checklist_kb_code_item" VALUES (364,262,138);
INSERT INTO "checklist_kb_code_item" VALUES (365,283,158);
INSERT INTO "checklist_kb_code_item" VALUES (366,285,136);
INSERT INTO "checklist_kb_code_item" VALUES (367,291,157);
INSERT INTO "checklist_kb_code_item" VALUES (368,295,154);
INSERT INTO "checklists_results" VALUES (1,45,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (2,46,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (3,47,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (4,48,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (5,49,1,1,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (6,50,1,1,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (7,51,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (8,52,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (9,53,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (10,54,1,1,0,263,2,'0',0);
INSERT INTO "checklists_results" VALUES (11,55,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (12,56,1,1,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (13,57,1,1,0,307,2,'0',0);
INSERT INTO "checklists_results" VALUES (14,58,1,1,0,304,2,'0',0);
INSERT INTO "checklists_results" VALUES (15,59,1,1,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (16,64,1,1,0,330,2,'0',0);
INSERT INTO "checklists_results" VALUES (17,72,1,1,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (18,73,1,1,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (19,74,1,1,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (20,75,1,1,0,276,2,'0',0);
INSERT INTO "checklists_results" VALUES (21,76,1,1,0,304,2,'0',0);
INSERT INTO "checklists_results" VALUES (22,77,1,1,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (23,82,1,1,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (24,83,1,1,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (25,84,1,1,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (26,85,1,1,0,523,2,'0',0);
INSERT INTO "checklists_results" VALUES (27,88,1,1,0,613,2,'0',0);
INSERT INTO "checklists_results" VALUES (28,103,1,2,0,598,3,'0',0);
INSERT INTO "checklists_results" VALUES (29,104,1,2,0,384,3,'0',0);
INSERT INTO "checklists_results" VALUES (30,105,1,2,0,311,3,'0',0);
INSERT INTO "checklists_results" VALUES (31,106,1,2,0,539,3,'0',0);
INSERT INTO "checklists_results" VALUES (32,108,1,2,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (33,109,1,2,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (34,112,1,2,0,614,3,'0',0);
INSERT INTO "checklists_results" VALUES (35,113,1,2,0,1004,3,'0',0);
INSERT INTO "checklists_results" VALUES (36,114,1,2,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (37,115,1,2,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (38,116,1,2,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (39,120,1,2,0,778,3,'0',0);
INSERT INTO "checklists_results" VALUES (40,122,1,3,0,602,4,'0',0);
INSERT INTO "checklists_results" VALUES (41,123,1,3,0,639,4,'0',0);
INSERT INTO "checklists_results" VALUES (42,124,1,3,0,285,4,'0',0);
INSERT INTO "checklists_results" VALUES (43,125,1,3,0,276,4,'0',0);
INSERT INTO "checklists_results" VALUES (44,126,1,3,0,285,4,'0',0);
INSERT INTO "checklists_results" VALUES (45,127,1,3,0,639,4,'0',0);
INSERT INTO "checklists_results" VALUES (46,128,1,3,0,352,4,'0',0);
INSERT INTO "checklists_results" VALUES (47,129,1,3,0,419,4,'0',0);
INSERT INTO "checklists_results" VALUES (48,130,1,3,0,548,4,'0',0);
INSERT INTO "checklists_results" VALUES (49,131,1,3,0,732,4,'0',0);
INSERT INTO "checklists_results" VALUES (50,133,1,4,0,235,5,'0',0);
INSERT INTO "checklists_results" VALUES (51,134,1,4,0,915,5,'0',0);
INSERT INTO "checklists_results" VALUES (52,135,1,4,0,20,5,'0',0);
INSERT INTO "checklists_results" VALUES (53,136,1,4,0,20,5,'0',0);
INSERT INTO "checklists_results" VALUES (54,137,1,4,0,601,5,'0',0);
INSERT INTO "checklists_results" VALUES (55,138,1,4,0,116,5,'0',0);
INSERT INTO "checklists_results" VALUES (56,139,1,4,0,138,5,'0',0);
INSERT INTO "checklists_results" VALUES (57,140,1,4,0,147,5,'0',0);
INSERT INTO "checklists_results" VALUES (58,141,1,4,0,95,5,'0',0);
INSERT INTO "checklists_results" VALUES (59,142,1,4,0,94,5,'0',0);
INSERT INTO "checklists_results" VALUES (60,143,1,4,0,918,5,'0',0);
INSERT INTO "checklists_results" VALUES (61,144,1,4,0,159,5,'0',0);
INSERT INTO "checklists_results" VALUES (62,145,1,4,0,94,5,'0',0);
INSERT INTO "checklists_results" VALUES (63,146,1,4,0,116,5,'0',0);
INSERT INTO "checklists_results" VALUES (64,147,1,4,0,176,5,'0',0);
INSERT INTO "checklists_results" VALUES (65,148,1,4,0,79,5,'0',0);
INSERT INTO "checklists_results" VALUES (66,151,1,4,0,830,5,'0',0);
INSERT INTO "checklists_results" VALUES (67,154,1,4,0,829,5,'0',0);
INSERT INTO "checklists_results" VALUES (68,149,1,4,0,89,5,'0',0);
INSERT INTO "checklists_results" VALUES (69,150,1,4,0,89,5,'0',0);
INSERT INTO "checklists_results" VALUES (70,152,1,4,0,943,5,'0',0);
INSERT INTO "checklists_results" VALUES (71,153,1,4,0,78,5,'0',0);
INSERT INTO "checklists_results" VALUES (72,155,1,4,0,643,5,'0',0);
INSERT INTO "checklists_results" VALUES (73,156,1,4,0,502,5,'0',0);
INSERT INTO "checklists_results" VALUES (74,157,1,4,0,611,5,'0',0);
INSERT INTO "checklists_results" VALUES (75,158,1,4,0,502,5,'0',0);
INSERT INTO "checklists_results" VALUES (76,159,1,4,0,95,5,'0',0);
INSERT INTO "checklists_results" VALUES (77,164,1,5,0,310,6,'0',0);
INSERT INTO "checklists_results" VALUES (78,178,1,6,0,532,7,'0',0);
INSERT INTO "checklists_results" VALUES (79,179,1,6,0,532,7,'0',0);
INSERT INTO "checklists_results" VALUES (80,188,1,6,0,210,7,'0',0);
INSERT INTO "checklists_results" VALUES (81,199,1,7,0,922,8,'0',0);
INSERT INTO "checklists_results" VALUES (82,200,1,7,0,922,8,'0',0);
INSERT INTO "checklists_results" VALUES (83,201,1,7,0,319,8,'0',0);
INSERT INTO "checklists_results" VALUES (84,202,1,7,0,212,8,'0',0);
INSERT INTO "checklists_results" VALUES (85,203,1,7,0,285,8,'0',0);
INSERT INTO "checklists_results" VALUES (86,204,1,7,0,200,8,'0',0);
INSERT INTO "checklists_results" VALUES (87,210,1,8,0,319,9,'0',0);
INSERT INTO "checklists_results" VALUES (88,211,1,8,0,326,9,'0',0);
INSERT INTO "checklists_results" VALUES (89,212,1,8,0,326,9,'0',0);
INSERT INTO "checklists_results" VALUES (90,226,1,9,0,2,10,'0',0);
INSERT INTO "checklists_results" VALUES (91,227,1,9,0,353,10,'0',0);
INSERT INTO "checklists_results" VALUES (92,228,1,9,0,350,10,'0',0);
INSERT INTO "checklists_results" VALUES (93,230,1,10,0,841,11,'0',0);
INSERT INTO "checklists_results" VALUES (94,231,1,10,0,779,11,'0',0);
INSERT INTO "checklists_results" VALUES (95,232,1,10,0,770,11,'0',0);
INSERT INTO "checklists_results" VALUES (96,233,1,10,0,770,11,'0',0);
INSERT INTO "checklists_results" VALUES (97,234,1,10,0,841,11,'0',0);
INSERT INTO "checklists_results" VALUES (98,239,1,11,0,400,12,'0',0);
INSERT INTO "checklists_results" VALUES (99,243,1,11,0,22,12,'0',0);
INSERT INTO "checklists_results" VALUES (100,244,1,11,0,73,12,'0',0);
INSERT INTO "checklists_results" VALUES (101,245,1,11,0,98,12,'0',0);
INSERT INTO "checklists_results" VALUES (102,246,1,11,0,641,12,'0',0);
INSERT INTO "checklists_results" VALUES (103,247,1,11,0,78,12,'0',0);
INSERT INTO "checklists_results" VALUES (104,249,1,11,0,922,12,'0',0);
INSERT INTO "checklists_results" VALUES (105,250,1,11,0,509,12,'0',0);
INSERT INTO "checklists_results" VALUES (106,251,1,11,0,552,12,'0',0);
INSERT INTO "checklists_results" VALUES (107,252,1,11,0,434,12,'0',0);
INSERT INTO "checklists_results" VALUES (108,253,1,11,0,918,12,'0',0);
INSERT INTO "checklists_results" VALUES (109,255,1,12,0,116,13,'0',0);
INSERT INTO "checklists_results" VALUES (110,256,1,12,0,419,13,'0',0);
INSERT INTO "checklists_results" VALUES (111,257,1,12,0,598,13,'0',0);
INSERT INTO "checklists_results" VALUES (112,260,1,12,0,650,13,'0',0);
INSERT INTO "checklists_results" VALUES (113,261,1,12,0,20,13,'0',0);
INSERT INTO "checklists_results" VALUES (114,262,1,12,0,352,13,'0',0);
INSERT INTO "checklists_results" VALUES (115,266,1,12,0,20,13,'0',0);
INSERT INTO "checklists_results" VALUES (116,276,1,13,0,1104,14,'0',0);
INSERT INTO "checklists_results" VALUES (117,277,1,13,0,531,14,'0',0);
INSERT INTO "checklists_results" VALUES (118,278,1,13,0,15,14,'0',0);
INSERT INTO "checklists_results" VALUES (119,284,1,13,0,200,14,'0',0);
INSERT INTO "checklists_results" VALUES (120,285,1,13,0,173,14,'0',0);
INSERT INTO "checklists_results" VALUES (121,286,1,13,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (122,287,1,13,0,1021,14,'0',0);
INSERT INTO "checklists_results" VALUES (123,288,1,13,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (124,289,1,13,0,523,14,'0',0);
INSERT INTO "checklists_results" VALUES (125,290,1,13,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (126,291,1,13,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (127,292,1,13,0,749,14,'0',0);
INSERT INTO "checklists_results" VALUES (128,293,1,13,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (129,294,1,13,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (130,282,1,13,0,209,14,'0',0);
INSERT INTO "checklists_results" VALUES (131,283,1,13,0,497,14,'0',0);
INSERT INTO "checklists_results" VALUES (132,2,2,14,0,272,1,'0',0);
INSERT INTO "checklists_results" VALUES (133,5,2,14,0,1059,1,'0',0);
INSERT INTO "checklists_results" VALUES (134,6,2,14,0,1059,1,'0',0);
INSERT INTO "checklists_results" VALUES (135,8,2,14,0,637,1,'0',0);
INSERT INTO "checklists_results" VALUES (136,9,2,14,0,250,1,'0',0);
INSERT INTO "checklists_results" VALUES (137,10,2,14,0,306,1,'0',0);
INSERT INTO "checklists_results" VALUES (138,11,2,14,0,306,1,'0',0);
INSERT INTO "checklists_results" VALUES (139,12,2,14,0,306,1,'0',0);
INSERT INTO "checklists_results" VALUES (140,13,2,14,0,602,1,'0',0);
INSERT INTO "checklists_results" VALUES (141,14,2,14,0,284,1,'0',0);
INSERT INTO "checklists_results" VALUES (142,15,2,14,0,272,1,'0',0);
INSERT INTO "checklists_results" VALUES (143,16,2,14,0,284,1,'0',0);
INSERT INTO "checklists_results" VALUES (144,17,2,14,0,274,1,'0',0);
INSERT INTO "checklists_results" VALUES (145,18,2,14,0,20,1,'0',0);
INSERT INTO "checklists_results" VALUES (146,19,2,14,0,502,1,'0',0);
INSERT INTO "checklists_results" VALUES (147,20,2,14,0,602,1,'0',0);
INSERT INTO "checklists_results" VALUES (148,21,2,14,0,116,1,'0',0);
INSERT INTO "checklists_results" VALUES (149,22,2,14,0,320,1,'0',0);
INSERT INTO "checklists_results" VALUES (150,24,2,14,0,204,1,'0',0);
INSERT INTO "checklists_results" VALUES (151,25,2,14,0,277,1,'0',0);
INSERT INTO "checklists_results" VALUES (152,26,2,14,0,1009,1,'0',0);
INSERT INTO "checklists_results" VALUES (153,27,2,14,0,2,1,'0',0);
INSERT INTO "checklists_results" VALUES (154,28,2,14,0,278,1,'0',0);
INSERT INTO "checklists_results" VALUES (155,29,2,14,0,278,1,'0',0);
INSERT INTO "checklists_results" VALUES (156,30,2,14,0,319,1,'0',0);
INSERT INTO "checklists_results" VALUES (157,31,2,14,0,295,1,'0',0);
INSERT INTO "checklists_results" VALUES (158,32,2,14,0,284,1,'0',0);
INSERT INTO "checklists_results" VALUES (159,33,2,14,0,1059,1,'0',0);
INSERT INTO "checklists_results" VALUES (160,34,2,14,0,362,1,'0',0);
INSERT INTO "checklists_results" VALUES (161,36,2,14,0,552,1,'0',0);
INSERT INTO "checklists_results" VALUES (162,37,2,14,0,646,1,'0',0);
INSERT INTO "checklists_results" VALUES (163,38,2,14,0,923,1,'0',0);
INSERT INTO "checklists_results" VALUES (164,39,2,14,0,494,1,'0',0);
INSERT INTO "checklists_results" VALUES (165,40,2,14,0,1104,1,'0',0);
INSERT INTO "checklists_results" VALUES (166,41,2,14,0,281,1,'0',0);
INSERT INTO "checklists_results" VALUES (167,42,2,14,0,265,1,'0',0);
INSERT INTO "checklists_results" VALUES (168,43,2,14,0,477,1,'0',0);
INSERT INTO "checklists_results" VALUES (169,3,2,14,0,1053,1,'0',0);
INSERT INTO "checklists_results" VALUES (170,4,2,14,0,1110,1,'0',0);
INSERT INTO "checklists_results" VALUES (171,7,2,14,0,184,1,'0',0);
INSERT INTO "checklists_results" VALUES (172,23,2,14,0,320,1,'0',0);
INSERT INTO "checklists_results" VALUES (173,45,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (174,46,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (175,47,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (176,48,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (177,49,2,15,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (178,50,2,15,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (179,51,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (180,52,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (181,53,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (182,54,2,15,0,263,2,'0',0);
INSERT INTO "checklists_results" VALUES (183,55,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (184,56,2,15,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (185,57,2,15,0,307,2,'0',0);
INSERT INTO "checklists_results" VALUES (186,58,2,15,0,304,2,'0',0);
INSERT INTO "checklists_results" VALUES (187,59,2,15,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (188,64,2,15,0,330,2,'0',0);
INSERT INTO "checklists_results" VALUES (189,65,2,15,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (190,66,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (191,67,2,15,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (192,68,2,15,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (193,69,2,15,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (194,70,2,15,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (195,71,2,15,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (196,72,2,15,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (197,73,2,15,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (198,74,2,15,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (199,75,2,15,0,276,2,'0',0);
INSERT INTO "checklists_results" VALUES (200,76,2,15,0,304,2,'0',0);
INSERT INTO "checklists_results" VALUES (201,77,2,15,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (202,78,2,15,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (203,79,2,15,0,290,2,'0',0);
INSERT INTO "checklists_results" VALUES (204,80,2,15,0,330,2,'0',0);
INSERT INTO "checklists_results" VALUES (205,81,2,15,0,310,2,'0',0);
INSERT INTO "checklists_results" VALUES (206,82,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (207,83,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (208,84,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (209,85,2,15,0,523,2,'0',0);
INSERT INTO "checklists_results" VALUES (210,86,2,15,0,256,2,'0',0);
INSERT INTO "checklists_results" VALUES (211,87,2,15,0,310,2,'0',0);
INSERT INTO "checklists_results" VALUES (212,88,2,15,0,613,2,'0',0);
INSERT INTO "checklists_results" VALUES (213,89,2,15,0,320,2,'0',0);
INSERT INTO "checklists_results" VALUES (214,90,2,15,0,326,2,'0',0);
INSERT INTO "checklists_results" VALUES (215,91,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (216,92,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (217,93,2,15,0,613,2,'0',0);
INSERT INTO "checklists_results" VALUES (218,95,2,15,0,320,2,'0',0);
INSERT INTO "checklists_results" VALUES (219,96,2,15,0,330,2,'0',0);
INSERT INTO "checklists_results" VALUES (220,97,2,15,0,327,2,'0',0);
INSERT INTO "checklists_results" VALUES (221,98,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (222,99,2,15,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (223,100,2,15,0,522,2,'0',0);
INSERT INTO "checklists_results" VALUES (224,101,2,15,0,798,2,'0',0);
INSERT INTO "checklists_results" VALUES (225,103,2,16,0,598,3,'0',0);
INSERT INTO "checklists_results" VALUES (226,104,2,16,0,384,3,'0',0);
INSERT INTO "checklists_results" VALUES (227,105,2,16,0,311,3,'0',0);
INSERT INTO "checklists_results" VALUES (228,106,2,16,0,539,3,'0',0);
INSERT INTO "checklists_results" VALUES (229,107,2,16,0,331,3,'0',0);
INSERT INTO "checklists_results" VALUES (230,108,2,16,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (231,109,2,16,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (232,110,2,16,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (233,111,2,16,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (234,112,2,16,0,614,3,'0',0);
INSERT INTO "checklists_results" VALUES (235,113,2,16,0,1004,3,'0',0);
INSERT INTO "checklists_results" VALUES (236,114,2,16,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (237,115,2,16,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (238,116,2,16,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (239,117,2,16,0,290,3,'0',0);
INSERT INTO "checklists_results" VALUES (240,118,2,16,0,798,3,'0',0);
INSERT INTO "checklists_results" VALUES (241,119,2,16,0,345,3,'0',0);
INSERT INTO "checklists_results" VALUES (242,120,2,16,0,778,3,'0',0);
INSERT INTO "checklists_results" VALUES (243,122,2,17,0,602,4,'0',0);
INSERT INTO "checklists_results" VALUES (244,123,2,17,0,639,4,'0',0);
INSERT INTO "checklists_results" VALUES (245,124,2,17,0,285,4,'0',0);
INSERT INTO "checklists_results" VALUES (246,125,2,17,0,276,4,'0',0);
INSERT INTO "checklists_results" VALUES (247,126,2,17,0,285,4,'0',0);
INSERT INTO "checklists_results" VALUES (248,127,2,17,0,639,4,'0',0);
INSERT INTO "checklists_results" VALUES (249,128,2,17,0,352,4,'0',0);
INSERT INTO "checklists_results" VALUES (250,129,2,17,0,419,4,'0',0);
INSERT INTO "checklists_results" VALUES (251,130,2,17,0,548,4,'0',0);
INSERT INTO "checklists_results" VALUES (252,131,2,17,0,732,4,'0',0);
INSERT INTO "checklists_results" VALUES (253,133,2,18,0,235,5,'0',0);
INSERT INTO "checklists_results" VALUES (254,134,2,18,0,915,5,'0',0);
INSERT INTO "checklists_results" VALUES (255,135,2,18,0,20,5,'0',0);
INSERT INTO "checklists_results" VALUES (256,136,2,18,0,20,5,'0',0);
INSERT INTO "checklists_results" VALUES (257,137,2,18,0,601,5,'0',0);
INSERT INTO "checklists_results" VALUES (258,138,2,18,0,116,5,'0',0);
INSERT INTO "checklists_results" VALUES (259,139,2,18,0,138,5,'0',0);
INSERT INTO "checklists_results" VALUES (260,140,2,18,0,147,5,'0',0);
INSERT INTO "checklists_results" VALUES (261,141,2,18,0,95,5,'0',0);
INSERT INTO "checklists_results" VALUES (262,142,2,18,0,94,5,'0',0);
INSERT INTO "checklists_results" VALUES (263,143,2,18,0,918,5,'0',0);
INSERT INTO "checklists_results" VALUES (264,144,2,18,0,159,5,'0',0);
INSERT INTO "checklists_results" VALUES (265,145,2,18,0,94,5,'0',0);
INSERT INTO "checklists_results" VALUES (266,146,2,18,0,116,5,'0',0);
INSERT INTO "checklists_results" VALUES (267,147,2,18,0,176,5,'0',0);
INSERT INTO "checklists_results" VALUES (268,148,2,18,0,79,5,'0',0);
INSERT INTO "checklists_results" VALUES (269,151,2,18,0,830,5,'0',0);
INSERT INTO "checklists_results" VALUES (270,154,2,18,0,829,5,'0',0);
INSERT INTO "checklists_results" VALUES (271,149,2,18,0,89,5,'0',0);
INSERT INTO "checklists_results" VALUES (272,150,2,18,0,89,5,'0',0);
INSERT INTO "checklists_results" VALUES (273,152,2,18,0,943,5,'0',0);
INSERT INTO "checklists_results" VALUES (274,153,2,18,0,78,5,'0',0);
INSERT INTO "checklists_results" VALUES (275,155,2,18,0,643,5,'0',0);
INSERT INTO "checklists_results" VALUES (276,156,2,18,0,502,5,'0',0);
INSERT INTO "checklists_results" VALUES (277,157,2,18,0,611,5,'0',0);
INSERT INTO "checklists_results" VALUES (278,158,2,18,0,502,5,'0',0);
INSERT INTO "checklists_results" VALUES (279,159,2,18,0,95,5,'0',0);
INSERT INTO "checklists_results" VALUES (280,161,2,19,0,311,6,'0',0);
INSERT INTO "checklists_results" VALUES (281,162,2,19,0,311,6,'0',0);
INSERT INTO "checklists_results" VALUES (282,163,2,19,0,311,6,'0',0);
INSERT INTO "checklists_results" VALUES (283,164,2,19,0,310,6,'0',0);
INSERT INTO "checklists_results" VALUES (284,165,2,19,0,327,6,'0',0);
INSERT INTO "checklists_results" VALUES (285,166,2,19,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (286,167,2,19,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (287,168,2,19,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (288,169,2,19,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (289,172,2,19,0,338,6,'0',0);
INSERT INTO "checklists_results" VALUES (290,173,2,19,0,338,6,'0',0);
INSERT INTO "checklists_results" VALUES (291,175,2,19,0,798,6,'0',0);
INSERT INTO "checklists_results" VALUES (292,176,2,19,0,320,6,'0',0);
INSERT INTO "checklists_results" VALUES (293,178,2,20,0,532,7,'0',0);
INSERT INTO "checklists_results" VALUES (294,179,2,20,0,532,7,'0',0);
INSERT INTO "checklists_results" VALUES (295,180,2,20,0,778,7,'0',0);
INSERT INTO "checklists_results" VALUES (296,181,2,20,0,778,7,'0',0);
INSERT INTO "checklists_results" VALUES (297,182,2,20,0,778,7,'0',0);
INSERT INTO "checklists_results" VALUES (298,183,2,20,0,285,7,'0',0);
INSERT INTO "checklists_results" VALUES (299,184,2,20,0,117,7,'0',0);
INSERT INTO "checklists_results" VALUES (300,185,2,20,0,117,7,'0',0);
INSERT INTO "checklists_results" VALUES (301,186,2,20,0,200,7,'0',0);
INSERT INTO "checklists_results" VALUES (302,187,2,20,0,2,7,'0',0);
INSERT INTO "checklists_results" VALUES (303,188,2,20,0,210,7,'0',0);
INSERT INTO "checklists_results" VALUES (304,189,2,20,0,544,7,'0',0);
INSERT INTO "checklists_results" VALUES (305,190,2,20,0,460,7,'0',0);
INSERT INTO "checklists_results" VALUES (306,192,2,21,0,532,8,'0',0);
INSERT INTO "checklists_results" VALUES (307,194,2,21,0,233,8,'0',0);
INSERT INTO "checklists_results" VALUES (308,195,2,21,0,525,8,'0',0);
INSERT INTO "checklists_results" VALUES (309,199,2,21,0,922,8,'0',0);
INSERT INTO "checklists_results" VALUES (310,200,2,21,0,922,8,'0',0);
INSERT INTO "checklists_results" VALUES (311,201,2,21,0,319,8,'0',0);
INSERT INTO "checklists_results" VALUES (312,202,2,21,0,212,8,'0',0);
INSERT INTO "checklists_results" VALUES (313,203,2,21,0,285,8,'0',0);
INSERT INTO "checklists_results" VALUES (314,204,2,21,0,200,8,'0',0);
INSERT INTO "checklists_results" VALUES (315,205,2,21,0,532,8,'0',0);
INSERT INTO "checklists_results" VALUES (316,206,2,21,0,226,8,'0',0);
INSERT INTO "checklists_results" VALUES (317,207,2,21,0,525,8,'0',0);
INSERT INTO "checklists_results" VALUES (318,208,2,21,0,285,8,'0',0);
INSERT INTO "checklists_results" VALUES (319,210,2,22,0,319,9,'0',0);
INSERT INTO "checklists_results" VALUES (320,211,2,22,0,326,9,'0',0);
INSERT INTO "checklists_results" VALUES (321,212,2,22,0,326,9,'0',0);
INSERT INTO "checklists_results" VALUES (322,213,2,22,0,295,9,'0',0);
INSERT INTO "checklists_results" VALUES (323,214,2,22,0,319,9,'0',0);
INSERT INTO "checklists_results" VALUES (324,215,2,22,0,297,9,'0',0);
INSERT INTO "checklists_results" VALUES (325,216,2,22,0,299,9,'0',0);
INSERT INTO "checklists_results" VALUES (326,220,2,23,0,359,10,'0',0);
INSERT INTO "checklists_results" VALUES (327,221,2,23,0,272,10,'0',0);
INSERT INTO "checklists_results" VALUES (328,226,2,23,0,2,10,'0',0);
INSERT INTO "checklists_results" VALUES (329,227,2,23,0,353,10,'0',0);
INSERT INTO "checklists_results" VALUES (330,228,2,23,0,350,10,'0',0);
INSERT INTO "checklists_results" VALUES (331,230,2,24,0,841,11,'0',0);
INSERT INTO "checklists_results" VALUES (332,231,2,24,0,779,11,'0',0);
INSERT INTO "checklists_results" VALUES (333,232,2,24,0,770,11,'0',0);
INSERT INTO "checklists_results" VALUES (334,233,2,24,0,770,11,'0',0);
INSERT INTO "checklists_results" VALUES (335,237,2,24,0,390,11,'0',0);
INSERT INTO "checklists_results" VALUES (336,234,2,24,0,841,11,'0',0);
INSERT INTO "checklists_results" VALUES (337,235,2,24,0,367,11,'0',0);
INSERT INTO "checklists_results" VALUES (338,236,2,24,0,754,11,'0',0);
INSERT INTO "checklists_results" VALUES (339,239,2,25,0,400,12,'0',0);
INSERT INTO "checklists_results" VALUES (340,240,2,25,0,400,12,'0',0);
INSERT INTO "checklists_results" VALUES (341,241,2,25,0,409,12,'0',0);
INSERT INTO "checklists_results" VALUES (342,242,2,25,0,434,12,'0',0);
INSERT INTO "checklists_results" VALUES (343,243,2,25,0,22,12,'0',0);
INSERT INTO "checklists_results" VALUES (344,244,2,25,0,73,12,'0',0);
INSERT INTO "checklists_results" VALUES (345,245,2,25,0,98,12,'0',0);
INSERT INTO "checklists_results" VALUES (346,246,2,25,0,641,12,'0',0);
INSERT INTO "checklists_results" VALUES (347,247,2,25,0,78,12,'0',0);
INSERT INTO "checklists_results" VALUES (348,248,2,25,0,829,12,'0',0);
INSERT INTO "checklists_results" VALUES (349,249,2,25,0,922,12,'0',0);
INSERT INTO "checklists_results" VALUES (350,250,2,25,0,509,12,'0',0);
INSERT INTO "checklists_results" VALUES (351,251,2,25,0,552,12,'0',0);
INSERT INTO "checklists_results" VALUES (352,252,2,25,0,434,12,'0',0);
INSERT INTO "checklists_results" VALUES (353,253,2,25,0,918,12,'0',0);
INSERT INTO "checklists_results" VALUES (354,255,2,26,0,116,13,'0',0);
INSERT INTO "checklists_results" VALUES (355,256,2,26,0,419,13,'0',0);
INSERT INTO "checklists_results" VALUES (356,257,2,26,0,598,13,'0',0);
INSERT INTO "checklists_results" VALUES (357,258,2,26,0,285,13,'0',0);
INSERT INTO "checklists_results" VALUES (358,259,2,26,0,434,13,'0',0);
INSERT INTO "checklists_results" VALUES (359,260,2,26,0,650,13,'0',0);
INSERT INTO "checklists_results" VALUES (360,261,2,26,0,20,13,'0',0);
INSERT INTO "checklists_results" VALUES (361,262,2,26,0,352,13,'0',0);
INSERT INTO "checklists_results" VALUES (362,263,2,26,0,779,13,'0',0);
INSERT INTO "checklists_results" VALUES (363,264,2,26,0,436,13,'0',0);
INSERT INTO "checklists_results" VALUES (364,265,2,26,0,598,13,'0',0);
INSERT INTO "checklists_results" VALUES (365,266,2,26,0,20,13,'0',0);
INSERT INTO "checklists_results" VALUES (366,267,2,26,0,345,13,'0',0);
INSERT INTO "checklists_results" VALUES (367,268,2,26,0,770,13,'0',0);
INSERT INTO "checklists_results" VALUES (368,269,2,26,0,285,13,'0',0);
INSERT INTO "checklists_results" VALUES (369,271,2,27,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (370,272,2,27,0,120,14,'0',0);
INSERT INTO "checklists_results" VALUES (371,273,2,27,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (372,274,2,27,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (373,276,2,27,0,1104,14,'0',0);
INSERT INTO "checklists_results" VALUES (374,277,2,27,0,531,14,'0',0);
INSERT INTO "checklists_results" VALUES (375,278,2,27,0,15,14,'0',0);
INSERT INTO "checklists_results" VALUES (376,279,2,27,0,828,14,'0',0);
INSERT INTO "checklists_results" VALUES (377,280,2,27,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (378,281,2,27,0,265,14,'0',0);
INSERT INTO "checklists_results" VALUES (379,284,2,27,0,200,14,'0',0);
INSERT INTO "checklists_results" VALUES (380,285,2,27,0,173,14,'0',0);
INSERT INTO "checklists_results" VALUES (381,286,2,27,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (382,287,2,27,0,1021,14,'0',0);
INSERT INTO "checklists_results" VALUES (383,288,2,27,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (384,289,2,27,0,523,14,'0',0);
INSERT INTO "checklists_results" VALUES (385,290,2,27,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (386,291,2,27,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (387,292,2,27,0,749,14,'0',0);
INSERT INTO "checklists_results" VALUES (388,293,2,27,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (389,294,2,27,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (390,295,2,27,0,306,14,'0',0);
INSERT INTO "checklists_results" VALUES (391,282,2,27,0,209,14,'0',0);
INSERT INTO "checklists_results" VALUES (392,283,2,27,0,497,14,'0',0);
INSERT INTO "checklists_results" VALUES (393,2,3,28,0,272,1,'0',0);
INSERT INTO "checklists_results" VALUES (394,5,3,28,0,1059,1,'0',0);
INSERT INTO "checklists_results" VALUES (395,6,3,28,0,1059,1,'0',0);
INSERT INTO "checklists_results" VALUES (396,8,3,28,0,637,1,'0',0);
INSERT INTO "checklists_results" VALUES (397,9,3,28,0,250,1,'0',0);
INSERT INTO "checklists_results" VALUES (398,10,3,28,0,306,1,'0',0);
INSERT INTO "checklists_results" VALUES (399,11,3,28,0,306,1,'0',0);
INSERT INTO "checklists_results" VALUES (400,12,3,28,0,306,1,'0',0);
INSERT INTO "checklists_results" VALUES (401,13,3,28,0,602,1,'0',0);
INSERT INTO "checklists_results" VALUES (402,14,3,28,0,284,1,'0',0);
INSERT INTO "checklists_results" VALUES (403,15,3,28,0,272,1,'0',0);
INSERT INTO "checklists_results" VALUES (404,16,3,28,0,284,1,'0',0);
INSERT INTO "checklists_results" VALUES (405,17,3,28,0,274,1,'0',0);
INSERT INTO "checklists_results" VALUES (406,18,3,28,0,20,1,'0',0);
INSERT INTO "checklists_results" VALUES (407,19,3,28,0,502,1,'0',0);
INSERT INTO "checklists_results" VALUES (408,20,3,28,0,602,1,'0',0);
INSERT INTO "checklists_results" VALUES (409,21,3,28,0,116,1,'0',0);
INSERT INTO "checklists_results" VALUES (410,22,3,28,0,320,1,'0',0);
INSERT INTO "checklists_results" VALUES (411,24,3,28,0,204,1,'0',0);
INSERT INTO "checklists_results" VALUES (412,25,3,28,0,277,1,'0',0);
INSERT INTO "checklists_results" VALUES (413,26,3,28,0,1009,1,'0',0);
INSERT INTO "checklists_results" VALUES (414,27,3,28,0,2,1,'0',0);
INSERT INTO "checklists_results" VALUES (415,28,3,28,0,278,1,'0',0);
INSERT INTO "checklists_results" VALUES (416,29,3,28,0,278,1,'0',0);
INSERT INTO "checklists_results" VALUES (417,30,3,28,0,319,1,'0',0);
INSERT INTO "checklists_results" VALUES (418,31,3,28,0,295,1,'0',0);
INSERT INTO "checklists_results" VALUES (419,32,3,28,0,284,1,'0',0);
INSERT INTO "checklists_results" VALUES (420,33,3,28,0,1059,1,'0',0);
INSERT INTO "checklists_results" VALUES (421,34,3,28,0,362,1,'0',0);
INSERT INTO "checklists_results" VALUES (422,35,3,28,0,362,1,'0',0);
INSERT INTO "checklists_results" VALUES (423,36,3,28,0,552,1,'0',0);
INSERT INTO "checklists_results" VALUES (424,37,3,28,0,646,1,'0',0);
INSERT INTO "checklists_results" VALUES (425,38,3,28,0,923,1,'0',0);
INSERT INTO "checklists_results" VALUES (426,39,3,28,0,494,1,'0',0);
INSERT INTO "checklists_results" VALUES (427,40,3,28,0,1104,1,'0',0);
INSERT INTO "checklists_results" VALUES (428,41,3,28,0,281,1,'0',0);
INSERT INTO "checklists_results" VALUES (429,42,3,28,0,265,1,'0',0);
INSERT INTO "checklists_results" VALUES (430,43,3,28,0,477,1,'0',0);
INSERT INTO "checklists_results" VALUES (431,3,3,28,0,1053,1,'0',0);
INSERT INTO "checklists_results" VALUES (432,4,3,28,0,1110,1,'0',0);
INSERT INTO "checklists_results" VALUES (433,7,3,28,0,184,1,'0',0);
INSERT INTO "checklists_results" VALUES (434,23,3,28,0,320,1,'0',0);
INSERT INTO "checklists_results" VALUES (435,45,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (436,46,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (437,47,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (438,48,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (439,49,3,29,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (440,50,3,29,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (441,51,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (442,52,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (443,53,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (444,54,3,29,0,263,2,'0',0);
INSERT INTO "checklists_results" VALUES (445,55,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (446,56,3,29,0,521,2,'0',0);
INSERT INTO "checklists_results" VALUES (447,57,3,29,0,307,2,'0',0);
INSERT INTO "checklists_results" VALUES (448,58,3,29,0,304,2,'0',0);
INSERT INTO "checklists_results" VALUES (449,59,3,29,0,620,2,'0',0);
INSERT INTO "checklists_results" VALUES (450,60,3,29,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (451,61,3,29,0,319,2,'0',0);
INSERT INTO "checklists_results" VALUES (452,62,3,29,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (453,63,3,29,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (454,64,3,29,0,330,2,'0',0);
INSERT INTO "checklists_results" VALUES (455,65,3,29,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (456,66,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (457,67,3,29,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (458,68,3,29,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (459,69,3,29,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (460,70,3,29,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (461,71,3,29,0,916,2,'0',0);
INSERT INTO "checklists_results" VALUES (462,72,3,29,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (463,73,3,29,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (464,74,3,29,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (465,75,3,29,0,276,2,'0',0);
INSERT INTO "checklists_results" VALUES (466,76,3,29,0,304,2,'0',0);
INSERT INTO "checklists_results" VALUES (467,77,3,29,0,640,2,'0',0);
INSERT INTO "checklists_results" VALUES (468,78,3,29,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (469,79,3,29,0,290,2,'0',0);
INSERT INTO "checklists_results" VALUES (470,80,3,29,0,330,2,'0',0);
INSERT INTO "checklists_results" VALUES (471,81,3,29,0,310,2,'0',0);
INSERT INTO "checklists_results" VALUES (472,82,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (473,83,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (474,84,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (475,85,3,29,0,523,2,'0',0);
INSERT INTO "checklists_results" VALUES (476,86,3,29,0,256,2,'0',0);
INSERT INTO "checklists_results" VALUES (477,87,3,29,0,310,2,'0',0);
INSERT INTO "checklists_results" VALUES (478,88,3,29,0,613,2,'0',0);
INSERT INTO "checklists_results" VALUES (479,89,3,29,0,320,2,'0',0);
INSERT INTO "checklists_results" VALUES (480,90,3,29,0,326,2,'0',0);
INSERT INTO "checklists_results" VALUES (481,91,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (482,92,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (483,93,3,29,0,613,2,'0',0);
INSERT INTO "checklists_results" VALUES (484,94,3,29,0,308,2,'0',0);
INSERT INTO "checklists_results" VALUES (485,95,3,29,0,320,2,'0',0);
INSERT INTO "checklists_results" VALUES (486,96,3,29,0,330,2,'0',0);
INSERT INTO "checklists_results" VALUES (487,97,3,29,0,327,2,'0',0);
INSERT INTO "checklists_results" VALUES (488,98,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (489,99,3,29,0,287,2,'0',0);
INSERT INTO "checklists_results" VALUES (490,100,3,29,0,522,2,'0',0);
INSERT INTO "checklists_results" VALUES (491,101,3,29,0,798,2,'0',0);
INSERT INTO "checklists_results" VALUES (492,103,3,30,0,598,3,'0',0);
INSERT INTO "checklists_results" VALUES (493,104,3,30,0,384,3,'0',0);
INSERT INTO "checklists_results" VALUES (494,105,3,30,0,311,3,'0',0);
INSERT INTO "checklists_results" VALUES (495,106,3,30,0,539,3,'0',0);
INSERT INTO "checklists_results" VALUES (496,107,3,30,0,331,3,'0',0);
INSERT INTO "checklists_results" VALUES (497,108,3,30,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (498,109,3,30,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (499,110,3,30,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (500,111,3,30,0,613,3,'0',0);
INSERT INTO "checklists_results" VALUES (501,112,3,30,0,614,3,'0',0);
INSERT INTO "checklists_results" VALUES (502,113,3,30,0,1004,3,'0',0);
INSERT INTO "checklists_results" VALUES (503,114,3,30,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (504,115,3,30,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (505,116,3,30,0,2,3,'0',0);
INSERT INTO "checklists_results" VALUES (506,117,3,30,0,290,3,'0',0);
INSERT INTO "checklists_results" VALUES (507,118,3,30,0,798,3,'0',0);
INSERT INTO "checklists_results" VALUES (508,119,3,30,0,345,3,'0',0);
INSERT INTO "checklists_results" VALUES (509,120,3,30,0,778,3,'0',0);
INSERT INTO "checklists_results" VALUES (510,122,3,31,0,602,4,'0',0);
INSERT INTO "checklists_results" VALUES (511,123,3,31,0,639,4,'0',0);
INSERT INTO "checklists_results" VALUES (512,124,3,31,0,285,4,'0',0);
INSERT INTO "checklists_results" VALUES (513,125,3,31,0,276,4,'0',0);
INSERT INTO "checklists_results" VALUES (514,126,3,31,0,285,4,'0',0);
INSERT INTO "checklists_results" VALUES (515,127,3,31,0,639,4,'0',0);
INSERT INTO "checklists_results" VALUES (516,128,3,31,0,352,4,'0',0);
INSERT INTO "checklists_results" VALUES (517,129,3,31,0,419,4,'0',0);
INSERT INTO "checklists_results" VALUES (518,130,3,31,0,548,4,'0',0);
INSERT INTO "checklists_results" VALUES (519,131,3,31,0,732,4,'0',0);
INSERT INTO "checklists_results" VALUES (520,133,3,32,0,235,5,'0',0);
INSERT INTO "checklists_results" VALUES (521,134,3,32,0,915,5,'0',0);
INSERT INTO "checklists_results" VALUES (522,135,3,32,0,20,5,'0',0);
INSERT INTO "checklists_results" VALUES (523,136,3,32,0,20,5,'0',0);
INSERT INTO "checklists_results" VALUES (524,137,3,32,0,601,5,'0',0);
INSERT INTO "checklists_results" VALUES (525,138,3,32,0,116,5,'0',0);
INSERT INTO "checklists_results" VALUES (526,139,3,32,0,138,5,'0',0);
INSERT INTO "checklists_results" VALUES (527,140,3,32,0,147,5,'0',0);
INSERT INTO "checklists_results" VALUES (528,141,3,32,0,95,5,'0',0);
INSERT INTO "checklists_results" VALUES (529,142,3,32,0,94,5,'0',0);
INSERT INTO "checklists_results" VALUES (530,143,3,32,0,918,5,'0',0);
INSERT INTO "checklists_results" VALUES (531,144,3,32,0,159,5,'0',0);
INSERT INTO "checklists_results" VALUES (532,145,3,32,0,94,5,'0',0);
INSERT INTO "checklists_results" VALUES (533,146,3,32,0,116,5,'0',0);
INSERT INTO "checklists_results" VALUES (534,147,3,32,0,176,5,'0',0);
INSERT INTO "checklists_results" VALUES (535,148,3,32,0,79,5,'0',0);
INSERT INTO "checklists_results" VALUES (536,151,3,32,0,830,5,'0',0);
INSERT INTO "checklists_results" VALUES (537,154,3,32,0,829,5,'0',0);
INSERT INTO "checklists_results" VALUES (538,149,3,32,0,89,5,'0',0);
INSERT INTO "checklists_results" VALUES (539,150,3,32,0,89,5,'0',0);
INSERT INTO "checklists_results" VALUES (540,152,3,32,0,943,5,'0',0);
INSERT INTO "checklists_results" VALUES (541,153,3,32,0,78,5,'0',0);
INSERT INTO "checklists_results" VALUES (542,155,3,32,0,643,5,'0',0);
INSERT INTO "checklists_results" VALUES (543,156,3,32,0,502,5,'0',0);
INSERT INTO "checklists_results" VALUES (544,157,3,32,0,611,5,'0',0);
INSERT INTO "checklists_results" VALUES (545,158,3,32,0,502,5,'0',0);
INSERT INTO "checklists_results" VALUES (546,159,3,32,0,95,5,'0',0);
INSERT INTO "checklists_results" VALUES (547,161,3,33,0,311,6,'0',0);
INSERT INTO "checklists_results" VALUES (548,162,3,33,0,311,6,'0',0);
INSERT INTO "checklists_results" VALUES (549,163,3,33,0,311,6,'0',0);
INSERT INTO "checklists_results" VALUES (550,164,3,33,0,310,6,'0',0);
INSERT INTO "checklists_results" VALUES (551,165,3,33,0,327,6,'0',0);
INSERT INTO "checklists_results" VALUES (552,166,3,33,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (553,167,3,33,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (554,168,3,33,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (555,169,3,33,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (556,170,3,33,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (557,171,3,33,0,326,6,'0',0);
INSERT INTO "checklists_results" VALUES (558,172,3,33,0,338,6,'0',0);
INSERT INTO "checklists_results" VALUES (559,173,3,33,0,338,6,'0',0);
INSERT INTO "checklists_results" VALUES (560,174,3,33,0,338,6,'0',0);
INSERT INTO "checklists_results" VALUES (561,175,3,33,0,798,6,'0',0);
INSERT INTO "checklists_results" VALUES (562,176,3,33,0,320,6,'0',0);
INSERT INTO "checklists_results" VALUES (563,178,3,34,0,532,7,'0',0);
INSERT INTO "checklists_results" VALUES (564,179,3,34,0,532,7,'0',0);
INSERT INTO "checklists_results" VALUES (565,180,3,34,0,778,7,'0',0);
INSERT INTO "checklists_results" VALUES (566,181,3,34,0,778,7,'0',0);
INSERT INTO "checklists_results" VALUES (567,182,3,34,0,778,7,'0',0);
INSERT INTO "checklists_results" VALUES (568,183,3,34,0,285,7,'0',0);
INSERT INTO "checklists_results" VALUES (569,184,3,34,0,117,7,'0',0);
INSERT INTO "checklists_results" VALUES (570,185,3,34,0,117,7,'0',0);
INSERT INTO "checklists_results" VALUES (571,186,3,34,0,200,7,'0',0);
INSERT INTO "checklists_results" VALUES (572,187,3,34,0,2,7,'0',0);
INSERT INTO "checklists_results" VALUES (573,188,3,34,0,210,7,'0',0);
INSERT INTO "checklists_results" VALUES (574,189,3,34,0,544,7,'0',0);
INSERT INTO "checklists_results" VALUES (575,190,3,34,0,460,7,'0',0);
INSERT INTO "checklists_results" VALUES (576,192,3,35,0,532,8,'0',0);
INSERT INTO "checklists_results" VALUES (577,194,3,35,0,233,8,'0',0);
INSERT INTO "checklists_results" VALUES (578,195,3,35,0,525,8,'0',0);
INSERT INTO "checklists_results" VALUES (579,196,3,35,0,770,8,'0',0);
INSERT INTO "checklists_results" VALUES (580,197,3,35,0,300,8,'0',0);
INSERT INTO "checklists_results" VALUES (581,199,3,35,0,922,8,'0',0);
INSERT INTO "checklists_results" VALUES (582,200,3,35,0,922,8,'0',0);
INSERT INTO "checklists_results" VALUES (583,201,3,35,0,319,8,'0',0);
INSERT INTO "checklists_results" VALUES (584,202,3,35,0,212,8,'0',0);
INSERT INTO "checklists_results" VALUES (585,203,3,35,0,285,8,'0',0);
INSERT INTO "checklists_results" VALUES (586,204,3,35,0,200,8,'0',0);
INSERT INTO "checklists_results" VALUES (587,205,3,35,0,532,8,'0',0);
INSERT INTO "checklists_results" VALUES (588,206,3,35,0,226,8,'0',0);
INSERT INTO "checklists_results" VALUES (589,207,3,35,0,525,8,'0',0);
INSERT INTO "checklists_results" VALUES (590,208,3,35,0,285,8,'0',0);
INSERT INTO "checklists_results" VALUES (591,210,3,36,0,319,9,'0',0);
INSERT INTO "checklists_results" VALUES (592,211,3,36,0,326,9,'0',0);
INSERT INTO "checklists_results" VALUES (593,212,3,36,0,326,9,'0',0);
INSERT INTO "checklists_results" VALUES (594,213,3,36,0,295,9,'0',0);
INSERT INTO "checklists_results" VALUES (595,214,3,36,0,319,9,'0',0);
INSERT INTO "checklists_results" VALUES (596,215,3,36,0,297,9,'0',0);
INSERT INTO "checklists_results" VALUES (597,216,3,36,0,299,9,'0',0);
INSERT INTO "checklists_results" VALUES (598,217,3,36,0,544,9,'0',0);
INSERT INTO "checklists_results" VALUES (599,219,3,37,0,749,10,'0',0);
INSERT INTO "checklists_results" VALUES (600,220,3,37,0,359,10,'0',0);
INSERT INTO "checklists_results" VALUES (601,221,3,37,0,272,10,'0',0);
INSERT INTO "checklists_results" VALUES (602,222,3,37,0,507,10,'0',0);
INSERT INTO "checklists_results" VALUES (603,223,3,37,0,511,10,'0',0);
INSERT INTO "checklists_results" VALUES (604,224,3,37,0,511,10,'0',0);
INSERT INTO "checklists_results" VALUES (605,225,3,37,0,507,10,'0',0);
INSERT INTO "checklists_results" VALUES (606,226,3,37,0,2,10,'0',0);
INSERT INTO "checklists_results" VALUES (607,227,3,37,0,353,10,'0',0);
INSERT INTO "checklists_results" VALUES (608,228,3,37,0,350,10,'0',0);
INSERT INTO "checklists_results" VALUES (609,230,3,38,0,841,11,'0',0);
INSERT INTO "checklists_results" VALUES (610,231,3,38,0,779,11,'0',0);
INSERT INTO "checklists_results" VALUES (611,232,3,38,0,770,11,'0',0);
INSERT INTO "checklists_results" VALUES (612,233,3,38,0,770,11,'0',0);
INSERT INTO "checklists_results" VALUES (613,237,3,38,0,390,11,'0',0);
INSERT INTO "checklists_results" VALUES (614,234,3,38,0,841,11,'0',0);
INSERT INTO "checklists_results" VALUES (615,235,3,38,0,367,11,'0',0);
INSERT INTO "checklists_results" VALUES (616,236,3,38,0,754,11,'0',0);
INSERT INTO "checklists_results" VALUES (617,239,3,39,0,400,12,'0',0);
INSERT INTO "checklists_results" VALUES (618,240,3,39,0,400,12,'0',0);
INSERT INTO "checklists_results" VALUES (619,241,3,39,0,409,12,'0',0);
INSERT INTO "checklists_results" VALUES (620,242,3,39,0,434,12,'0',0);
INSERT INTO "checklists_results" VALUES (621,243,3,39,0,22,12,'0',0);
INSERT INTO "checklists_results" VALUES (622,244,3,39,0,73,12,'0',0);
INSERT INTO "checklists_results" VALUES (623,245,3,39,0,98,12,'0',0);
INSERT INTO "checklists_results" VALUES (624,246,3,39,0,641,12,'0',0);
INSERT INTO "checklists_results" VALUES (625,247,3,39,0,78,12,'0',0);
INSERT INTO "checklists_results" VALUES (626,248,3,39,0,829,12,'0',0);
INSERT INTO "checklists_results" VALUES (627,249,3,39,0,922,12,'0',0);
INSERT INTO "checklists_results" VALUES (628,250,3,39,0,509,12,'0',0);
INSERT INTO "checklists_results" VALUES (629,251,3,39,0,552,12,'0',0);
INSERT INTO "checklists_results" VALUES (630,252,3,39,0,434,12,'0',0);
INSERT INTO "checklists_results" VALUES (631,253,3,39,0,918,12,'0',0);
INSERT INTO "checklists_results" VALUES (632,255,3,40,0,116,13,'0',0);
INSERT INTO "checklists_results" VALUES (633,256,3,40,0,419,13,'0',0);
INSERT INTO "checklists_results" VALUES (634,257,3,40,0,598,13,'0',0);
INSERT INTO "checklists_results" VALUES (635,258,3,40,0,285,13,'0',0);
INSERT INTO "checklists_results" VALUES (636,259,3,40,0,434,13,'0',0);
INSERT INTO "checklists_results" VALUES (637,260,3,40,0,650,13,'0',0);
INSERT INTO "checklists_results" VALUES (638,261,3,40,0,20,13,'0',0);
INSERT INTO "checklists_results" VALUES (639,262,3,40,0,352,13,'0',0);
INSERT INTO "checklists_results" VALUES (640,263,3,40,0,779,13,'0',0);
INSERT INTO "checklists_results" VALUES (641,264,3,40,0,436,13,'0',0);
INSERT INTO "checklists_results" VALUES (642,265,3,40,0,598,13,'0',0);
INSERT INTO "checklists_results" VALUES (643,266,3,40,0,20,13,'0',0);
INSERT INTO "checklists_results" VALUES (644,267,3,40,0,345,13,'0',0);
INSERT INTO "checklists_results" VALUES (645,268,3,40,0,770,13,'0',0);
INSERT INTO "checklists_results" VALUES (646,269,3,40,0,285,13,'0',0);
INSERT INTO "checklists_results" VALUES (647,271,3,41,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (648,272,3,41,0,120,14,'0',0);
INSERT INTO "checklists_results" VALUES (649,273,3,41,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (650,274,3,41,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (651,275,3,41,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (652,276,3,41,0,1104,14,'0',0);
INSERT INTO "checklists_results" VALUES (653,277,3,41,0,531,14,'0',0);
INSERT INTO "checklists_results" VALUES (654,278,3,41,0,15,14,'0',0);
INSERT INTO "checklists_results" VALUES (655,279,3,41,0,828,14,'0',0);
INSERT INTO "checklists_results" VALUES (656,280,3,41,0,2,14,'0',0);
INSERT INTO "checklists_results" VALUES (657,281,3,41,0,265,14,'0',0);
INSERT INTO "checklists_results" VALUES (658,284,3,41,0,200,14,'0',0);
INSERT INTO "checklists_results" VALUES (659,285,3,41,0,173,14,'0',0);
INSERT INTO "checklists_results" VALUES (660,286,3,41,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (661,287,3,41,0,1021,14,'0',0);
INSERT INTO "checklists_results" VALUES (662,288,3,41,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (663,289,3,41,0,523,14,'0',0);
INSERT INTO "checklists_results" VALUES (664,290,3,41,0,116,14,'0',0);
INSERT INTO "checklists_results" VALUES (665,291,3,41,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (666,292,3,41,0,749,14,'0',0);
INSERT INTO "checklists_results" VALUES (667,293,3,41,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (668,294,3,41,0,346,14,'0',0);
INSERT INTO "checklists_results" VALUES (669,295,3,41,0,306,14,'0',0);
INSERT INTO "checklists_results" VALUES (670,282,3,41,0,209,14,'0',0);
INSERT INTO "checklists_results" VALUES (671,283,3,41,0,497,14,'0',0);
COMMIT;
